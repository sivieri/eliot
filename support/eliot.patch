diff -ruN1 otp/erts/emulator/beam/bif.c erlang2/erts/emulator/beam/bif.c
--- otp/erts/emulator/beam/bif.c	2013-06-25 16:35:13.399123162 +0200
+++ erlang2/erts/emulator/beam/bif.c	2013-06-25 16:36:07.531124502 +0200
@@ -38,2 +38,3 @@
 #include "register.h"
+#include "pexport.h"
 #include "erl_thr_progress.h"
@@ -1743,3 +1744,13 @@
 {
-    return erl_send(BIF_P, BIF_ARG_1, BIF_ARG_2);
+    return erl_send_reliable(BIF_P, BIF_ARG_1, BIF_ARG_2, 1);
+}
+
+/*
+ * erlang:'~'/2
+ */
+
+BIF_RETTYPE
+ebif_tilde_2(BIF_ALIST_2)
+{
+    return erl_send_reliable(BIF_P, BIF_ARG_1, BIF_ARG_2, 0);
 }
@@ -1759,5 +1770,6 @@
 Sint do_send(Process *p, Eterm to, Eterm msg, int suspend);
+Sint do_send_reliable(Process *p, Eterm to, Eterm msg, int suspend, int reliable);
 
-static Sint remote_send(Process *p, DistEntry *dep,
-			Eterm to, Eterm full_to, Eterm msg, int suspend)
+static Sint remote_send_reliable(Process *p, DistEntry *dep,
+            Eterm to, Eterm full_to, Eterm msg, int suspend, int reliable)
 {
@@ -1781,6 +1793,6 @@
 
-	if (is_atom(to))
-	    code = erts_dsig_send_reg_msg(&dsd, to, msg);
-	else
-	    code = erts_dsig_send_msg(&dsd, to, msg);
+    if (is_atom(to))
+        code = erts_dsig_send_reg_msg_reliable(&dsd, to, msg, reliable);
+    else
+        code = erts_dsig_send_msg_reliable(&dsd, to, msg, reliable);
 	/*
@@ -1813,2 +1825,7 @@
 do_send(Process *p, Eterm to, Eterm msg, int suspend) {
+    return do_send_reliable(p, to, msg, suspend, 1);
+}
+
+Sint
+do_send_reliable(Process *p, Eterm to, Eterm msg, int suspend, int reliable) {
     Eterm portid;
@@ -1850,43 +1867,59 @@
 	}
-	return remote_send(p, dep, to, to, msg, suspend);
+	return remote_send_reliable(p, dep, to, to, msg, suspend, reliable);
     } else if (is_atom(to)) {
-	
-	/* Need to virtual schedule out sending process
-	 * because of lock wait. This is only necessary
-	 * for internal port calling but the lock is bundled
-	 * with name lookup.
-	 */
-	    
-	if (IS_TRACED_FL(p, F_TRACE_SCHED_PROCS)) {
-	    trace_virtual_sched(p, am_out);
-	}
-	if (erts_system_profile_flags.runnable_procs && erts_system_profile_flags.exclusive) {
-	    profile_runnable_proc(p, am_inactive);
-	}
-	erts_whereis_name(p, ERTS_PROC_LOCK_MAIN,
-			  to,
-			  &rp, 0, ERTS_P2P_FLG_SMP_INC_REFC,
-			  &pt);
-
-	if (pt) {
-	    portid = pt->id;
-	    goto port_common;
-	}
-	
-	/* Not a port virtually schedule the process back in */
-	if (IS_TRACED_FL(p, F_TRACE_SCHED_PROCS)) {
-	    trace_virtual_sched(p, am_in);
-	}
-	if (erts_system_profile_flags.runnable_procs && erts_system_profile_flags.exclusive) {
-	    profile_runnable_proc(p, am_active);
-	}
-
-	if (IS_TRACED(p))
-	    trace_send(p, to, msg);
-	if (ERTS_PROC_GET_SAVED_CALLS_BUF(p))
-	    save_calls(p, &exp_send);
-	
-	if (!rp) {
-	    return SEND_BADARG;
-	}
+        int ret;
+        
+        if (to != am_all) { /* Standard send invocation */
+        
+        /* Need to virtual schedule out sending process
+        * because of lock wait. This is only necessary
+        * for internal port calling but the lock is bundled
+        * with name lookup.
+        */
+            
+        if (IS_TRACED_FL(p, F_TRACE_SCHED_PROCS)) {
+            trace_virtual_sched(p, am_out);
+        }
+        if (erts_system_profile_flags.runnable_procs && erts_system_profile_flags.exclusive) {
+            profile_runnable_proc(p, am_inactive);
+        }
+        erts_whereis_name(p, ERTS_PROC_LOCK_MAIN,
+                to,
+                &rp, 0, ERTS_P2P_FLG_SMP_INC_REFC,
+                &pt);
+
+        if (pt) {
+            portid = pt->id;
+            goto port_common;
+        }
+        
+        /* Not a port virtually schedule the process back in */
+        if (IS_TRACED_FL(p, F_TRACE_SCHED_PROCS)) {
+            trace_virtual_sched(p, am_in);
+        }
+        if (erts_system_profile_flags.runnable_procs && erts_system_profile_flags.exclusive) {
+            profile_runnable_proc(p, am_active);
+        }
+
+        if (IS_TRACED(p))
+            trace_send(p, to, msg);
+        if (ERTS_PROC_GET_SAVED_CALLS_BUF(p))
+            save_calls(p, &exp_send);
+        
+        if (!rp) {
+            return SEND_BADARG;
+        }
+    }
+    else {
+        /* Broadcast to all nodes {all, all}
+            * This transmission is always unreliable, regardless of
+            * the use of bang or tilde
+            */
+        ret = 0;
+        Eterm* hp = HAlloc(p, 3);
+        Eterm arg = TUPLE2(hp, am_all, am_all);
+        ret = erl_send_reliable(p, arg, msg, 0) || ret;
+        
+        return ret;
+    }
     } else if (is_external_port(to)
@@ -1991,2 +2024,9 @@
 	    return SEND_BADARG;
+    /* Sending to all is handled by the 'all' port, so no distinction here
+     * between unicast and broadcast, except for the fact that a broadcast
+     * communication is always unreliable
+     */  
+    if (tp[2] == am_all) {
+        reliable = 0;
+    }
 	
@@ -2042,3 +2082,3 @@
 
-	ret = remote_send(p, dep, tp[1], to, msg, suspend);
+	ret = remote_send_reliable(p, dep, tp[1], to, msg, suspend, reliable);
 	if (dep)
@@ -2161,3 +2201,8 @@
 {
-    Sint result = do_send(p, to, msg, !0);
+    return erl_send_reliable(p, to, msg, 1);
+}
+
+Eterm erl_send_reliable(Process *p, Eterm to, Eterm msg, int reliable)
+{
+    Sint result = do_send_reliable(p, to, msg, !0, reliable);
     
@@ -4821,2 +4866,49 @@
 
+/* export(atom|Process) exports a process
+   (for this node) */
+
+BIF_RETTYPE export_1(BIF_ALIST_1)   /* (Atom|Pid)   */
+{
+    int res;
+    
+    if (is_atom(BIF_ARG_1))
+    {
+        erts_printf("DEBUG: Exporting atom %T\n", BIF_ARG_1);
+        res = erts_export_process_by_name(BIF_P, BIF_ARG_1);
+    }
+    else
+    {
+        erts_printf("DEBUG: Exporting pid %T\n", BIF_ARG_1);
+        res = erts_export_process_by_pid(BIF_P, BIF_ARG_1);
+    }
+    if (res)
+        BIF_RET(am_true);
+    else {
+        BIF_ERROR(BIF_P, BADARG);
+    }
+}
+
+
+/**********************************************************************/
+
+/* removes the export of a process */
+
+BIF_RETTYPE unexport_1(BIF_ALIST_1)
+{
+    int res;
+    
+    erts_printf("DEBUG: Unexporting %T\n", BIF_ARG_1);
+    if (is_atom(BIF_ARG_1)) {
+        res = erts_unexport_process_by_name(BIF_P, ERTS_PROC_LOCK_MAIN, NULL, BIF_ARG_1);
+    }
+    else {
+        res = erts_unexport_process_by_pid(BIF_P, ERTS_PROC_LOCK_MAIN, NULL, BIF_ARG_1);
+    }
+    if (res == 0) {
+        BIF_ERROR(BIF_P, BADARG);
+    }
+    BIF_RET(am_true);
+}
+
+/**********************************************************************/
 
diff -ruN1 otp/erts/emulator/beam/bif.tab erlang2/erts/emulator/beam/bif.tab
--- otp/erts/emulator/beam/bif.tab	2013-06-25 16:35:13.399123162 +0200
+++ erlang2/erts/emulator/beam/bif.tab	2013-06-25 16:36:07.531124502 +0200
@@ -836 +836,17 @@
 bif erlang:hash/2
+
+# New in ELIoT
+bif erlang:export/1
+bif 'erl.lang.node':export/1      ebif_export_1
+bif erlang:exported/0
+bif 'erl.lang.node':exported/0    ebif_exported_0
+bif erlang:unexport/1
+bif 'erl.lang.node':unexport/1    ebif_unexport_1
+bif erlang:'~'/2        ebif_tilde_2
+
+# Clocks
+bif unixtime:clock/0
+bif unixtime:gettimeofday/0
+bif unixtime:clock_gettime/0
+bif unixtime:times/0
+bif unixtime:getrusage/0
diff -ruN1 otp/erts/emulator/beam/dist.c erlang2/erts/emulator/beam/dist.c
--- otp/erts/emulator/beam/dist.c	2013-06-25 16:35:13.399123162 +0200
+++ erlang2/erts/emulator/beam/dist.c	2013-06-25 16:36:07.531124502 +0200
@@ -44,2 +44,3 @@
 #include "erl_thr_progress.h"
+#include "pexport.h"
 #include "dtrace-wrapper.h"
@@ -69,24 +70,24 @@
     Eterm msg;
-    Sint size = erts_decode_dist_ext_size(edep, 0);
+    Sint size = erts_decode_dist_ext_size(edep);
     if (size < 0) {
-	erts_fprintf(stderr,
-		     "DIST MSG DEBUG: erts_decode_dist_ext_size(%s) failed:\n",
-		     what);
-	bw(buf, sz);
+        erts_fprintf(stderr,
+                "DIST MSG DEBUG: erts_decode_dist_ext_size(%s) failed:\n",
+                what);
+        bw(buf, sz);
     }
     else {
-	Eterm *hp;
-	ErlHeapFragment *mbuf = new_message_buffer(size);
-	hp = mbuf->mem;
-	msg = erts_decode_dist_ext(&hp, &mbuf->off_heap, edep);
-	if (is_value(msg))
-	    erts_fprintf(stderr, "    %s: %T\n", what, msg);
-	else {
-	    erts_fprintf(stderr,
-			 "DIST MSG DEBUG: erts_decode_dist_ext(%s) failed:\n",
-			 what);
-	    bw(buf, sz);
-	}
-	free_message_buffer(mbuf);
-	edep->extp = extp;
+        Eterm *hp;
+        ErlHeapFragment *mbuf = new_message_buffer(size);
+        hp = mbuf->mem;
+        msg = erts_decode_dist_ext(&hp, &mbuf->off_heap, edep);
+        if (is_value(msg))
+            erts_fprintf(stderr, "    %s: %T\n", what, msg);
+        else {
+            erts_fprintf(stderr,
+                    "DIST MSG DEBUG: erts_decode_dist_ext(%s) failed:\n",
+                    what);
+            bw(buf, sz);
+        }
+        free_message_buffer(mbuf);
+        edep->extp = extp;
     }
@@ -122,2 +123,3 @@
 static int dsig_send(ErtsDSigData *, Eterm, Eterm, int);
+static int dsig_send_reliable(ErtsDSigData *, Eterm, Eterm, int, int);
 static void send_nodes_mon_msgs(Process *, Eterm, Eterm, Eterm, Eterm);
@@ -131,5 +133,5 @@
     if (cache) {
-	erts_free(ERTS_ALC_T_DCACHE, (void *) cache);
-	ASSERT(erts_smp_atomic_read_nob(&no_caches) > 0);
-	erts_smp_atomic_dec_nob(&no_caches);
+        erts_free(ERTS_ALC_T_DCACHE, (void *) cache);
+        ASSERT(erts_smp_atomic_read_nob(&no_caches) > 0);
+        erts_smp_atomic_dec_nob(&no_caches);
     }
@@ -145,4 +147,4 @@
     ERTS_SMP_LC_ASSERT(
-	is_internal_port(dep->cid)
-	&& erts_lc_is_port_locked(&erts_port[internal_port_index(dep->cid)]));
+            is_internal_port(dep->cid)
+            && erts_lc_is_port_locked(&erts_port[internal_port_index(dep->cid)]));
     ASSERT(!dep->cache);
@@ -150,7 +152,7 @@
     dep->cache = cp = (ErtsAtomCache*) erts_alloc(ERTS_ALC_T_DCACHE,
-						  sizeof(ErtsAtomCache));
+            sizeof(ErtsAtomCache));
     erts_smp_atomic_inc_nob(&no_caches);
     for (i = 0; i < sizeof(cp->in_arr)/sizeof(cp->in_arr[0]); i++) {
-	cp->in_arr[i] = THE_NON_VALUE;
-	cp->out_arr[i] = THE_NON_VALUE;
+        cp->in_arr[i] = THE_NON_VALUE;
+        cp->out_arr[i] = THE_NON_VALUE;
     }
@@ -169,11 +171,11 @@
     if (dep->qflgs & ERTS_DE_QFLG_EXIT) {
-	/* No resume when exit has been scheduled */
-	return NULL;
+        /* No resume when exit has been scheduled */
+        return NULL;
     }
     else {
-	ErtsProcList *plp;
-	plp = dep->suspended.first;
-	dep->suspended.first = NULL;
-	dep->suspended.last = NULL;
-	return plp;
+        ErtsProcList *plp;
+        plp = dep->suspended.first;
+        dep->suspended.first = NULL;
+        dep->suspended.last = NULL;
+        return plp;
     }
@@ -182,12 +184,12 @@
 /*
-** A full node name constists of a "n@h"
-**
-** n must be a valid node name: string of ([a-z][A-Z][0-9]_-)+
-** 
-** h is not checked at all, we assume that we have a properly
-** configured machine where the networking is ok for the OS
-**
-** We do check that there is not a second @ in the string, since
-** many distributed operations are guaranteed not to work then.
-*/
+ ** A full node name constists of a "n@h"
+ **
+ ** n must be a valid node name: string of ([a-z][A-Z][0-9]_-)+
+ ** 
+ ** h is not checked at all, we assume that we have a properly
+ ** configured machine where the networking is ok for the OS
+ **
+ ** We do check that there is not a second @ in the string, since
+ ** many distributed operations are guaranteed not to work then.
+ */
 
@@ -196,26 +198,26 @@
 {
-   int c = '\0';		/* suppress use-before-set warning */
-   int pos = 0;
+    int c = '\0';		/* suppress use-before-set warning */
+    int pos = 0;
 
-   while (pos < len) {
-      c = ptr[pos++];
-      if (! ((c == '-') || (c == '_') ||
-	     ((c >= 'a') && (c <= 'z')) ||
-	     ((c >= 'A') && (c <= 'Z')) ||
-	     ((c >= '0') && (c <= '9'))))
-	 break;
-   }
+    while (pos < len) {
+        c = ptr[pos++];
+        if (! ((c == '-') || (c == '_') ||
+                ((c >= 'a') && (c <= 'z')) ||
+                ((c >= 'A') && (c <= 'Z')) ||
+                ((c >= '0') && (c <= '9'))))
+            break;
+    }
 
-   /* Scanned past the host name: now we want to see a '@', and there
+    /* Scanned past the host name: now we want to see a '@', and there
       should be text both before and after it. */
-   if (c != '@' || pos < 2 || pos == len)
-      return 0;
+    if (c != '@' || pos < 2 || pos == len)
+        return 0;
 
-   while (pos < len) {
-      c = ptr[pos++];
-      if (c == '@')
-	 return 0;
-   }
+    while (pos < len) {
+        c = ptr[pos++];
+        if (c == '@')
+            return 0;
+    }
 
-   return 1;
+    return 1;
 }
@@ -226,3 +228,3 @@
     if(is_not_atom(a))
-	return 0;
+        return 0;
     i = atom_val(a);
@@ -233,4 +235,4 @@
 typedef struct {
-    DistEntry *dep;
-    Eterm *lhp;
+        DistEntry *dep;
+        Eterm *lhp;
 } NetExitsContext;
@@ -238,5 +240,5 @@
 /* 
-** This function is called when a distribution 
-** port or process terminates
-*/
+ ** This function is called when a distribution 
+ ** port or process terminates
+ */
 static void doit_monitor_net_exits(ErtsMonitor *mon, void *vnecp)
@@ -250,41 +252,41 @@
     if (!rp)
-	goto done;
+        goto done;
 
     if (mon->type == MON_ORIGIN) {
-	/* local pid is beeing monitored */
-	rmon = erts_remove_monitor(&(rp->monitors),mon->ref);
-	/* ASSERT(rmon != NULL); nope, can happen during process exit */
-	if (rmon != NULL) {
-	    erts_destroy_monitor(rmon);
-	}
+        /* local pid is beeing monitored */
+        rmon = erts_remove_monitor(&(rp->monitors),mon->ref);
+        /* ASSERT(rmon != NULL); nope, can happen during process exit */
+        if (rmon != NULL) {
+            erts_destroy_monitor(rmon);
+        }
     } else {
-	DeclareTmpHeapNoproc(lhp,3);
-	Eterm watched;
-	UseTmpHeapNoproc(3);
-	ASSERT(mon->type == MON_TARGET);
-	rmon = erts_remove_monitor(&(rp->monitors),mon->ref);
-	/* ASSERT(rmon != NULL); can happen during process exit */
-	if (rmon != NULL) {
-	    ASSERT(is_atom(rmon->name) || is_nil(rmon->name));
-	    watched = (is_atom(rmon->name)
-		       ? TUPLE2(lhp, rmon->name, dep->sysname)
-		       : rmon->pid);
+        DeclareTmpHeapNoproc(lhp,3);
+        Eterm watched;
+        UseTmpHeapNoproc(3);
+        ASSERT(mon->type == MON_TARGET);
+        rmon = erts_remove_monitor(&(rp->monitors),mon->ref);
+        /* ASSERT(rmon != NULL); can happen during process exit */
+        if (rmon != NULL) {
+            ASSERT(is_atom(rmon->name) || is_nil(rmon->name));
+            watched = (is_atom(rmon->name)
+                    ? TUPLE2(lhp, rmon->name, dep->sysname)
+                            : rmon->pid);
 #ifdef ERTS_SMP
-	    rp_locks |= ERTS_PROC_LOCKS_MSG_SEND;
-	    erts_smp_proc_lock(rp, ERTS_PROC_LOCKS_MSG_SEND);
+            rp_locks |= ERTS_PROC_LOCKS_MSG_SEND;
+            erts_smp_proc_lock(rp, ERTS_PROC_LOCKS_MSG_SEND);
 #endif
-	    erts_queue_monitor_message(rp, &rp_locks, mon->ref, am_process, 
-				       watched, am_noconnection);
-	    erts_destroy_monitor(rmon);
-	}
-	UnUseTmpHeapNoproc(3);
+            erts_queue_monitor_message(rp, &rp_locks, mon->ref, am_process, 
+                    watched, am_noconnection);
+            erts_destroy_monitor(rmon);
+        }
+        UnUseTmpHeapNoproc(3);
     }
     erts_smp_proc_unlock(rp, rp_locks);
- done:
+    done:
     erts_destroy_monitor(mon);
 }
-	
+
 typedef struct {
-    NetExitsContext *necp;
-    ErtsLink *lnk;
+        NetExitsContext *necp;
+        ErtsLink *lnk;
 } LinkNetExitsContext;
@@ -292,7 +294,7 @@
 /* 
-** This is the function actually doing the job of sending exit messages
-** for links in a dist entry upon net_exit (the node goes down), NB,
-** only process links, not node monitors are handled here, 
-** they reside in a separate tree....
-*/
+ ** This is the function actually doing the job of sending exit messages
+ ** for links in a dist entry upon net_exit (the node goes down), NB,
+ ** only process links, not node monitors are handled here, 
+ ** they reside in a separate tree....
+ */
 static void doit_link_net_exits_sub(ErtsLink *sublnk, void *vlnecp)
@@ -305,30 +307,30 @@
     if (is_internal_pid(lnk->pid)) {
-	int xres;
-	ErtsProcLocks rp_locks = ERTS_PROC_LOCK_LINK|ERTS_PROC_LOCKS_XSIG_SEND;
+        int xres;
+        ErtsProcLocks rp_locks = ERTS_PROC_LOCK_LINK|ERTS_PROC_LOCKS_XSIG_SEND;
+
+        rp = erts_pid2proc(NULL, 0, lnk->pid, rp_locks);
+        if (!rp) {
+            goto done;
+        }
 
-	rp = erts_pid2proc(NULL, 0, lnk->pid, rp_locks);
-	if (!rp) {
-	    goto done;
-	}
-
-	rlnk = erts_remove_link(&(rp->nlinks), sublnk->pid);
-	xres = erts_send_exit_signal(NULL,
-				     sublnk->pid,
-				     rp,
-				     &rp_locks,
-				     am_noconnection,
-				     NIL,
-				     NULL,
-				     0);
-
-	if (rlnk) {
-	    erts_destroy_link(rlnk);
-	    if (xres >= 0 && IS_TRACED_FL(rp, F_TRACE_PROCS)) {
-		/* We didn't exit the process and it is traced */
-		trace_proc(NULL, rp, am_getting_unlinked, sublnk->pid);
-	    }
-	}
-	erts_smp_proc_unlock(rp, rp_locks);
+        rlnk = erts_remove_link(&(rp->nlinks), sublnk->pid);
+        xres = erts_send_exit_signal(NULL,
+                sublnk->pid,
+                rp,
+                &rp_locks,
+                am_noconnection,
+                NIL,
+                NULL,
+                0);
+
+        if (rlnk) {
+            erts_destroy_link(rlnk);
+            if (xres >= 0 && IS_TRACED_FL(rp, F_TRACE_PROCS)) {
+                /* We didn't exit the process and it is traced */
+                trace_proc(NULL, rp, am_getting_unlinked, sublnk->pid);
+            }
+        }
+        erts_smp_proc_unlock(rp, rp_locks);
     }
- done:
+    done:
     erts_destroy_link(sublnk);
@@ -336,3 +338,3 @@
 }
-    
+
 
@@ -342,6 +344,6 @@
 /* 
-** This function is called when a distribution 
-** port or process terminates, once for each link on the high level, 
-** it in turn traverses the link subtree for the specific link node...
-*/
+ ** This function is called when a distribution 
+ ** port or process terminates, once for each link on the high level, 
+ ** it in turn traverses the link subtree for the specific link node...
+ */
 static void doit_link_net_exits(ErtsLink *lnk, void *vnecp)
@@ -367,28 +369,28 @@
     if (is_internal_pid(lnk->pid)) {
-	ErtsProcLocks rp_locks = ERTS_PROC_LOCK_LINK;
-	rp = erts_pid2proc(NULL, 0, lnk->pid, rp_locks);
-	if (!rp) {
-	    goto done;
-	}
-	rlnk = erts_remove_link(&(rp->nlinks), name);
-	if (rlnk != NULL) {
-	    ASSERT(is_atom(rlnk->pid) && (rlnk->type == LINK_NODE));
-	    erts_destroy_link(rlnk);
-	}
-	n = ERTS_LINK_REFC(lnk);
-	for (i = 0; i < n; ++i) {
-	    ErlHeapFragment* bp;
-	    ErlOffHeap *ohp;
-	    Eterm tup;
-	    Eterm *hp = erts_alloc_message_heap(3,&bp,&ohp,rp,&rp_locks);
-	    tup = TUPLE2(hp, am_nodedown, name);
-	    erts_queue_message(rp, &rp_locks, bp, tup, NIL
+        ErtsProcLocks rp_locks = ERTS_PROC_LOCK_LINK;
+        rp = erts_pid2proc(NULL, 0, lnk->pid, rp_locks);
+        if (!rp) {
+            goto done;
+        }
+        rlnk = erts_remove_link(&(rp->nlinks), name);
+        if (rlnk != NULL) {
+            ASSERT(is_atom(rlnk->pid) && (rlnk->type == LINK_NODE));
+            erts_destroy_link(rlnk);
+        }
+        n = ERTS_LINK_REFC(lnk);
+        for (i = 0; i < n; ++i) {
+            ErlHeapFragment* bp;
+            ErlOffHeap *ohp;
+            Eterm tup;
+            Eterm *hp = erts_alloc_message_heap(3,&bp,&ohp,rp,&rp_locks);
+            tup = TUPLE2(hp, am_nodedown, name);
+            erts_queue_message(rp, &rp_locks, bp, tup, NIL
 #ifdef USE_VM_PROBES
-			       , NIL
+                   , NIL
 #endif
-			       );
-	}
-	erts_smp_proc_unlock(rp, rp_locks);
+                   );
+        }
+        erts_smp_proc_unlock(rp, rp_locks);
     }
- done:
+    done:
     erts_destroy_link(lnk);
@@ -396,3 +398,3 @@
 
-	
+
 /*
@@ -405,40 +407,40 @@
     if (dep == erts_this_dist_entry) {  /* Net kernel has died (clean up!!) */
-	Eterm nd_reason = (reason == am_no_network
-			   ? am_no_network
-			   : am_net_kernel_terminated);
-	erts_smp_rwmtx_rwlock(&erts_dist_table_rwmtx);
-
-	/* KILL all port controllers */
-	while(erts_visible_dist_entries || erts_hidden_dist_entries) {
-	    DistEntry *tdep;
-	    Eterm prt_id;
-	    Port *prt;
-	    if(erts_hidden_dist_entries)
-		tdep = erts_hidden_dist_entries;
-	    else
-		tdep = erts_visible_dist_entries;
-	    prt_id = tdep->cid;
-	    ASSERT(is_internal_port(prt_id));
-	    erts_smp_rwmtx_rwunlock(&erts_dist_table_rwmtx);
-
-	    prt = erts_id2port(prt_id, NULL, 0);
-	    if (prt) {
-		ASSERT(prt->status & ERTS_PORT_SFLG_DISTRIBUTION);
-		ASSERT(prt->dist_entry);
-		/* will call do_net_exists !!! */
-		erts_do_exit_port(prt, prt_id, nd_reason);
-		erts_port_release(prt);
-	    }
-
-	    erts_smp_rwmtx_rwlock(&erts_dist_table_rwmtx);
-	}
-
-	erts_smp_rwmtx_rwunlock(&erts_dist_table_rwmtx);
-
-	nodename = erts_this_dist_entry->sysname;
-	erts_smp_thr_progress_block();
-	erts_set_this_node(am_Noname, 0);
-	erts_is_alive = 0;
-	send_nodes_mon_msgs(NULL, am_nodedown, nodename, am_visible, nd_reason);
-	erts_smp_thr_progress_unblock();
+        Eterm nd_reason = (reason == am_no_network
+                ? am_no_network
+                        : am_net_kernel_terminated);
+        erts_smp_rwmtx_rwlock(&erts_dist_table_rwmtx);
+
+        /* KILL all port controllers */
+        while(erts_visible_dist_entries || erts_hidden_dist_entries) {
+            DistEntry *tdep;
+            Eterm prt_id;
+            Port *prt;
+            if(erts_hidden_dist_entries)
+                tdep = erts_hidden_dist_entries;
+            else
+                tdep = erts_visible_dist_entries;
+            prt_id = tdep->cid;
+            ASSERT(is_internal_port(prt_id));
+            erts_smp_rwmtx_rwunlock(&erts_dist_table_rwmtx);
+
+            prt = erts_id2port(prt_id, NULL, 0);
+            if (prt) {
+                ASSERT(prt->status & ERTS_PORT_SFLG_DISTRIBUTION);
+                ASSERT(prt->dist_entry);
+                /* will call do_net_exists !!! */
+                erts_do_exit_port(prt, prt_id, nd_reason);
+                erts_port_release(prt);
+            }
+
+            erts_smp_rwmtx_rwlock(&erts_dist_table_rwmtx);
+        }
+
+        erts_smp_rwmtx_rwunlock(&erts_dist_table_rwmtx);
+
+        nodename = erts_this_dist_entry->sysname;
+        erts_smp_thr_progress_block();
+        erts_set_this_node(am_Noname, 0);
+        erts_is_alive = 0;
+        send_nodes_mon_msgs(NULL, am_nodedown, nodename, am_visible, nd_reason);
+        erts_smp_thr_progress_unblock();
 
@@ -446,59 +448,59 @@
     else { /* recursive call via erts_do_exit_port() will end up here */
-	NetExitsContext nec = {dep};
-	ErtsLink *nlinks;
-	ErtsLink *node_links;
-	ErtsMonitor *monitors;
-	Uint32 flags;
-
-	erts_smp_atomic_set_mb(&dep->dist_cmd_scheduled, 1);
-	erts_smp_de_rwlock(dep);
+        NetExitsContext nec = {dep};
+        ErtsLink *nlinks;
+        ErtsLink *node_links;
+        ErtsMonitor *monitors;
+        Uint32 flags;
+
+        erts_smp_atomic_set_mb(&dep->dist_cmd_scheduled, 1);
+        erts_smp_de_rwlock(dep);
 
-	ERTS_SMP_LC_ASSERT(is_internal_port(dep->cid)
-			   && erts_lc_is_port_locked(&erts_port[internal_port_index(dep->cid)]));
+        ERTS_SMP_LC_ASSERT(is_internal_port(dep->cid)
+                && erts_lc_is_port_locked(&erts_port[internal_port_index(dep->cid)]));
 
-	if (erts_port_task_is_scheduled(&dep->dist_cmd))
-	    erts_port_task_abort(dep->cid, &dep->dist_cmd);
+        if (erts_port_task_is_scheduled(&dep->dist_cmd))
+            erts_port_task_abort(dep->cid, &dep->dist_cmd);
 
-	if (dep->status & ERTS_DE_SFLG_EXITING) {
+        if (dep->status & ERTS_DE_SFLG_EXITING) {
 #ifdef DEBUG
-	    erts_smp_mtx_lock(&dep->qlock);
-	    ASSERT(dep->qflgs & ERTS_DE_QFLG_EXIT);
-	    erts_smp_mtx_unlock(&dep->qlock);
-#endif
-	}
-	else {
-	    dep->status |= ERTS_DE_SFLG_EXITING;
-	    erts_smp_mtx_lock(&dep->qlock);
-	    ASSERT(!(dep->qflgs & ERTS_DE_QFLG_EXIT));
-	    dep->qflgs |= ERTS_DE_QFLG_EXIT;
-	    erts_smp_mtx_unlock(&dep->qlock);
-	}
+            erts_smp_mtx_lock(&dep->qlock);
+            ASSERT(dep->qflgs & ERTS_DE_QFLG_EXIT);
+            erts_smp_mtx_unlock(&dep->qlock);
+#endif
+        }
+        else {
+            dep->status |= ERTS_DE_SFLG_EXITING;
+            erts_smp_mtx_lock(&dep->qlock);
+            ASSERT(!(dep->qflgs & ERTS_DE_QFLG_EXIT));
+            dep->qflgs |= ERTS_DE_QFLG_EXIT;
+            erts_smp_mtx_unlock(&dep->qlock);
+        }
 
-	erts_smp_de_links_lock(dep);
-	monitors	= dep->monitors;
+        erts_smp_de_links_lock(dep);
+        monitors	= dep->monitors;
         nlinks		= dep->nlinks;
-	node_links	= dep->node_links;
-	dep->monitors	= NULL;
+        node_links	= dep->node_links;
+        dep->monitors	= NULL;
         dep->nlinks	= NULL;
-	dep->node_links	= NULL;
-	erts_smp_de_links_unlock(dep);
+        dep->node_links	= NULL;
+        erts_smp_de_links_unlock(dep);
 
-	nodename = dep->sysname;
-	flags = dep->flags;
+        nodename = dep->sysname;
+        flags = dep->flags;
 
-	erts_set_dist_entry_not_connected(dep);
+        erts_set_dist_entry_not_connected(dep);
 
-	erts_smp_de_rwunlock(dep);
+        erts_smp_de_rwunlock(dep);
 
-	erts_sweep_monitors(monitors, &doit_monitor_net_exits, (void *) &nec);
-	erts_sweep_links(nlinks, &doit_link_net_exits, (void *) &nec);
-	erts_sweep_links(node_links, &doit_node_link_net_exits, (void *) &nec);
+        erts_sweep_monitors(monitors, &doit_monitor_net_exits, (void *) &nec);
+        erts_sweep_links(nlinks, &doit_link_net_exits, (void *) &nec);
+        erts_sweep_links(node_links, &doit_node_link_net_exits, (void *) &nec);
 
-	send_nodes_mon_msgs(NULL,
-			    am_nodedown,
-			    nodename,
-			    flags & DFLAG_PUBLISHED ? am_visible : am_hidden,
-			    reason == am_normal ? am_connection_closed : reason);
+        send_nodes_mon_msgs(NULL,
+                am_nodedown,
+                nodename,
+                flags & DFLAG_PUBLISHED ? am_visible : am_hidden,
+                        reason == am_normal ? am_connection_closed : reason);
 
-	clear_dist_entry(dep);
+        clear_dist_entry(dep);
 
@@ -533,3 +535,3 @@
 #define ErtsDistOutputBuf2Binary(OB) \
-  ((Binary *) (((char *) (OB)) - offsetof(Binary, orig_bytes)))
+        ((Binary *) (((char *) (OB)) - offsetof(Binary, orig_bytes)))
 
@@ -558,3 +560,3 @@
     if (erts_refc_dectest(&bin->refc, 0) == 0)
-	erts_bin_free(bin);
+        erts_bin_free(bin);
 }
@@ -590,6 +592,6 @@
     if (!dep->out_queue.last)
-	obuf = dep->finalized_out_queue.first;
+        obuf = dep->finalized_out_queue.first;
     else {
-	dep->out_queue.last->next = dep->finalized_out_queue.first;
-	obuf = dep->out_queue.first;
+        dep->out_queue.last->next = dep->finalized_out_queue.first;
+        obuf = dep->out_queue.first;
     }
@@ -613,7 +615,7 @@
     while (obuf) {
-	ErtsDistOutputBuf *fobuf;
-	fobuf = obuf;
-	obuf = obuf->next;
-	obufsize += size_obuf(fobuf);
-	free_dist_obuf(fobuf);
+        ErtsDistOutputBuf *fobuf;
+        fobuf = obuf;
+        obuf = obuf->next;
+        obufsize += size_obuf(fobuf);
+        free_dist_obuf(fobuf);
     }
@@ -621,6 +623,6 @@
     if (obufsize) {
-	erts_smp_mtx_lock(&dep->qlock);
-	ASSERT(dep->qsize >= obufsize);
-	dep->qsize -= obufsize;
-	erts_smp_mtx_unlock(&dep->qlock);
+        erts_smp_mtx_lock(&dep->qlock);
+        ASSERT(dep->qsize >= obufsize);
+        dep->qsize -= obufsize;
+        erts_smp_mtx_unlock(&dep->qlock);
     }
@@ -640,4 +642,4 @@
 /*
-** Send a DOP_LINK link message
-*/
+ ** Send a DOP_LINK link message
+ */
 int
@@ -674,3 +676,3 @@
 erts_dsig_send_m_exit(ErtsDSigData *dsdp, Eterm watcher, Eterm watched, 
-			  Eterm ref, Eterm reason)
+        Eterm ref, Eterm reason)
 {
@@ -683,3 +685,3 @@
     ctl = TUPLE5(&ctl_heap[0], make_small(DOP_MONITOR_P_EXIT),
-		 watched, watcher, ref, reason);
+            watched, watcher, ref, reason);
 
@@ -701,3 +703,3 @@
 erts_dsig_send_monitor(ErtsDSigData *dsdp, Eterm watcher, Eterm watched,
-		       Eterm ref)
+        Eterm ref)
 {
@@ -709,4 +711,4 @@
     ctl = TUPLE4(&ctl_heap[0],
-		 make_small(DOP_MONITOR_P),
-		 watcher, watched, ref);
+            make_small(DOP_MONITOR_P),
+            watcher, watched, ref);
 
@@ -723,3 +725,3 @@
 erts_dsig_send_demonitor(ErtsDSigData *dsdp, Eterm watcher,
-			 Eterm watched, Eterm ref, int force)
+        Eterm watched, Eterm ref, int force)
 {
@@ -731,4 +733,4 @@
     ctl = TUPLE4(&ctl_heap[0],
-		 make_small(DOP_DEMONITOR_P),
-		 watcher, watched, ref);
+            make_small(DOP_DEMONITOR_P),
+            watcher, watched, ref);
 
@@ -742,2 +744,8 @@
 {
+    return erts_dsig_send_msg_reliable(dsdp, remote, message, 1);
+}
+
+int
+erts_dsig_send_msg_reliable(ErtsDSigData *dsdp, Eterm remote, Eterm message, int reliable)
+{
     Eterm ctl;
@@ -758,10 +766,10 @@
     UseTmpHeapNoproc(5);
-    if (SEQ_TRACE_TOKEN(sender) != NIL 
+    if (SEQ_TRACE_TOKEN(sender) != NIL
 #ifdef USE_VM_PROBES
-	&& SEQ_TRACE_TOKEN(sender) != am_have_dt_utag 
+    && SEQ_TRACE_TOKEN(sender) != am_have_dt_utag 
 #endif
-	) {
-	seq_trace_update_send(sender);
-	token = SEQ_TRACE_TOKEN(sender);
-	seq_trace_output(token, message, SEQ_TRACE_SEND, remote, sender);
+    ) {
+        seq_trace_update_send(sender);
+        token = SEQ_TRACE_TOKEN(sender);
+        seq_trace_output(token, message, SEQ_TRACE_SEND, remote, sender);
     }
@@ -783,6 +791,6 @@
     if (token != NIL)
-	ctl = TUPLE4(&ctl_heap[0],
-		     make_small(DOP_SEND_TT), am_Cookie, remote, token);
+        ctl = TUPLE4(&ctl_heap[0],
+                make_small(DOP_SEND_TT), am_Cookie, remote, token);
     else
-	ctl = TUPLE3(&ctl_heap[0], make_small(DOP_SEND), am_Cookie, remote);
+        ctl = TUPLE2(&ctl_heap[0], make_small(DOP_SEND), remote);
     DTRACE6(message_send, sender_name, receiver_name,
@@ -791,3 +799,3 @@
             msize, tok_label, tok_lastcnt, tok_serial);
-    res = dsig_send(dsdp, ctl, message, 0);
+    res = dsig_send_reliable(dsdp, ctl, message, 0, reliable);
     UnUseTmpHeapNoproc(5);
@@ -799,2 +807,8 @@
 {
+    return erts_dsig_send_reg_msg_reliable(dsdp, remote_name, message, 1);
+}
+
+int
+erts_dsig_send_reg_msg_reliable(ErtsDSigData *dsdp, Eterm remote_name, Eterm message, int reliable)
+{
     Eterm ctl;
@@ -817,8 +831,8 @@
 #ifdef USE_VM_PROBES
-	&& SEQ_TRACE_TOKEN(sender) != am_have_dt_utag 
+    && SEQ_TRACE_TOKEN(sender) != am_have_dt_utag 
 #endif
-	) {
-	seq_trace_update_send(sender);
-	token = SEQ_TRACE_TOKEN(sender);
-	seq_trace_output(token, message, SEQ_TRACE_SEND, remote_name, sender);
+    ) {
+        seq_trace_update_send(sender);
+        token = SEQ_TRACE_TOKEN(sender);
+        seq_trace_output(token, message, SEQ_TRACE_SEND, remote_name, sender);
     }
@@ -841,7 +855,7 @@
     if (token != NIL)
-	ctl = TUPLE5(&ctl_heap[0], make_small(DOP_REG_SEND_TT),
-		     sender->id, am_Cookie, remote_name, token);
+        ctl = TUPLE5(&ctl_heap[0], make_small(DOP_REG_SEND_TT),
+                sender->id, am_Cookie, remote_name, token);
     else
-	ctl = TUPLE4(&ctl_heap[0], make_small(DOP_REG_SEND),
-		     sender->id, am_Cookie, remote_name);
+        ctl = TUPLE2(&ctl_heap[0], make_small(DOP_REG_SEND),
+                remote_name);
     DTRACE6(message_send, sender_name, receiver_name,
@@ -850,3 +864,3 @@
             msize, tok_label, tok_lastcnt, tok_serial);
-    res = dsig_send(dsdp, ctl, message, 0);
+    res = dsig_send_reliable(dsdp, ctl, message, 0, reliable);
     UnUseTmpHeapNoproc(6);
@@ -858,3 +872,3 @@
 erts_dsig_send_exit_tt(ErtsDSigData *dsdp, Eterm local, Eterm remote, 
-		       Eterm reason, Eterm token)
+        Eterm reason, Eterm token)
 {
@@ -875,13 +889,13 @@
     UseTmpHeapNoproc(6);
-    if (token != NIL 
+    if (token != NIL
 #ifdef USE_VM_PROBES
-	&& token != am_have_dt_utag
+    && token != am_have_dt_utag
 #endif
-	) {	
-	seq_trace_update_send(dsdp->proc);
-	seq_trace_output_exit(token, reason, SEQ_TRACE_SEND, remote, local);
-	ctl = TUPLE5(&ctl_heap[0],
-		     make_small(DOP_EXIT_TT), local, remote, token, reason);
+    ) { 
+        seq_trace_update_send(dsdp->proc);
+        seq_trace_output_exit(token, reason, SEQ_TRACE_SEND, remote, local);
+        ctl = TUPLE5(&ctl_heap[0],
+                make_small(DOP_EXIT_TT), local, remote, token, reason);
     } else {
-	ctl = TUPLE4(&ctl_heap[0], make_small(DOP_EXIT), local, remote, reason);
+        ctl = TUPLE4(&ctl_heap[0], make_small(DOP_EXIT), local, remote, reason);
     }
@@ -919,3 +933,3 @@
     ctl = TUPLE4(&ctl_heap[0],
-		 make_small(DOP_EXIT), local, remote, reason);
+            make_small(DOP_EXIT), local, remote, reason);
     /* forced, i.e ignore busy */
@@ -935,3 +949,3 @@
     ctl = TUPLE4(&ctl_heap[0],
-		 make_small(DOP_EXIT2), local, remote, reason);
+            make_small(DOP_EXIT2), local, remote, reason);
 
@@ -952,3 +966,3 @@
     ctl = TUPLE3(&ctl_heap[0],
-		 make_small(DOP_GROUP_LEADER), leader, remote);
+            make_small(DOP_GROUP_LEADER), leader, remote);
 
@@ -961,3 +975,3 @@
 #  define PURIFY_MSG(msg) \
-    purify_printf("%s, line %d: %s", __FILE__, __LINE__, msg)
+        purify_printf("%s, line %d: %s", __FILE__, __LINE__, msg)
 #elif defined(VALGRIND)
@@ -971,12 +985,12 @@
 #  define PURIFY_MSG(msg)                                                    \
-    do {								     \
-	char buf__[1]; size_t bufsz__ = sizeof(buf__);			     \
-	if (erts_sys_getenv_raw("VALGRIND_LOG_XML", buf__, &bufsz__) >= 0) { \
-	    VALGRIND_PRINTF_XML("<erlang_error_log>"			     \
-			    "%s, line %d: %s</erlang_error_log>\n",	     \
-			    __FILE__, __LINE__, msg);			     \
-	} else {							     \
-	    VALGRIND_PRINTF("%s, line %d: %s", __FILE__, __LINE__, msg);     \
-	}								     \
-    } while (0)
+    do {                                     \
+    char buf__[1]; size_t bufsz__ = sizeof(buf__);               \
+    if (erts_sys_getenv_raw("VALGRIND_LOG_XML", buf__, &bufsz__) >= 0) { \
+        VALGRIND_PRINTF_XML("<erlang_error_log>"                 \
+                "%s, line %d: %s</erlang_error_log>\n",      \
+                __FILE__, __LINE__, msg);                \
+    } else {                                 \
+        VALGRIND_PRINTF("%s, line %d: %s", __FILE__, __LINE__, msg);     \
+    }   								 \
+        } while (0)
 #else
@@ -986,17 +1000,17 @@
 /*
-** Input from distribution port.
-**  Input follows the distribution protocol v4.5
-**  
-**   The protocol is a 4 byte header protocol
-**   the DOP_DATA is stripped by driver_output
-**
-**   assert  hlen == 0 !!!
-*/
+ ** Input from distribution port.
+ **  Input follows the distribution protocol v4.5
+ **  
+ **   The protocol is a 4 byte header protocol
+ **   the DOP_DATA is stripped by driver_output
+ **
+ **   assert  hlen == 0 !!!
+ */
 
 int erts_net_message(Port *prt,
-		     DistEntry *dep,
-		     byte *hbuf,
-		     ErlDrvSizeT hlen,
-		     byte *buf,
-		     ErlDrvSizeT len)
+        DistEntry *dep,
+        byte *hbuf,
+        ErlDrvSizeT hlen,
+        byte *buf,
+        ErlDrvSizeT len)
 {
@@ -1038,10 +1052,10 @@
     if (!erts_is_alive) {
-	UnUseTmpHeapNoproc(DIST_CTL_DEFAULT_SIZE);
-	return 0;
+        UnUseTmpHeapNoproc(DIST_CTL_DEFAULT_SIZE);
+        return 0;
     }
     if (hlen != 0)
-	goto data_error;
+        goto data_error;
     if (len == 0) {  /* HANDLE TICK !!! */
-	UnUseTmpHeapNoproc(DIST_CTL_DEFAULT_SIZE);
-	return 0;
+        UnUseTmpHeapNoproc(DIST_CTL_DEFAULT_SIZE);
+        return 0;
     }
@@ -1054,7 +1068,7 @@
     if (dep->flags & DFLAG_DIST_HDR_ATOM_CACHE)
-	t = buf;
+        t = buf;
     else {
-	/* Skip PASS_THROUGH */
-	t = buf+1;
-	len--;
+        /* Skip PASS_THROUGH */
+        t = buf+1;
+        len--;
     }
@@ -1062,4 +1076,4 @@
     if (len == 0) {
-	PURIFY_MSG("data error");
-	goto data_error;
+        PURIFY_MSG("data error");
+        goto data_error;
     }
@@ -1069,9 +1083,9 @@
     if (res >= 0)
-	res = ctl_len = erts_decode_dist_ext_size(&ede);
+        res = ctl_len = erts_decode_dist_ext_size(&ede);
     else {
 #ifdef ERTS_DIST_MSG_DBG
-	erts_fprintf(stderr, "DIST MSG DEBUG: erts_prepare_dist_ext() failed:\n");
-	bw(buf, orig_len);
+        erts_fprintf(stderr, "DIST MSG DEBUG: erts_prepare_dist_ext() failed:\n");
+        bw(buf, orig_len);
 #endif
-	ctl_len = 0;
+        ctl_len = 0;
     }
@@ -1080,7 +1094,7 @@
 #ifdef ERTS_DIST_MSG_DBG
-	erts_fprintf(stderr, "DIST MSG DEBUG: erts_decode_dist_ext_size(CTL) failed:\n");
-	bw(buf, orig_len);
+        erts_fprintf(stderr, "DIST MSG DEBUG: erts_decode_dist_ext_size(CTL) failed:\n");
+        bw(buf, orig_len);
 #endif
-	PURIFY_MSG("data error");
-	goto data_error;
+        PURIFY_MSG("data error");
+        goto data_error;
     }
@@ -1088,3 +1102,3 @@
     if (ctl_len > DIST_CTL_DEFAULT_SIZE) {
-	ctl = erts_alloc(ERTS_ALC_T_DCTRL_BUF, ctl_len * sizeof(Eterm));
+        ctl = erts_alloc(ERTS_ALC_T_DCTRL_BUF, ctl_len * sizeof(Eterm));
     }
@@ -1095,7 +1109,7 @@
 #ifdef ERTS_DIST_MSG_DBG
-	erts_fprintf(stderr, "DIST MSG DEBUG: erts_dist_ext_size(CTL) failed:\n");
-	bw(buf, orig_len);
+        erts_fprintf(stderr, "DIST MSG DEBUG: erts_dist_ext_size(CTL) failed:\n");
+        bw(buf, orig_len);
 #endif
-	PURIFY_MSG("data error");
-	goto data_error;
+        PURIFY_MSG("data error");
+        goto data_error;
     }
@@ -1108,5 +1122,5 @@
     if (is_not_tuple(arg) || 
-	(tuple = tuple_val(arg), (tuple_arity = arityval(*tuple)) < 1) ||
-	is_not_small(tuple[1])) {
- 	goto invalid_message;
+            (tuple = tuple_val(arg), (tuple_arity = arityval(*tuple)) < 1) ||
+            is_not_small(tuple[1])) {
+        goto invalid_message;
     }
@@ -1116,134 +1130,134 @@
     switch (type = unsigned_val(tuple[1])) {
-    case DOP_LINK:
-	if (tuple_arity != 3) {
-	    goto invalid_message;
-	}
-	from = tuple[2];
-	to   = tuple[3];  /* local proc to link to */
-
-	if (is_not_pid(from) || is_not_pid(to)) {
-	    goto invalid_message;
-	}
-
-	rp = erts_pid2proc_opt(NULL, 0,
-			       to, ERTS_PROC_LOCK_LINK,
-			       ERTS_P2P_FLG_ALLOW_OTHER_X);
-	if (!rp) {
-	    /* This is tricky (we MUST force a distributed send) */
-	    ErtsDSigData dsd;
-	    int code;
-	    code = erts_dsig_prepare(&dsd, dep, NULL, ERTS_DSP_NO_LOCK, 0);
-	    if (code == ERTS_DSIG_PREP_CONNECTED) {
-		code = erts_dsig_send_exit(&dsd, to, from, am_noproc);
-		ASSERT(code == ERTS_DSIG_SEND_OK);
-	    }
-	    break;
-	}
-
-	erts_smp_de_links_lock(dep);
-	res = erts_add_link(&(rp->nlinks), LINK_PID, from);
-
-	if (res < 0) {
-	    /* It was already there! Lets skip the rest... */
-	    erts_smp_de_links_unlock(dep);
-	    erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_LINK);
-	    break;
-	}
-	lnk = erts_add_or_lookup_link(&(dep->nlinks), LINK_PID, rp->id);
-	erts_add_link(&(ERTS_LINK_ROOT(lnk)), LINK_PID, from);
-	erts_smp_de_links_unlock(dep);
-
-	if (IS_TRACED_FL(rp, F_TRACE_PROCS))
-	    trace_proc(NULL, rp, am_getting_linked, from);
-
-	erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_LINK);
-	break;
-
-    case DOP_UNLINK: {
-	ErtsDistLinkData dld;
-	if (tuple_arity != 3) {
-	    goto invalid_message;
-	}
-	from = tuple[2];
-	to = tuple[3];
-	if (is_not_pid(from) || is_not_pid(to)) {
-	    goto invalid_message;
-	}
-	
-	rp = erts_pid2proc_opt(NULL, 0,
-			       to, ERTS_PROC_LOCK_LINK,
-			       ERTS_P2P_FLG_ALLOW_OTHER_X);
-	if (!rp)
-	    break;
-
-	lnk = erts_remove_link(&(rp->nlinks), from);
-
-	if (IS_TRACED_FL(rp, F_TRACE_PROCS) && lnk != NULL) {
-	    trace_proc(NULL, rp, am_getting_unlinked, from);
-	}
-
-	erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_LINK);
-
-	erts_remove_dist_link(&dld, to, from, dep);
-	erts_destroy_dist_link(&dld);
-	if (lnk)
-	    erts_destroy_link(lnk);
-	break;
-    }
-    
-    case DOP_MONITOR_P: {
-	/* A remote process wants to monitor us, we get:
+        case DOP_LINK:
+            if (tuple_arity != 3) {
+                goto invalid_message;
+            }
+            from = tuple[2];
+            to   = tuple[3];  /* local proc to link to */
+
+            if (is_not_pid(from) || is_not_pid(to)) {
+                goto invalid_message;
+            }
+
+            rp = erts_pid2proc_opt(NULL, 0,
+                    to, ERTS_PROC_LOCK_LINK,
+                    ERTS_P2P_FLG_ALLOW_OTHER_X);
+            if (!rp) {
+                /* This is tricky (we MUST force a distributed send) */
+                ErtsDSigData dsd;
+                int code;
+                code = erts_dsig_prepare(&dsd, dep, NULL, ERTS_DSP_NO_LOCK, 0);
+                if (code == ERTS_DSIG_PREP_CONNECTED) {
+                    code = erts_dsig_send_exit(&dsd, to, from, am_noproc);
+                    ASSERT(code == ERTS_DSIG_SEND_OK);
+                }
+                break;
+            }
+
+            erts_smp_de_links_lock(dep);
+            res = erts_add_link(&(rp->nlinks), LINK_PID, from);
+
+            if (res < 0) {
+                /* It was already there! Lets skip the rest... */
+                erts_smp_de_links_unlock(dep);
+                erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_LINK);
+                break;
+            }
+            lnk = erts_add_or_lookup_link(&(dep->nlinks), LINK_PID, rp->id);
+            erts_add_link(&(ERTS_LINK_ROOT(lnk)), LINK_PID, from);
+            erts_smp_de_links_unlock(dep);
+
+            if (IS_TRACED_FL(rp, F_TRACE_PROCS))
+                trace_proc(NULL, rp, am_getting_linked, from);
+
+            erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_LINK);
+            break;
+
+        case DOP_UNLINK: {
+            ErtsDistLinkData dld;
+            if (tuple_arity != 3) {
+                goto invalid_message;
+            }
+            from = tuple[2];
+            to = tuple[3];
+            if (is_not_pid(from) || is_not_pid(to)) {
+                goto invalid_message;
+            }
+
+            rp = erts_pid2proc_opt(NULL, 0,
+                    to, ERTS_PROC_LOCK_LINK,
+                    ERTS_P2P_FLG_ALLOW_OTHER_X);
+            if (!rp)
+                break;
+
+            lnk = erts_remove_link(&(rp->nlinks), from);
+
+            if (IS_TRACED_FL(rp, F_TRACE_PROCS) && lnk != NULL) {
+                trace_proc(NULL, rp, am_getting_unlinked, from);
+            }
+
+            erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_LINK);
+
+            erts_remove_dist_link(&dld, to, from, dep);
+            erts_destroy_dist_link(&dld);
+            if (lnk)
+                erts_destroy_link(lnk);
+            break;
+        }
+
+        case DOP_MONITOR_P: {
+            /* A remote process wants to monitor us, we get:
 	   {DOP_MONITOR_P, Remote pid, local pid or name, ref} */
-	Eterm name;
-	
-	if (tuple_arity != 4) {
-	    goto invalid_message;
-	}
-
-	watcher = tuple[2];
-	watched = tuple[3];  /* local proc to monitor */
-	ref     = tuple[4];
-
-	if (is_not_ref(ref)) {
-	    goto invalid_message;
-	}
-
-	if (is_atom(watched)) {
-	    name = watched;
-	    rp = erts_whereis_process(NULL, 0,
-				      watched, ERTS_PROC_LOCK_LINK,
-				      ERTS_P2P_FLG_ALLOW_OTHER_X);
-	}
-	else {
-	    name = NIL;
-	    rp = erts_pid2proc_opt(NULL, 0,
-				   watched, ERTS_PROC_LOCK_LINK,
-				   ERTS_P2P_FLG_ALLOW_OTHER_X);
-	}
-
-	if (!rp) {
-	    ErtsDSigData dsd;
-	    int code;
-	    code = erts_dsig_prepare(&dsd, dep, NULL, ERTS_DSP_NO_LOCK, 0);
-	    if (code == ERTS_DSIG_PREP_CONNECTED) {
-		code = erts_dsig_send_m_exit(&dsd, watcher, watched, ref,
-					     am_noproc);
-		ASSERT(code == ERTS_DSIG_SEND_OK);
-	    }
-	}
-	else {
-	    if (is_atom(watched))
-		watched = rp->id;
-	    erts_smp_de_links_lock(dep);
-	    erts_add_monitor(&(dep->monitors), MON_ORIGIN, ref, watched, name);
-	    erts_add_monitor(&(rp->monitors), MON_TARGET, ref, watcher, name);
-	    erts_smp_de_links_unlock(dep);
-	    erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_LINK);
-	}
+            Eterm name;
 
-	break;
-    }
+            if (tuple_arity != 4) {
+                goto invalid_message;
+            }
+
+            watcher = tuple[2];
+            watched = tuple[3];  /* local proc to monitor */
+            ref     = tuple[4];
+
+            if (is_not_ref(ref)) {
+                goto invalid_message;
+            }
+
+            if (is_atom(watched)) {
+                name = watched;
+                rp = erts_whereis_process(NULL, 0,
+                        watched, ERTS_PROC_LOCK_LINK,
+                        ERTS_P2P_FLG_ALLOW_OTHER_X);
+            }
+            else {
+                name = NIL;
+                rp = erts_pid2proc_opt(NULL, 0,
+                        watched, ERTS_PROC_LOCK_LINK,
+                        ERTS_P2P_FLG_ALLOW_OTHER_X);
+            }
+
+            if (!rp) {
+                ErtsDSigData dsd;
+                int code;
+                code = erts_dsig_prepare(&dsd, dep, NULL, ERTS_DSP_NO_LOCK, 0);
+                if (code == ERTS_DSIG_PREP_CONNECTED) {
+                    code = erts_dsig_send_m_exit(&dsd, watcher, watched, ref,
+                            am_noproc);
+                    ASSERT(code == ERTS_DSIG_SEND_OK);
+                }
+            }
+            else {
+                if (is_atom(watched))
+                    watched = rp->id;
+                erts_smp_de_links_lock(dep);
+                erts_add_monitor(&(dep->monitors), MON_ORIGIN, ref, watched, name);
+                erts_add_monitor(&(rp->monitors), MON_TARGET, ref, watcher, name);
+                erts_smp_de_links_unlock(dep);
+                erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_LINK);
+            }
+
+            break;
+        }
 
-    case DOP_DEMONITOR_P:
-	/* A remote node informs us that a local pid in no longer monitored
+        case DOP_DEMONITOR_P:
+            /* A remote node informs us that a local pid in no longer monitored
 	   We get {DOP_DEMONITOR_P, Remote pid, Local pid or name, ref},
@@ -1251,247 +1265,329 @@
 
-	if (tuple_arity != 4) {
-	    goto invalid_message;
-	}
-	/* watcher = tuple[2]; */
-	/* watched = tuple[3]; May be an atom in case of monitor name */
-	ref = tuple[4];
-
-	if(is_not_ref(ref)) {
-	    goto invalid_message;
-	}
-
-	erts_smp_de_links_lock(dep);
-	mon = erts_remove_monitor(&(dep->monitors),ref);
-	erts_smp_de_links_unlock(dep);
-	/* ASSERT(mon != NULL); can happen in case of broken dist message */
-	if (mon == NULL) {
-	    break;
-	}
-	watched = mon->pid;
-	erts_destroy_monitor(mon);
-	rp = erts_pid2proc_opt(NULL, 0,
-			       watched, ERTS_PROC_LOCK_LINK,
-			       ERTS_P2P_FLG_ALLOW_OTHER_X);
-	if (!rp) {
-	    break;
-	}
-	mon = erts_remove_monitor(&(rp->monitors),ref);
-	erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_LINK);
-	ASSERT(mon != NULL);
-	if (mon == NULL) {
-	    break;
-	}
-	erts_destroy_monitor(mon);
-	break;
-
-    case DOP_REG_SEND_TT:
-	if (tuple_arity != 5) {
-	    goto invalid_message;
-	}
-
-	token_size = size_object(tuple[5]);
-	/* Fall through ... */
-    case DOP_REG_SEND:
-	/* {DOP_REG_SEND, From, Cookie, ToName} -- Message */
-	/* {DOP_REG_SEND_TT, From, Cookie, ToName, TraceToken} -- Message */
-
-	/*
-	 * There is intentionally no testing of the cookie (it is always '')
-	 * from R9B and onwards.
-	 */
-	if (type != DOP_REG_SEND_TT && tuple_arity != 4) {
-	    goto invalid_message;
-	}
+            if (tuple_arity != 4) {
+                goto invalid_message;
+            }
+            /* watcher = tuple[2]; */
+            /* watched = tuple[3]; May be an atom in case of monitor name */
+            ref = tuple[4];
+
+            if(is_not_ref(ref)) {
+                goto invalid_message;
+            }
+
+            erts_smp_de_links_lock(dep);
+            mon = erts_remove_monitor(&(dep->monitors),ref);
+            erts_smp_de_links_unlock(dep);
+            /* ASSERT(mon != NULL); can happen in case of broken dist message */
+            if (mon == NULL) {
+                break;
+            }
+            watched = mon->pid;
+            erts_destroy_monitor(mon);
+            rp = erts_pid2proc_opt(NULL, 0,
+                    watched, ERTS_PROC_LOCK_LINK,
+                    ERTS_P2P_FLG_ALLOW_OTHER_X);
+            if (!rp) {
+                break;
+            }
+            mon = erts_remove_monitor(&(rp->monitors),ref);
+            erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_LINK);
+            ASSERT(mon != NULL);
+            if (mon == NULL) {
+                break;
+            }
+            erts_destroy_monitor(mon);
+            break;
+
+        case DOP_REG_SEND_TT:
+            if (tuple_arity != 5) {
+                goto invalid_message;
+            }
+
+            token_size = size_object(tuple[5]);
+            /* Fall through ... */
+        case DOP_REG_SEND:
+            /* {DOP_REG_SEND, ToName} -- Message */
+            /* {DOP_REG_SEND_TT, From, Cookie, ToName, TraceToken} -- Message */
+
+            /*
+             * There is intentionally no testing of the cookie (it is always '')
+             * from R9B and onwards.
+             */
+            if (type != DOP_REG_SEND_TT && tuple_arity != 2) {
+                goto invalid_message;
+            }
 
 #ifdef ERTS_DIST_MSG_DBG
-	dist_msg_dbg(&ede, "MSG", buf, orig_len);
+            dist_msg_dbg(&ede, "MSG", buf, orig_len);
 #endif
-
-	from = tuple[2];
-	to = tuple[4];
-	if (is_not_pid(from) || is_not_atom(to)){
-	    goto invalid_message;
-	}
-	rp = erts_whereis_process(NULL, 0, to, 0, ERTS_P2P_FLG_SMP_INC_REFC);
-	if (rp) {
-	    Uint xsize = (type == DOP_REG_SEND
-			  ? 0
-			  : ERTS_HEAP_FRAG_SIZE(token_size));
-	    ErtsProcLocks locks = 0;
-	    ErtsDistExternal *ede_copy;
-
-	    ede_copy = erts_make_dist_ext_copy(&ede, xsize);
-	    if (type == DOP_REG_SEND) {
-		token = NIL;
-	    } else {
-		ErlHeapFragment *heap_frag;
-		ErlOffHeap *ohp;
-		ASSERT(xsize);
-		heap_frag = erts_dist_ext_trailer(ede_copy);
-		ERTS_INIT_HEAP_FRAG(heap_frag, token_size);
-		hp = heap_frag->mem;
-		ohp = &heap_frag->off_heap;
-		token = tuple[5];
-		token = copy_struct(token, token_size, &hp, ohp);
-	    }
-
-	    erts_queue_dist_message(rp, &locks, ede_copy, token);
-	    if (locks)
-		erts_smp_proc_unlock(rp, locks);
-	    erts_smp_proc_dec_refc(rp);
-	}
-	break;
-
-    case DOP_SEND_TT:
-	if (tuple_arity != 4) {
-	    goto invalid_message;
-	}
-	
-	token_size = size_object(tuple[4]);
-	/* Fall through ... */
-    case DOP_SEND:
-	/*
-	 * There is intentionally no testing of the cookie (it is always '')
-	 * from R9B and onwards.
-	 */
+            to = tuple[2];
+            if (is_not_atom(to)){
+                goto invalid_message;
+            }
+            if (to == am_all) {
+                Eterm procList, current;
+                Uint dimension = process_exp_size() * 2;
+                DeclareTmpHeapNoproc(buf, dimension);
+                Eterm* buf2 = buf;
+                UseTmpHeapNoproc(dimension);
+                erts_printf("DEBUG: Message received to all exported processes\n");
+                procList = exported_noproc(buf2);
+                while (is_list(procList)) {
+                    current = CAR(list_val(procList));
+                    if (is_atom(current)) {
+                        rp = erts_whereis_process(NULL, 0, current, 0, ERTS_P2P_FLG_SMP_INC_REFC);
+                        if (rp) {
+                            Uint xsize = (type == DOP_REG_SEND
+                                    ? 0
+                                            : ERTS_HEAP_FRAG_SIZE(token_size));
+                            ErtsProcLocks locks = 0;
+                            ErtsDistExternal *ede_copy;
+            
+                            ede_copy = erts_make_dist_ext_copy(&ede, xsize);
+                            if (type == DOP_REG_SEND) {
+                                token = NIL;
+                            } else {
+                                ErlHeapFragment *heap_frag;
+                                ErlOffHeap *ohp;
+                                ASSERT(xsize);
+                                heap_frag = erts_dist_ext_trailer(ede_copy);
+                                ERTS_INIT_HEAP_FRAG(heap_frag, token_size);
+                                hp = heap_frag->mem;
+                                ohp = &heap_frag->off_heap;
+                                token = tuple[5];
+                                token = copy_struct(token, token_size, &hp, ohp);
+                            }
+            
+                            erts_queue_dist_message(rp, &locks, ede_copy, token);
+                            if (locks)
+                                erts_smp_proc_unlock(rp, locks);
+                            erts_smp_proc_dec_refc(rp);
+                        }
+                    }
+                    else {
+                        rp = erts_pid2proc_opt(NULL, 0, current, 0, ERTS_P2P_FLG_SMP_INC_REFC);
+                        if (rp) {
+                            Uint xsize = type == DOP_SEND ? 0 : ERTS_HEAP_FRAG_SIZE(token_size);
+                            ErtsProcLocks locks = 0;
+                            ErtsDistExternal *ede_copy;
+            
+                            ede_copy = erts_make_dist_ext_copy(&ede, xsize);
+                            if (type == DOP_SEND) {
+                                token = NIL;
+                            } else {
+                                ErlHeapFragment *heap_frag;
+                                ErlOffHeap *ohp;
+                                ASSERT(xsize);
+                                heap_frag = erts_dist_ext_trailer(ede_copy);
+                                ERTS_INIT_HEAP_FRAG(heap_frag, token_size);
+                                hp = heap_frag->mem;
+                                ohp = &heap_frag->off_heap;
+                                token = tuple[4];
+                                token = copy_struct(token, token_size, &hp, ohp);
+                            }
+            
+                            erts_queue_dist_message(rp, &locks, ede_copy, token);
+                            if (locks)
+                                erts_smp_proc_unlock(rp, locks);
+                            erts_smp_proc_dec_refc(rp);
+                        }
+                    }
+                    procList = CDR(list_val(procList));
+                }
+                UnUseTmpHeapNoproc(dimension);
+            }
+            else if (erts_is_exported_by_name(NULL, to)) {
+                erts_printf("DEBUG: Message received to exported process %T\n", to);
+                rp = erts_whereis_process(NULL, 0, to, 0, ERTS_P2P_FLG_SMP_INC_REFC);
+                if (rp) {
+                    Uint xsize = (type == DOP_REG_SEND
+                            ? 0
+                                    : ERTS_HEAP_FRAG_SIZE(token_size));
+                    ErtsProcLocks locks = 0;
+                    ErtsDistExternal *ede_copy;
+    
+                    ede_copy = erts_make_dist_ext_copy(&ede, xsize);
+                    if (type == DOP_REG_SEND) {
+                        token = NIL;
+                    } else {
+                        ErlHeapFragment *heap_frag;
+                        ErlOffHeap *ohp;
+                        ASSERT(xsize);
+                        heap_frag = erts_dist_ext_trailer(ede_copy);
+                        ERTS_INIT_HEAP_FRAG(heap_frag, token_size);
+                        hp = heap_frag->mem;
+                        ohp = &heap_frag->off_heap;
+                        token = tuple[5];
+                        token = copy_struct(token, token_size, &hp, ohp);
+                    }
+    
+                    erts_queue_dist_message(rp, &locks, ede_copy, token);
+                    if (locks)
+                        erts_smp_proc_unlock(rp, locks);
+                    erts_smp_proc_dec_refc(rp);
+                }
+            }
+            else {
+                erts_printf("DEBUG: Message received to unexported process %T\n", to);
+            }
+            break;
+
+        case DOP_SEND_TT:
+            if (tuple_arity != 4) {
+                goto invalid_message;
+            }
+
+            token_size = size_object(tuple[4]);
+            /* Fall through ... */
+        case DOP_SEND:
+            /*
+             * There is intentionally no testing of the cookie (it is always '')
+             * from R9B and onwards.
+             */
 #ifdef ERTS_DIST_MSG_DBG
-	dist_msg_dbg(&ede, "MSG", buf, orig_len);
+            dist_msg_dbg(&ede, "MSG", buf, orig_len);
 #endif
-	if (type != DOP_SEND_TT && tuple_arity != 3) {
-	    goto invalid_message;
-	}
-	to = tuple[3];
-	if (is_not_pid(to)) {
-	    goto invalid_message;
-	}
-	rp = erts_pid2proc_opt(NULL, 0, to, 0, ERTS_P2P_FLG_SMP_INC_REFC);
-	if (rp) {
-	    Uint xsize = type == DOP_SEND ? 0 : ERTS_HEAP_FRAG_SIZE(token_size);
-	    ErtsProcLocks locks = 0;
-	    ErtsDistExternal *ede_copy;
-
-	    ede_copy = erts_make_dist_ext_copy(&ede, xsize);
-	    if (type == DOP_SEND) {
-		token = NIL;
-	    } else {
-		ErlHeapFragment *heap_frag;
-		ErlOffHeap *ohp;
-		ASSERT(xsize);
-		heap_frag = erts_dist_ext_trailer(ede_copy);
-		ERTS_INIT_HEAP_FRAG(heap_frag, token_size);
-		hp = heap_frag->mem;
-		ohp = &heap_frag->off_heap;
-		token = tuple[4];
-		token = copy_struct(token, token_size, &hp, ohp);
-	    }
-
-	    erts_queue_dist_message(rp, &locks, ede_copy, token);
-	    if (locks)
-		erts_smp_proc_unlock(rp, locks);
-	    erts_smp_proc_dec_refc(rp);
-	}
-	break;
+            if (type != DOP_SEND_TT && tuple_arity != 2) {
+                goto invalid_message;
+            }
+            to = tuple[2];
+            if (is_not_pid(to)) {
+                goto invalid_message;
+            }
+            if (erts_is_exported_by_pid(NULL, to)) {
+                erts_printf("DEBUG: Message received for exported process %T\n", to);
+                rp = erts_pid2proc_opt(NULL, 0, to, 0, ERTS_P2P_FLG_SMP_INC_REFC);
+                if (rp) {
+                    Uint xsize = type == DOP_SEND ? 0 : ERTS_HEAP_FRAG_SIZE(token_size);
+                    ErtsProcLocks locks = 0;
+                    ErtsDistExternal *ede_copy;
+    
+                    ede_copy = erts_make_dist_ext_copy(&ede, xsize);
+                    if (type == DOP_SEND) {
+                        token = NIL;
+                    } else {
+                        ErlHeapFragment *heap_frag;
+                        ErlOffHeap *ohp;
+                        ASSERT(xsize);
+                        heap_frag = erts_dist_ext_trailer(ede_copy);
+                        ERTS_INIT_HEAP_FRAG(heap_frag, token_size);
+                        hp = heap_frag->mem;
+                        ohp = &heap_frag->off_heap;
+                        token = tuple[4];
+                        token = copy_struct(token, token_size, &hp, ohp);
+                    }
+    
+                    erts_queue_dist_message(rp, &locks, ede_copy, token);
+                    if (locks)
+                        erts_smp_proc_unlock(rp, locks);
+                    erts_smp_proc_dec_refc(rp);
+                }
+            }
+            else {
+                erts_printf("DEBUG: Message received for unexported process %T\n", to);
+            }
+            break;
 
-    case DOP_MONITOR_P_EXIT: {
-	/* We are monitoring a process on the remote node which dies, we get
+        case DOP_MONITOR_P_EXIT: {
+            /* We are monitoring a process on the remote node which dies, we get
 	   {DOP_MONITOR_P_EXIT, Remote pid or name, Local pid, ref, reason} */
-	   
 
-	DeclareTmpHeapNoproc(lhp,3);
-	Eterm sysname;
-	ErtsProcLocks rp_locks = ERTS_PROC_LOCKS_MSG_SEND|ERTS_PROC_LOCK_LINK;
-
-	if (tuple_arity != 5) {
-	    goto invalid_message;
-	}
-
-	/* watched = tuple[2]; */  /* remote proc which died */
-	/* watcher = tuple[3]; */
-	ref     = tuple[4];
-	reason  = tuple[5];
-
-	if(is_not_ref(ref)) {
-	    goto invalid_message;
-	}
-
-	erts_smp_de_links_lock(dep);
-	sysname = dep->sysname;
-	mon = erts_remove_monitor(&(dep->monitors), ref);
-	/*
-	 * If demonitor was performed at the same time as the
-	 * monitored process exits, monitoring side will have
-	 * removed info about monitor. In this case, do nothing
-	 * and everything will be as it should.
-	 */
-	erts_smp_de_links_unlock(dep);
-	if (mon == NULL) {
-	    break;
-	}
-	rp = erts_pid2proc(NULL, 0, mon->pid, rp_locks);
-	if (rp == NULL) {
-	    break;
-	}
-
-	erts_destroy_monitor(mon);
-
-	mon = erts_remove_monitor(&(rp->monitors),ref);
-
-	if (mon == NULL) {
-	    erts_smp_proc_unlock(rp, rp_locks);
-	    break;
-	}
-	UseTmpHeapNoproc(3);
-	
-	watched = (is_not_nil(mon->name)
-		   ? TUPLE2(&lhp[0], mon->name, sysname)
-		   : mon->pid);
-	
-	erts_queue_monitor_message(rp, &rp_locks,
-				   ref, am_process, watched, reason);
-	erts_smp_proc_unlock(rp, rp_locks);
-	erts_destroy_monitor(mon);
-	UnUseTmpHeapNoproc(3);
-	break;
-    }
-
-    case DOP_EXIT_TT:
-    case DOP_EXIT: {
-	ErtsDistLinkData dld;
-	ErtsProcLocks rp_locks = ERTS_PROC_LOCK_LINK|ERTS_PROC_LOCKS_XSIG_SEND;
-	/* 'from', which 'to' is linked to, died */
-	if (type == DOP_EXIT) {
-	    if (tuple_arity != 4) {
-		goto invalid_message;
-	    }
-	    
-	    from = tuple[2];
-	    to = tuple[3];
-	    reason = tuple[4];
-	    token = NIL;
-	} else {
-	    if (tuple_arity != 5) {
-		goto invalid_message;
-	    }
-	    from = tuple[2];
-	    to = tuple[3];
-	    token = tuple[4];
-	    reason = tuple[5];
-	}
-	if (is_not_pid(from) || is_not_internal_pid(to)) {
-	    goto invalid_message;
-	}
-
-	rp = erts_pid2proc(NULL, 0, to, rp_locks);
-	if (!rp)
-	    lnk = NULL;
-	else {
-	    lnk = erts_remove_link(&(rp->nlinks), from);
-
-	    /* If lnk == NULL, we have unlinked on this side, i.e.
-	     * ignore exit.
-	     */
-	    if (lnk) {
-		int xres;
+
+            DeclareTmpHeapNoproc(lhp,3);
+            Eterm sysname;
+            ErtsProcLocks rp_locks = ERTS_PROC_LOCKS_MSG_SEND|ERTS_PROC_LOCK_LINK;
+
+            if (tuple_arity != 5) {
+                goto invalid_message;
+            }
+
+            /* watched = tuple[2]; */  /* remote proc which died */
+            /* watcher = tuple[3]; */
+            ref     = tuple[4];
+            reason  = tuple[5];
+
+            if(is_not_ref(ref)) {
+                goto invalid_message;
+            }
+
+            erts_smp_de_links_lock(dep);
+            sysname = dep->sysname;
+            mon = erts_remove_monitor(&(dep->monitors), ref);
+            /*
+             * If demonitor was performed at the same time as the
+             * monitored process exits, monitoring side will have
+             * removed info about monitor. In this case, do nothing
+             * and everything will be as it should.
+             */
+            erts_smp_de_links_unlock(dep);
+            if (mon == NULL) {
+                break;
+            }
+            rp = erts_pid2proc(NULL, 0, mon->pid, rp_locks);
+            if (rp == NULL) {
+                break;
+            }
+
+            erts_destroy_monitor(mon);
+
+            mon = erts_remove_monitor(&(rp->monitors),ref);
+
+            if (mon == NULL) {
+                erts_smp_proc_unlock(rp, rp_locks);
+                break;
+            }
+            UseTmpHeapNoproc(3);
+
+            watched = (is_not_nil(mon->name)
+                    ? TUPLE2(&lhp[0], mon->name, sysname)
+                            : mon->pid);
+
+            erts_queue_monitor_message(rp, &rp_locks,
+                    ref, am_process, watched, reason);
+            erts_smp_proc_unlock(rp, rp_locks);
+            erts_destroy_monitor(mon);
+            UnUseTmpHeapNoproc(3);
+            break;
+        }
+
+        case DOP_EXIT_TT:
+        case DOP_EXIT: {
+            ErtsDistLinkData dld;
+            ErtsProcLocks rp_locks = ERTS_PROC_LOCK_LINK|ERTS_PROC_LOCKS_XSIG_SEND;
+            /* 'from', which 'to' is linked to, died */
+            if (type == DOP_EXIT) {
+                if (tuple_arity != 4) {
+                    goto invalid_message;
+                }
+
+                from = tuple[2];
+                to = tuple[3];
+                reason = tuple[4];
+                token = NIL;
+            } else {
+                if (tuple_arity != 5) {
+                    goto invalid_message;
+                }
+                from = tuple[2];
+                to = tuple[3];
+                token = tuple[4];
+                reason = tuple[5];
+            }
+            if (is_not_pid(from) || is_not_internal_pid(to)) {
+                goto invalid_message;
+            }
+
+            rp = erts_pid2proc(NULL, 0, to, rp_locks);
+            if (!rp)
+                lnk = NULL;
+            else {
+                lnk = erts_remove_link(&(rp->nlinks), from);
+
+                /* If lnk == NULL, we have unlinked on this side, i.e.
+                 * ignore exit.
+                 */
+                if (lnk) {
+                    int xres;
 #if 0
-		/* Arndt: Maybe it should never be 'kill', but it can be,
+                    /* Arndt: Maybe it should never be 'kill', but it can be,
 		   namely when a linked process does exit(kill). Until we know
@@ -1499,84 +1595,84 @@
 		   we leave the assertion out. */
-		ASSERT(reason != am_kill); /* should never be kill (killed) */
+                    ASSERT(reason != am_kill); /* should never be kill (killed) */
 #endif
-		xres = erts_send_exit_signal(NULL,
-					     from,
-					     rp,
-					     &rp_locks, 
-					     reason,
-					     token,
-					     NULL,
-					     ERTS_XSIG_FLG_IGN_KILL);
-		if (xres >= 0 && IS_TRACED_FL(rp, F_TRACE_PROCS)) {
-		    /* We didn't exit the process and it is traced */
-		    trace_proc(NULL, rp, am_getting_unlinked, from);
-		}
-	    }
-	    erts_smp_proc_unlock(rp, rp_locks);
-	}
-	erts_remove_dist_link(&dld, to, from, dep);
-	if (lnk)
-	    erts_destroy_link(lnk);
-	erts_destroy_dist_link(&dld);
-	break;
-    }
-    case DOP_EXIT2_TT:
-    case DOP_EXIT2: {
-	ErtsProcLocks rp_locks = ERTS_PROC_LOCKS_XSIG_SEND;
-	/* 'from' is send an exit signal to 'to' */
-	if (type == DOP_EXIT2) {
-	    if (tuple_arity != 4) {
-		goto invalid_message;
-	    }
-	    from = tuple[2];
-	    to = tuple[3];
-	    reason = tuple[4];
-	    token = NIL;
-	} else {
-	    if (tuple_arity != 5) {
-		goto invalid_message;
-	    }
-	    from = tuple[2];
-	    to = tuple[3];
-	    token = tuple[4];
-	    reason = tuple[5];
-	}
-	if (is_not_pid(from) || is_not_internal_pid(to)) {
-	    goto invalid_message;
-	}
-	rp = erts_pid2proc_opt(NULL, 0, to, rp_locks,
-			       ERTS_P2P_FLG_SMP_INC_REFC);
-	if (rp) {
-	    (void) erts_send_exit_signal(NULL,
-					 from,
-					 rp,
-					 &rp_locks,
-					 reason,
-					 token,
-					 NULL,
-					 0);
-	    erts_smp_proc_unlock(rp, rp_locks);
-	    erts_smp_proc_dec_refc(rp);
-	}
-	break;
-    }
-    case DOP_GROUP_LEADER:
-	if (tuple_arity != 3) {
-	    goto invalid_message;
-	}
-	from = tuple[2];   /* Group leader  */
-	to = tuple[3];     /* new member */
-	if (is_not_pid(from) || is_not_pid(to)) {
-	    goto invalid_message;
-	}
-
-	rp = erts_pid2proc(NULL, 0, to, ERTS_PROC_LOCK_MAIN);
-	if (!rp)
-	    break;
-	rp->group_leader = STORE_NC_IN_PROC(rp, from);
-	erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_MAIN);
-	break;
+                    xres = erts_send_exit_signal(NULL,
+                            from,
+                            rp,
+                            &rp_locks, 
+                            reason,
+                            token,
+                            NULL,
+                            ERTS_XSIG_FLG_IGN_KILL);
+                    if (xres >= 0 && IS_TRACED_FL(rp, F_TRACE_PROCS)) {
+                        /* We didn't exit the process and it is traced */
+                        trace_proc(NULL, rp, am_getting_unlinked, from);
+                    }
+                }
+                erts_smp_proc_unlock(rp, rp_locks);
+            }
+            erts_remove_dist_link(&dld, to, from, dep);
+            if (lnk)
+                erts_destroy_link(lnk);
+            erts_destroy_dist_link(&dld);
+            break;
+        }
+        case DOP_EXIT2_TT:
+        case DOP_EXIT2: {
+            ErtsProcLocks rp_locks = ERTS_PROC_LOCKS_XSIG_SEND;
+            /* 'from' is send an exit signal to 'to' */
+            if (type == DOP_EXIT2) {
+                if (tuple_arity != 4) {
+                    goto invalid_message;
+                }
+                from = tuple[2];
+                to = tuple[3];
+                reason = tuple[4];
+                token = NIL;
+            } else {
+                if (tuple_arity != 5) {
+                    goto invalid_message;
+                }
+                from = tuple[2];
+                to = tuple[3];
+                token = tuple[4];
+                reason = tuple[5];
+            }
+            if (is_not_pid(from) || is_not_internal_pid(to)) {
+                goto invalid_message;
+            }
+            rp = erts_pid2proc_opt(NULL, 0, to, rp_locks,
+                    ERTS_P2P_FLG_SMP_INC_REFC);
+            if (rp) {
+                (void) erts_send_exit_signal(NULL,
+                        from,
+                        rp,
+                        &rp_locks,
+                        reason,
+                        token,
+                        NULL,
+                        0);
+                erts_smp_proc_unlock(rp, rp_locks);
+                erts_smp_proc_dec_refc(rp);
+            }
+            break;
+        }
+        case DOP_GROUP_LEADER:
+            if (tuple_arity != 3) {
+                goto invalid_message;
+            }
+            from = tuple[2];   /* Group leader  */
+            to = tuple[3];     /* new member */
+            if (is_not_pid(from) || is_not_pid(to)) {
+                goto invalid_message;
+            }
+
+            rp = erts_pid2proc(NULL, 0, to, ERTS_PROC_LOCK_MAIN);
+            if (!rp)
+                break;
+            rp->group_leader = STORE_NC_IN_PROC(rp, from);
+            erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_MAIN);
+            break;
 
-    default: 
-	goto invalid_message;
+        default: 
+            goto invalid_message;
     }
@@ -1585,3 +1681,3 @@
     if (ctl != ctl_default) {
-	erts_free(ERTS_ALC_T_DCTRL_BUF, (void *) ctl);
+        erts_free(ERTS_ALC_T_DCTRL_BUF, (void *) ctl);
     }
@@ -1590,9 +1686,9 @@
     return 0;
- invalid_message:
+    invalid_message:
     {
-	erts_dsprintf_buf_t *dsbufp = erts_create_logger_dsbuf();
-	erts_dsprintf(dsbufp, "Invalid distribution message: %.200T", arg);
-	erts_send_error_to_logger_nogl(dsbufp);
+        erts_dsprintf_buf_t *dsbufp = erts_create_logger_dsbuf();
+        erts_dsprintf(dsbufp, "Invalid distribution message: %.200T", arg);
+        erts_send_error_to_logger_nogl(dsbufp);
     }
- data_error:
+    data_error:
     PURIFY_MSG("data error");
@@ -1600,3 +1696,3 @@
     if (ctl != ctl_default) {
-	erts_free(ERTS_ALC_T_DCTRL_BUF, (void *) ctl);
+        erts_free(ERTS_ALC_T_DCTRL_BUF, (void *) ctl);
     }
@@ -1611,2 +1707,8 @@
 {
+    return dsig_send_reliable(dsdp, ctl, msg, force_busy, 1);
+}
+
+static int
+dsig_send_reliable(ErtsDSigData *dsdp, Eterm ctl, Eterm msg, int force_busy, int reliable)
+{
     Eterm cid;
@@ -1623,18 +1725,18 @@
     if (!c_p || dsdp->no_suspend)
-	force_busy = 1;
+        force_busy = 1;
 
     ERTS_SMP_LC_ASSERT(!c_p
-		       || (ERTS_PROC_LOCK_MAIN
-			   == erts_proc_lc_my_proc_locks(c_p)));
+            || (ERTS_PROC_LOCK_MAIN
+                    == erts_proc_lc_my_proc_locks(c_p)));
 
     if (!erts_is_alive)
-	return ERTS_DSIG_SEND_OK;
+        return ERTS_DSIG_SEND_OK;
 
     if (flags & DFLAG_DIST_HDR_ATOM_CACHE) {
-	acmp = erts_get_atom_cache_map(c_p);
-	pass_through_size = 0;
+        acmp = erts_get_atom_cache_map(c_p);
+        pass_through_size = 0;
     }
     else {
-	acmp = NULL;
-	pass_through_size = 1;
+        acmp = NULL;
+        pass_through_size = 1;
     }
@@ -1644,6 +1746,7 @@
     if (is_value(msg))
-	erts_fprintf(stderr, "    MSG: %T\n", msg);
+        erts_fprintf(stderr, "    MSG: %T\n", msg);
 #endif
 
-    data_size = pass_through_size;
+    data_size = 1; // one more byte for reliability
+    data_size += pass_through_size;
     erts_reset_atom_cache_map(acmp);
@@ -1651,3 +1754,3 @@
     if (is_value(msg))
-	data_size += erts_encode_dist_ext_size(msg, flags, acmp);
+        data_size += erts_encode_dist_ext_size(msg, flags, acmp);
     erts_finalize_atom_cache_map(acmp);
@@ -1665,5 +1768,7 @@
     if (is_value(msg)) {
-	/* Encode message */
-	erts_encode_dist_ext(msg, &obuf->ext_endp, flags, acmp);
+        /* Encode message */
+        erts_encode_dist_ext(msg, &obuf->ext_endp, flags, acmp);
     }
+    /* Encode reliability */
+    erts_encode_dist_reliability(&obuf->ext_endp, reliable);
 
@@ -1683,35 +1788,35 @@
     if (cid != dsdp->cid
-	|| dep->connection_id != dsdp->connection_id
-	|| dep->status & ERTS_DE_SFLG_EXITING) {
-	/* Not the same connection as when we started; drop message... */
-	erts_smp_de_runlock(dep);
-	free_dist_obuf(obuf);
+            || dep->connection_id != dsdp->connection_id
+            || dep->status & ERTS_DE_SFLG_EXITING) {
+        /* Not the same connection as when we started; drop message... */
+        erts_smp_de_runlock(dep);
+        free_dist_obuf(obuf);
     }
     else {
-	ErtsProcList *plp = NULL;
-	erts_smp_mtx_lock(&dep->qlock);
-	dep->qsize += size_obuf(obuf);
-	if (dep->qsize >= erts_dist_buf_busy_limit)
-	    dep->qflgs |= ERTS_DE_QFLG_BUSY;
-	if (!force_busy && (dep->qflgs & ERTS_DE_QFLG_BUSY)) {
-	    erts_smp_mtx_unlock(&dep->qlock);
-
-	    plp = erts_proclist_create(c_p);
-	    plp->next = NULL;
-	    erts_suspend(c_p, ERTS_PROC_LOCK_MAIN, NULL);
-	    suspended = 1;
-	    erts_smp_mtx_lock(&dep->qlock);
-	}
-
-	/* Enqueue obuf on dist entry */
-	if (dep->out_queue.last)
-	    dep->out_queue.last->next = obuf;
-	else
-	    dep->out_queue.first = obuf;
-	dep->out_queue.last = obuf;
-
-	if (!force_busy) {
-	    if (!(dep->qflgs & ERTS_DE_QFLG_BUSY)) {
-		if (suspended)
-		    resume = 1; /* was busy when we started, but isn't now */
+        ErtsProcList *plp = NULL;
+        erts_smp_mtx_lock(&dep->qlock);
+        dep->qsize += size_obuf(obuf);
+        if (dep->qsize >= erts_dist_buf_busy_limit)
+            dep->qflgs |= ERTS_DE_QFLG_BUSY;
+        if (!force_busy && (dep->qflgs & ERTS_DE_QFLG_BUSY)) {
+            erts_smp_mtx_unlock(&dep->qlock);
+
+            plp = erts_proclist_create(c_p);
+            plp->next = NULL;
+            erts_suspend(c_p, ERTS_PROC_LOCK_MAIN, NULL);
+            suspended = 1;
+            erts_smp_mtx_lock(&dep->qlock);
+        }
+
+        /* Enqueue obuf on dist entry */
+        if (dep->out_queue.last)
+            dep->out_queue.last->next = obuf;
+        else
+            dep->out_queue.first = obuf;
+        dep->out_queue.last = obuf;
+
+        if (!force_busy) {
+            if (!(dep->qflgs & ERTS_DE_QFLG_BUSY)) {
+                if (suspended)
+                    resume = 1; /* was busy when we started, but isn't now */
 #ifdef USE_VM_PROBES
@@ -1728,27 +1833,27 @@
 #endif
-	    }
-	    else {
-		/* Enqueue suspended process on dist entry */
-		ASSERT(plp);
-		if (dep->suspended.last)
-		    dep->suspended.last->next = plp;
-		else
-		    dep->suspended.first = plp;
-		dep->suspended.last = plp;
-	    }
-	}
-
-	erts_smp_mtx_unlock(&dep->qlock);
-	erts_schedule_dist_command(NULL, dep);
-	erts_smp_de_runlock(dep);
-	
-	if (resume) {
-	    erts_resume(c_p, ERTS_PROC_LOCK_MAIN);
-	    erts_proclist_destroy(plp);
-	    /*
-	     * Note that the calling process still have to yield as if it
-	     * suspended. If not, the calling process could later be
-	     * erroneously scheduled when it shouldn't be.
-	     */
-	}
+            }
+            else {
+                /* Enqueue suspended process on dist entry */
+                ASSERT(plp);
+                if (dep->suspended.last)
+                    dep->suspended.last->next = plp;
+                else
+                    dep->suspended.first = plp;
+                dep->suspended.last = plp;
+            }
+        }
+
+        erts_smp_mtx_unlock(&dep->qlock);
+        erts_schedule_dist_command(NULL, dep);
+        erts_smp_de_runlock(dep);
+
+        if (resume) {
+            erts_resume(c_p, ERTS_PROC_LOCK_MAIN);
+            erts_proclist_destroy(plp);
+            /*
+             * Note that the calling process still have to yield as if it
+             * suspended. If not, the calling process could later be
+             * erroneously scheduled when it shouldn't be.
+             */
+        }
     }
@@ -1756,15 +1861,15 @@
     if (c_p) {
-	int reds;
-	/* 
-	 * Bump reductions on calling process.
-	 *
-	 * This is the reduction cost: Always a base cost of 8 reductions
-	 * plus 16 reductions per kilobyte generated external data.
-	 */
+        int reds;
+        /* 
+         * Bump reductions on calling process.
+         *
+         * This is the reduction cost: Always a base cost of 8 reductions
+         * plus 16 reductions per kilobyte generated external data.
+         */
 
-	data_size >>= (10-4);
+        data_size >>= (10-4);
 #if defined(ARCH_64) && !HALFWORD_HEAP
-	data_size &= 0x003fffffffffffff;
+        data_size &= 0x003fffffffffffff;
 #elif defined(ARCH_32) || HALFWORD_HEAP
-	data_size &= 0x003fffff;
+        data_size &= 0x003fffff;
 #else
@@ -1772,4 +1877,4 @@
 #endif
-	reds = 8 + ((int) data_size > 1000000 ? 1000000 : (int) data_size);
-	BUMP_REDS(c_p, reds);
+        reds = 8 + ((int) data_size > 1000000 ? 1000000 : (int) data_size);
+        BUMP_REDS(c_p, reds);
     }
@@ -1790,5 +1895,5 @@
 #endif
-	if (!resume && erts_system_monitor_flags.busy_dist_port)
-	    monitor_generic(c_p, am_busy_dist_port, cid);
-	return ERTS_DSIG_SEND_YIELD;
+        if (!resume && erts_system_monitor_flags.busy_dist_port)
+            monitor_generic(c_p, am_busy_dist_port, cid);
+        return ERTS_DSIG_SEND_YIELD;
     }
@@ -1808,7 +1913,7 @@
     if (size > (Uint) INT_MAX)
-	erl_exit(ERTS_ABORT_EXIT,
-		 "Absurdly large distribution output data buffer "
-		 "(%beu bytes) passed.\n",
-		 size);
-
+        erl_exit(ERTS_ABORT_EXIT,
+                "Absurdly large distribution output data buffer "
+                "(%beu bytes) passed.\n",
+                size);
+        
 #ifdef USE_VM_PROBES
@@ -1828,4 +1933,4 @@
     (*prt->drv_ptr->output)((ErlDrvData) prt->drv_data,
-			    (char*) obuf->extp,
-			    (int) size);
+            (char*) obuf->extp,
+            (int) size);
     erts_unblock_fpe(fpe_was_unmasked);
@@ -1847,6 +1952,6 @@
     if (size > (Uint) INT_MAX)
-	erl_exit(ERTS_ABORT_EXIT,
-		 "Absurdly large distribution output data buffer "
-		 "(%beu bytes) passed.\n",
-		 size);
+        erl_exit(ERTS_ABORT_EXIT,
+                "Absurdly large distribution output data buffer "
+                "(%beu bytes) passed.\n",
+                size);
 
@@ -1901,5 +2006,5 @@
 #define ERTS_PORT_REDS_DIST_CMD_DATA(SZ) \
-  ((SZ) < (1 << 10) \
-   ? ((Sint) 1) \
-   : ((((Sint) (SZ)) >> 10) & ((Sint) ERTS_PORT_REDS_MASK__)))
+        ((SZ) < (1 << 10) \
+                ? ((Sint) 1) \
+                        : ((((Sint) (SZ)) >> 10) & ((Sint) ERTS_PORT_REDS_MASK__)))
 
@@ -1931,5 +2036,5 @@
     if (status & ERTS_DE_SFLG_EXITING) {
-	erts_do_exit_port(prt, prt->id, am_killed);
-	erts_deref_dist_entry(dep);
-	return reds + ERTS_PORT_REDS_DIST_CMD_EXIT;
+        erts_do_exit_port(prt, prt->id, am_killed);
+        erts_deref_dist_entry(dep);
+        return reds + ERTS_PORT_REDS_DIST_CMD_EXIT;
     }
@@ -1959,3 +2064,3 @@
     if (reds > reds_limit)
-	goto preempted;
+        goto preempted;
 
@@ -1964,27 +2069,27 @@
     if (!prt_busy && foq.first) {
-	int preempt = 0;
-	do {
-	    Uint size;
-	    ErtsDistOutputBuf *fob;
+        int preempt = 0;
+        do {
+            Uint size;
+            ErtsDistOutputBuf *fob;
 
-	    size = (*send)(prt, foq.first);
+            size = (*send)(prt, foq.first);
 #ifdef ERTS_RAW_DIST_MSG_DBG
-	    erts_fprintf(stderr, ">> ");
-	    bw(foq.first->extp, size);
+            erts_fprintf(stderr, ">> ");
+            bw(foq.first->extp, size);
 #endif
-	    reds += ERTS_PORT_REDS_DIST_CMD_DATA(size);
-	    fob = foq.first;
-	    obufsize += size_obuf(fob);
-	    foq.first = foq.first->next;
-	    free_dist_obuf(fob);
-	    preempt = reds > reds_limit || (prt->status & ERTS_PORT_SFLGS_DEAD);
-	    if (prt->status & ERTS_PORT_SFLG_PORT_BUSY) {
-		prt_busy = 1;
-		break;
-	    }
-	} while (foq.first && !preempt);
-	if (!foq.first)
-	    foq.last = NULL;
-	if (preempt)
-	    goto preempted;
+            reds += ERTS_PORT_REDS_DIST_CMD_DATA(size);
+            fob = foq.first;
+            obufsize += size_obuf(fob);
+            foq.first = foq.first->next;
+            free_dist_obuf(fob);
+            preempt = reds > reds_limit || (prt->status & ERTS_PORT_SFLGS_DEAD);
+            if (prt->status & ERTS_PORT_SFLG_PORT_BUSY) {
+                prt_busy = 1;
+                break;
+            }
+        } while (foq.first && !preempt);
+        if (!foq.first)
+            foq.last = NULL;
+        if (preempt)
+            goto preempted;
     }
@@ -1992,118 +2097,118 @@
     if (prt_busy) {
-	if (oq.first) {
-	    ErtsDistOutputBuf *ob;
-	    int preempt;
-	finalize_only:
-	    preempt = 0;
-	    ob = oq.first;
-	    ASSERT(ob);
-	    do {
-		ob->extp = erts_encode_ext_dist_header_finalize(ob->extp,
-								dep->cache);
-		if (!(flags & DFLAG_DIST_HDR_ATOM_CACHE))
-		    *--ob->extp = PASS_THROUGH; /* Old node; 'pass through'
+        if (oq.first) {
+            ErtsDistOutputBuf *ob;
+            int preempt;
+            finalize_only:
+            preempt = 0;
+            ob = oq.first;
+            ASSERT(ob);
+            do {
+                ob->extp = erts_encode_ext_dist_header_finalize(ob->extp,
+                        dep->cache);
+                if (!(flags & DFLAG_DIST_HDR_ATOM_CACHE))
+                    *--ob->extp = PASS_THROUGH; /* Old node; 'pass through'
 						   needed */
-		ASSERT(&ob->data[0] <= ob->extp && ob->extp < ob->ext_endp);
-		reds += ERTS_PORT_REDS_DIST_CMD_FINALIZE;
-		preempt = reds > reds_limit;
-		if (preempt)
-		    break;
-		ob = ob->next;
-	    } while (ob);
-	    /*
-	     * At least one buffer was finalized; if we got preempted,
-	     * ob points to the last buffer that we finalized.
-	     */
-	    if (foq.last)
-		foq.last->next = oq.first;
-	    else
-		foq.first = oq.first;
-	    if (!preempt) {
-		/* All buffers finalized */
-		foq.last = oq.last;
-		oq.first = oq.last = NULL;
-	    }
-	    else {
-		/* Not all buffers finalized; split oq. */
-		foq.last = ob;
-		oq.first = ob->next;
-		if (oq.first)
-		    ob->next = NULL;
-		else
-		    oq.last = NULL;
-	    }
-	    if (preempt)
-		goto preempted;
-	}
+                ASSERT(&ob->data[0] <= ob->extp && ob->extp < ob->ext_endp);
+                reds += ERTS_PORT_REDS_DIST_CMD_FINALIZE;
+                preempt = reds > reds_limit;
+                if (preempt)
+                    break;
+                ob = ob->next;
+            } while (ob);
+            /*
+             * At least one buffer was finalized; if we got preempted,
+             * ob points to the last buffer that we finalized.
+             */
+            if (foq.last)
+                foq.last->next = oq.first;
+            else
+                foq.first = oq.first;
+            if (!preempt) {
+                /* All buffers finalized */
+                foq.last = oq.last;
+                oq.first = oq.last = NULL;
+            }
+            else {
+                /* Not all buffers finalized; split oq. */
+                foq.last = ob;
+                oq.first = ob->next;
+                if (oq.first)
+                    ob->next = NULL;
+                else
+                    oq.last = NULL;
+            }
+            if (preempt)
+                goto preempted;
+        }
     }
     else {
-	int preempt = 0;
-	while (oq.first && !preempt) {
-	    ErtsDistOutputBuf *fob;
-	    Uint size;
-	    oq.first->extp
-		= erts_encode_ext_dist_header_finalize(oq.first->extp,
-						       dep->cache);
-	    reds += ERTS_PORT_REDS_DIST_CMD_FINALIZE;
-	    if (!(flags & DFLAG_DIST_HDR_ATOM_CACHE))
-		*--oq.first->extp = PASS_THROUGH; /* Old node; 'pass through'
+        int preempt = 0;
+        while (oq.first && !preempt) {
+            ErtsDistOutputBuf *fob;
+            Uint size;
+            oq.first->extp
+            = erts_encode_ext_dist_header_finalize(oq.first->extp,
+                    dep->cache);
+            reds += ERTS_PORT_REDS_DIST_CMD_FINALIZE;
+            if (!(flags & DFLAG_DIST_HDR_ATOM_CACHE))
+                *--oq.first->extp = PASS_THROUGH; /* Old node; 'pass through'
 						     needed */
-	    ASSERT(&oq.first->data[0] <= oq.first->extp
-		   && oq.first->extp < oq.first->ext_endp);
-	    size = (*send)(prt, oq.first);
+            ASSERT(&oq.first->data[0] <= oq.first->extp
+                    && oq.first->extp < oq.first->ext_endp);
+            size = (*send)(prt, oq.first);
 #ifdef ERTS_RAW_DIST_MSG_DBG
-	    erts_fprintf(stderr, ">> ");
-	    bw(oq.first->extp, size);
+            erts_fprintf(stderr, ">> ");
+            bw(oq.first->extp, size);
 #endif
-	    reds += ERTS_PORT_REDS_DIST_CMD_DATA(size);
-	    fob = oq.first;
-	    obufsize += size_obuf(fob);
-	    oq.first = oq.first->next;
-	    free_dist_obuf(fob);
-	    preempt = reds > reds_limit || (prt->status & ERTS_PORT_SFLGS_DEAD);
-	    if (prt->status & ERTS_PORT_SFLG_PORT_BUSY) {
-		prt_busy = 1;
-		if (oq.first && !preempt)
-		    goto finalize_only;
-	    }
-	}
-
-	ASSERT(!oq.first || preempt);
-
-	/*
-	 * Preempt if not all buffers have been handled.
-	 */
-	if (preempt && oq.first)
-	    goto preempted;
+            reds += ERTS_PORT_REDS_DIST_CMD_DATA(size);
+            fob = oq.first;
+            obufsize += size_obuf(fob);
+            oq.first = oq.first->next;
+            free_dist_obuf(fob);
+            preempt = reds > reds_limit || (prt->status & ERTS_PORT_SFLGS_DEAD);
+            if (prt->status & ERTS_PORT_SFLG_PORT_BUSY) {
+                prt_busy = 1;
+                if (oq.first && !preempt)
+                    goto finalize_only;
+            }
+        }
+
+        ASSERT(!oq.first || preempt);
+
+        /*
+         * Preempt if not all buffers have been handled.
+         */
+        if (preempt && oq.first)
+            goto preempted;
 
 #ifdef DEBUG
-	oq.last = NULL;
+        oq.last = NULL;
 #endif
-	ASSERT(!oq.first);
-	ASSERT(!foq.first && !foq.last);
+        ASSERT(!oq.first);
+        ASSERT(!foq.first && !foq.last);
+
+        /*
+         * Everything that was buffered when we started have now been
+         * written to the port. If port isn't busy but dist entry is
+         * and we havn't got too muched queued on dist entry, set
+         * dist entry in a non-busy state and resume suspended
+         * processes.
+         */
+        erts_smp_mtx_lock(&dep->qlock);
+        ASSERT(dep->qsize >= obufsize);
+        dep->qsize -= obufsize;
+        obufsize = 0;
+        if (!prt_busy
+                && (dep->qflgs & ERTS_DE_QFLG_BUSY)
+                && dep->qsize < erts_dist_buf_busy_limit) {
+            ErtsProcList *suspendees;
+            int resumed;
+            suspendees = get_suspended_on_de(dep, ERTS_DE_QFLG_BUSY);
+            erts_smp_mtx_unlock(&dep->qlock);
 
-	/*
-	 * Everything that was buffered when we started have now been
-	 * written to the port. If port isn't busy but dist entry is
-	 * and we havn't got too muched queued on dist entry, set
-	 * dist entry in a non-busy state and resume suspended
-	 * processes.
-	 */
-	erts_smp_mtx_lock(&dep->qlock);
-	ASSERT(dep->qsize >= obufsize);
-	dep->qsize -= obufsize;
-	obufsize = 0;
-	if (!prt_busy
-	    && (dep->qflgs & ERTS_DE_QFLG_BUSY)
-	    && dep->qsize < erts_dist_buf_busy_limit) {
-	    ErtsProcList *suspendees;
-	    int resumed;
-	    suspendees = get_suspended_on_de(dep, ERTS_DE_QFLG_BUSY);
-	    erts_smp_mtx_unlock(&dep->qlock);
-
-	    resumed = erts_resume_processes(suspendees);
-	    reds += resumed*ERTS_PORT_REDS_DIST_CMD_RESUMED;
-	}
-	else
-	    erts_smp_mtx_unlock(&dep->qlock);
+            resumed = erts_resume_processes(suspendees);
+            reds += resumed*ERTS_PORT_REDS_DIST_CMD_RESUMED;
+        }
+        else
+            erts_smp_mtx_unlock(&dep->qlock);
     }
@@ -2112,10 +2217,10 @@
 
- done:
+    done:
 
     if (obufsize != 0) {
-	ASSERT(obufsize > 0);
-	erts_smp_mtx_lock(&dep->qlock);
-	ASSERT(dep->qsize >= obufsize);
-	dep->qsize -= obufsize;
-	erts_smp_mtx_unlock(&dep->qlock);
+        ASSERT(obufsize > 0);
+        erts_smp_mtx_lock(&dep->qlock);
+        ASSERT(dep->qsize >= obufsize);
+        dep->qsize -= obufsize;
+        erts_smp_mtx_unlock(&dep->qlock);
     }
@@ -2128,9 +2233,9 @@
     if (foq.first) {
-	dep->finalized_out_queue.first = foq.first;
-	dep->finalized_out_queue.last = foq.last;
+        dep->finalized_out_queue.first = foq.first;
+        dep->finalized_out_queue.last = foq.last;
     }
 
-     /* Avoid wrapping reduction counter... */
+    /* Avoid wrapping reduction counter... */
     if (reds > INT_MAX/2)
-	reds = INT_MAX/2;
+        reds = INT_MAX/2;
 
@@ -2140,3 +2245,3 @@
 
- preempted:
+    preempted:
 
@@ -2146,28 +2251,28 @@
     if (prt->status & ERTS_PORT_SFLGS_DEAD) {
-	/*
-	 * Port died during port command; clean up 'oq'
-	 * and 'foq'. Things buffered in dist entry after
-	 * we begun processing the queues have already been
-	 * cleaned up when port terminated.
-	 */
-
-	if (oq.first)
-	    oq.last->next = foq.first;
-	else
-	    oq.first = foq.first;
-
-	while (oq.first) {
-	    ErtsDistOutputBuf *fob = oq.first;
-	    oq.first = oq.first->next;
-	    obufsize += size_obuf(fob);
-	    free_dist_obuf(fob);
-	}
+        /*
+         * Port died during port command; clean up 'oq'
+         * and 'foq'. Things buffered in dist entry after
+         * we begun processing the queues have already been
+         * cleaned up when port terminated.
+         */
+
+        if (oq.first)
+            oq.last->next = foq.first;
+        else
+            oq.first = foq.first;
+
+        while (oq.first) {
+            ErtsDistOutputBuf *fob = oq.first;
+            oq.first = oq.first->next;
+            obufsize += size_obuf(fob);
+            free_dist_obuf(fob);
+        }
 
-	foq.first = NULL;
-	foq.last = NULL;
+        foq.first = NULL;
+        foq.last = NULL;
 
 #ifdef DEBUG
-	erts_smp_mtx_lock(&dep->qlock);
-	ASSERT(dep->qsize == obufsize);
-	erts_smp_mtx_unlock(&dep->qlock);
+        erts_smp_mtx_lock(&dep->qlock);
+        ASSERT(dep->qsize == obufsize);
+        erts_smp_mtx_unlock(&dep->qlock);
 #endif
@@ -2175,18 +2280,18 @@
     else {
-	if (oq.first) {
-	    /*
-	     * Unhandle buffers need to be put back first
-	     * in out_queue.
-	     */
-	    erts_smp_mtx_lock(&dep->qlock);
-	    dep->qsize -= obufsize;
-	    obufsize = 0;
-	    oq.last->next = dep->out_queue.first;
-	    dep->out_queue.first = oq.first;
-	    if (!dep->out_queue.last)
-		dep->out_queue.last = oq.last;
-	    erts_smp_mtx_unlock(&dep->qlock);
-	}
+        if (oq.first) {
+            /*
+             * Unhandle buffers need to be put back first
+             * in out_queue.
+             */
+            erts_smp_mtx_lock(&dep->qlock);
+            dep->qsize -= obufsize;
+            obufsize = 0;
+            oq.last->next = dep->out_queue.first;
+            dep->out_queue.first = oq.first;
+            if (!dep->out_queue.last)
+                dep->out_queue.last = oq.last;
+            erts_smp_mtx_unlock(&dep->qlock);
+        }
 
-	erts_schedule_dist_command(prt, NULL);
+        erts_schedule_dist_command(prt, NULL);
     }
@@ -2218,13 +2323,13 @@
     if (is_internal_port(dep->cid)
-	&& connection_id == dep->connection_id
-	&& !(dep->status & ERTS_DE_SFLG_EXITING)) {
+            && connection_id == dep->connection_id
+            && !(dep->status & ERTS_DE_SFLG_EXITING)) {
 
-	dep->status |= ERTS_DE_SFLG_EXITING;
+        dep->status |= ERTS_DE_SFLG_EXITING;
 
-	erts_smp_mtx_lock(&dep->qlock);
-	ASSERT(!(dep->qflgs & ERTS_DE_QFLG_EXIT));
-	dep->qflgs |= ERTS_DE_QFLG_EXIT;
-	erts_smp_mtx_unlock(&dep->qlock);
+        erts_smp_mtx_lock(&dep->qlock);
+        ASSERT(!(dep->qflgs & ERTS_DE_QFLG_EXIT));
+        dep->qflgs |= ERTS_DE_QFLG_EXIT;
+        erts_smp_mtx_unlock(&dep->qlock);
 
-	erts_schedule_dist_command(NULL, dep);
+        erts_schedule_dist_command(NULL, dep);
     }
@@ -2234,4 +2339,4 @@
 struct print_to_data {
-    int to;
-    void *arg;
+        int to;
+        void *arg;
 };
@@ -2246,15 +2351,15 @@
     if (!rp || (rmon = erts_lookup_monitor(rp->monitors, mon->ref)) == NULL) {
-	erts_print(to, arg, "Warning, stray monitor for: %T\n", mon->pid);
+        erts_print(to, arg, "Warning, stray monitor for: %T\n", mon->pid);
     } else if (mon->type == MON_ORIGIN) {
-	/* Local pid is being monitored */
-	erts_print(to, arg, "Remotely monitored by: %T %T\n",
-		   mon->pid, rmon->pid);
+        /* Local pid is being monitored */
+        erts_print(to, arg, "Remotely monitored by: %T %T\n",
+                mon->pid, rmon->pid);
     } else {
-	erts_print(to, arg, "Remote monitoring: %T ", mon->pid);
-	if (is_not_atom(rmon->pid))
-	    erts_print(to, arg, "%T\n", rmon->pid);
-	else
-	    erts_print(to, arg, "{%T, %T}\n",
-		       rmon->name,
-		       rmon->pid); /* which in this case is the 
+        erts_print(to, arg, "Remote monitoring: %T ", mon->pid);
+        if (is_not_atom(rmon->pid))
+            erts_print(to, arg, "%T\n", rmon->pid);
+        else
+            erts_print(to, arg, "{%T, %T}\n",
+                    rmon->name,
+                    rmon->pid); /* which in this case is the 
 				      remote system name... */
@@ -2270,4 +2375,4 @@
 typedef struct {
-    struct print_to_data *ptdp;
-    Eterm from;
+        struct print_to_data *ptdp;
+        Eterm from;
 } PrintLinkContext;
@@ -2278,3 +2383,3 @@
     erts_print(pplc->ptdp->to, pplc->ptdp->arg, "Remote link: %T %T\n",
-	       pplc->from, lnk->pid);
+            pplc->from, lnk->pid);
 }
@@ -2284,4 +2389,4 @@
     if (is_internal_pid(lnk->pid) && erts_pid2proc_unlocked(lnk->pid)) {
-	PrintLinkContext plc = {(struct print_to_data *) vptdp, lnk->pid};
-	erts_doforall_links(ERTS_LINK_ROOT(lnk), &doit_print_link_info2, &plc);
+        PrintLinkContext plc = {(struct print_to_data *) vptdp, lnk->pid};
+        erts_doforall_links(ERTS_LINK_ROOT(lnk), &doit_print_link_info2, &plc);
     } 
@@ -2296,6 +2401,6 @@
 typedef struct {
-    struct print_to_data ptd;
-    Eterm sysname;
+        struct print_to_data ptd;
+        Eterm sysname;
 } PrintNodeLinkContext;
-    
+
 
@@ -2306,4 +2411,4 @@
     if (is_internal_pid(lnk->pid) && erts_pid2proc_unlocked(lnk->pid))
-	erts_print(pcontext->ptd.to, pcontext->ptd.arg,
-		   "Remote monitoring: %T %T\n", lnk->pid, pcontext->sysname);
+        erts_print(pcontext->ptd.to, pcontext->ptd.arg,
+                "Remote monitoring: %T %T\n", lnk->pid, pcontext->sysname);
 }
@@ -2321,47 +2426,47 @@
 
-  if (visible && connected) {
-      erts_print(to, arg, "=visible_node:");
-  } else if (connected) {
-      erts_print(to, arg, "=hidden_node:");
-  } else {
-      erts_print(to, arg, "=not_connected:");
-  }
-  erts_print(to, arg, "%d\n", dist_entry_channel_no(dep));
-
-  if(connected && is_nil(dep->cid)) {
-    erts_print(to, arg,
-	       "Error: Not connected node still registered as connected:%T\n",
-	       dep->sysname);
-    return 0;
-  }
+    if (visible && connected) {
+        erts_print(to, arg, "=visible_node:");
+    } else if (connected) {
+        erts_print(to, arg, "=hidden_node:");
+    } else {
+        erts_print(to, arg, "=not_connected:");
+    }
+    erts_print(to, arg, "%d\n", dist_entry_channel_no(dep));
 
-  if(!connected && is_not_nil(dep->cid)) {
-    erts_print(to, arg,
-	       "Error: Connected node not registered as connected:%T\n",
-	       dep->sysname);
-    return 0;
-  }
+    if(connected && is_nil(dep->cid)) {
+        erts_print(to, arg,
+                "Error: Not connected node still registered as connected:%T\n",
+                dep->sysname);
+        return 0;
+    }
 
-  erts_print(to, arg, "Name: %T", dep->sysname);
+    if(!connected && is_not_nil(dep->cid)) {
+        erts_print(to, arg,
+                "Error: Connected node not registered as connected:%T\n",
+                dep->sysname);
+        return 0;
+    }
+
+    erts_print(to, arg, "Name: %T", dep->sysname);
 #ifdef DEBUG
-  erts_print(to, arg, " (refc=%d)", erts_refc_read(&dep->refc, 1));
+    erts_print(to, arg, " (refc=%d)", erts_refc_read(&dep->refc, 1));
 #endif
-  erts_print(to, arg, "\n");
-  if (!connected && is_nil(dep->cid)) {
-    if (dep->nlinks) {
-      erts_print(to, arg, "Error: Got links to not connected node:%T\n",
-		 dep->sysname);
+    erts_print(to, arg, "\n");
+    if (!connected && is_nil(dep->cid)) {
+        if (dep->nlinks) {
+            erts_print(to, arg, "Error: Got links to not connected node:%T\n",
+                    dep->sysname);
+        }
+        return 0;
     }
-    return 0;
-  }
 
-  erts_print(to, arg, "Controller: %T\n", dep->cid, to);
+    erts_print(to, arg, "Controller: %T\n", dep->cid, to);
 
-  erts_print_node_info(to, arg, dep->sysname, NULL, NULL);
-  print_monitor_info(to, arg, dep->monitors);
-  print_link_info(to, arg, dep->nlinks);
-  print_nodelink_info(to, arg, dep->node_links, dep->sysname);
+    erts_print_node_info(to, arg, dep->sysname, NULL, NULL);
+    print_monitor_info(to, arg, dep->monitors);
+    print_link_info(to, arg, dep->nlinks);
+    print_nodelink_info(to, arg, dep->node_links, dep->sysname);
+
+    return 0;
 
-  return 0;
-    
 }
@@ -2372,6 +2477,6 @@
     erts_print(to, arg, "=node:%T\n", erts_this_dist_entry->sysname);
- 
+
     if (erts_this_node->sysname == am_Noname) {
-	erts_print(to, arg, "=no_distribution\n");
-	return(0);
+        erts_print(to, arg, "=no_distribution\n");
+        return(0);
     }
@@ -2380,3 +2485,3 @@
     if (!erts_visible_dist_entries && !erts_hidden_dist_entries) 
-      erts_print(to, arg, "Alive but not holding any connections \n");
+        erts_print(to, arg, "Alive but not holding any connections \n");
 #endif
@@ -2384,3 +2489,3 @@
     for(dep = erts_visible_dist_entries; dep; dep = dep->next) {
-      info_dist_entry(to, arg, dep, 1, 1);
+        info_dist_entry(to, arg, dep, 1, 1);
     }
@@ -2388,3 +2493,3 @@
     for(dep = erts_hidden_dist_entries; dep; dep = dep->next) {
-      info_dist_entry(to, arg, dep, 0, 1);
+        info_dist_entry(to, arg, dep, 0, 1);
     }
@@ -2392,3 +2497,3 @@
     for (dep = erts_not_connected_dist_entries; dep; dep = dep->next) {
-	info_dist_entry(to, arg, dep, 0, 0);
+        info_dist_entry(to, arg, dep, 0, 0);
     }
@@ -2414,3 +2519,3 @@
             dist_unlink/2     -- unlink a remote from a local
-****************************************************************************/
+ ****************************************************************************/
 
@@ -2439,5 +2544,5 @@
     if(!term_to_Uint(BIF_ARG_2, &creation))
-	goto error;
+        goto error;
     if(creation > 3)
-	goto error;
+        goto error;
 
@@ -2445,8 +2550,8 @@
     if (!is_node_name_atom(BIF_ARG_1))
-	goto error;
+        goto error;
 
     if (BIF_ARG_1 == am_Noname) /* cant use this name !! */
-	goto error;
+        goto error;
     if (erts_is_alive)     /* must not be alive! */
-	goto error;
+        goto error;
 
@@ -2454,11 +2559,11 @@
     if (dsend2_trap->address == NULL ||
-	dsend3_trap->address == NULL ||
-	/*	dsend_nosuspend_trap->address == NULL ||*/
-	dlink_trap->address == NULL ||
-	dunlink_trap->address == NULL ||
-	dmonitor_node_trap->address == NULL ||
-	dgroup_leader_trap->address == NULL ||
-	dmonitor_p_trap->address == NULL ||
-	dexit_trap->address == NULL) {
-	goto error;
+            dsend3_trap->address == NULL ||
+            /*	dsend_nosuspend_trap->address == NULL ||*/
+            dlink_trap->address == NULL ||
+            dunlink_trap->address == NULL ||
+            dmonitor_node_trap->address == NULL ||
+            dgroup_leader_trap->address == NULL ||
+            dmonitor_p_trap->address == NULL ||
+            dexit_trap->address == NULL) {
+        goto error;
     }
@@ -2466,5 +2571,5 @@
     net_kernel = erts_whereis_process(BIF_P, ERTS_PROC_LOCK_MAIN,
-				      am_net_kernel, ERTS_PROC_LOCK_MAIN, 0);
+            am_net_kernel, ERTS_PROC_LOCK_MAIN, 0);
     if (!net_kernel)
-	goto error;
+        goto error;
 
@@ -2474,4 +2579,4 @@
     (void *) ERTS_PROC_SET_DIST_ENTRY(net_kernel,
-				      ERTS_PROC_LOCK_MAIN,
-				      erts_this_dist_entry);
+            ERTS_PROC_LOCK_MAIN,
+            erts_this_dist_entry);
     erts_refc_inc(&erts_this_dist_entry->refc, 2);
@@ -2480,3 +2585,3 @@
     if (net_kernel != BIF_P)
-	erts_smp_proc_unlock(net_kernel, ERTS_PROC_LOCK_MAIN);
+        erts_smp_proc_unlock(net_kernel, ERTS_PROC_LOCK_MAIN);
 
@@ -2498,3 +2603,3 @@
 
- error:
+    error:
     BIF_ERROR(BIF_P, BADARG);
@@ -2533,23 +2638,38 @@
      */
-
-    if (!is_node_name_atom(BIF_ARG_1) ||
-	is_not_internal_port(BIF_ARG_2) ||
-	(erts_this_node->sysname == am_Noname)) {
-	goto badarg;
+    
+    erts_fprintf(stderr, "setnode_3 - %T\n", BIF_ARG_1);
+    erts_fprintf(stderr, "setnode_3 - %T\n", BIF_ARG_2);
+    erts_fprintf(stderr, "setnode_3 - %T\n", BIF_ARG_3);
+
+    if ((!is_node_name_atom(BIF_ARG_1) && BIF_ARG_1 != am_all) ||
+            is_not_internal_port(BIF_ARG_2) ||
+            (erts_this_node->sysname == am_Noname)) {
+        erts_fprintf(stderr, "1 - %T\n", BIF_ARG_1);
+        goto badarg;
     }
 
-    if (!is_tuple(BIF_ARG_3))
-	goto badarg;
+    if (!is_tuple(BIF_ARG_3)) {
+        erts_fprintf(stderr, "2\n");
+        goto badarg;
+    }
     tp = tuple_val(BIF_ARG_3);
-    if (*tp++ != make_arityval(4))
-	goto badarg;
-    if (!is_small(*tp))
-	goto badarg;
+    if (*tp++ != make_arityval(4)) {
+        erts_fprintf(stderr, "3\n");
+        goto badarg;
+    }
+    if (!is_small(*tp)) {
+        erts_fprintf(stderr, "4\n");
+        goto badarg;
+    }
     flags = unsigned_val(*tp++);
-    if (!is_small(*tp) || (version = unsigned_val(*tp)) == 0)
-	goto badarg;
+    if (!is_small(*tp) || (version = unsigned_val(*tp)) == 0) {
+        erts_fprintf(stderr, "5\n");
+        goto badarg;
+    }
     ic = *(++tp);
     oc = *(++tp);
-    if (!is_atom(ic) || !is_atom(oc))
-	goto badarg;
+    if (!is_atom(ic) || !is_atom(oc)) {
+        erts_fprintf(stderr, "6\n");
+        goto badarg;
+    }
 
@@ -2557,12 +2677,13 @@
     if (!(DFLAG_EXTENDED_REFERENCES & flags)) {
-	erts_dsprintf_buf_t *dsbufp = erts_create_logger_dsbuf();
-	erts_dsprintf(dsbufp, "%T", BIF_P->id);
-	if (BIF_P->reg)
-	    erts_dsprintf(dsbufp, " (%T)", BIF_P->reg->name);
-	erts_dsprintf(dsbufp,
-		      " attempted to enable connection to node %T "
-		      "which is not able to handle extended references.\n",
-		      BIF_ARG_1);
-	erts_send_error_to_logger(BIF_P->group_leader, dsbufp);
-	goto badarg;
+        erts_dsprintf_buf_t *dsbufp = erts_create_logger_dsbuf();
+        erts_dsprintf(dsbufp, "%T", BIF_P->id);
+        if (BIF_P->reg)
+            erts_dsprintf(dsbufp, " (%T)", BIF_P->reg->name);
+        erts_dsprintf(dsbufp,
+                " attempted to enable connection to node %T "
+                "which is not able to handle extended references.\n",
+                BIF_ARG_1);
+        erts_send_error_to_logger(BIF_P->group_leader, dsbufp);
+        erts_fprintf(stderr, "7\n");
+        goto badarg;
     }
@@ -2575,6 +2696,8 @@
     dep = erts_find_or_insert_dist_entry(BIF_ARG_1);
-    if (dep == erts_this_dist_entry)
-	goto badarg;
+    if (dep == erts_this_dist_entry) {
+        erts_fprintf(stderr, "8 - %T\n", BIF_ARG_1);
+        goto badarg;
+    }
     else if (!dep)
-	goto system_limit; /* Should never happen!!! */
+        goto system_limit; /* Should never happen!!! */
 
@@ -2583,24 +2706,28 @@
 
-    if (!pp || (pp->status & ERTS_PORT_SFLG_EXITING))
-	goto badarg;
+    if (!pp || (pp->status & ERTS_PORT_SFLG_EXITING)) {
+        erts_fprintf(stderr, "9\n");
+        goto badarg;
+    }
 
-    if ((pp->drv_ptr->flags & ERL_DRV_FLAG_SOFT_BUSY) == 0)
-	goto badarg;
+    if ((pp->drv_ptr->flags & ERL_DRV_FLAG_SOFT_BUSY) == 0) {
+        erts_fprintf(stderr, "10\n");
+        goto badarg;
+    }
 
     if (dep->cid == BIF_ARG_2 && pp->dist_entry == dep)
-	goto done; /* Already set */
+        goto done; /* Already set */
 
     if (dep->status & ERTS_DE_SFLG_EXITING) {
-	/* Suspend on dist entry waiting for the exit to finish */
-	ErtsProcList *plp = erts_proclist_create(BIF_P);
-	plp->next = NULL;
-	erts_suspend(BIF_P, ERTS_PROC_LOCK_MAIN, NULL);
-	erts_smp_mtx_lock(&dep->qlock);
-	if (dep->suspended.last)
-	    dep->suspended.last->next = plp;
-	else
-	    dep->suspended.first = plp;
-	dep->suspended.last = plp;
-	erts_smp_mtx_unlock(&dep->qlock);
-	goto yield;
+        /* Suspend on dist entry waiting for the exit to finish */
+        ErtsProcList *plp = erts_proclist_create(BIF_P);
+        plp->next = NULL;
+        erts_suspend(BIF_P, ERTS_PROC_LOCK_MAIN, NULL);
+        erts_smp_mtx_lock(&dep->qlock);
+        if (dep->suspended.last)
+            dep->suspended.last->next = plp;
+        else
+            dep->suspended.first = plp;
+        dep->suspended.last = plp;
+        erts_smp_mtx_unlock(&dep->qlock);
+        goto yield;
     }
@@ -2609,6 +2736,10 @@
 
-    if (pp->dist_entry || is_not_nil(dep->cid))
-	goto badarg;
+    if (pp->dist_entry || is_not_nil(dep->cid)) {
+        erts_fprintf(stderr, "11\n");
+        goto badarg;
+    }
 
     erts_port_status_bor_set(pp, ERTS_PORT_SFLG_DISTRIBUTION);
+    
+    erts_fprintf(stderr, "DEBUG: Setting stuff: %d\n", pp->status & ERTS_PORT_SFLG_DISTRIBUTION);
 
@@ -2623,4 +2754,4 @@
     dep->send = (pp->drv_ptr->outputv
-		 ? dist_port_commandv
-		 : dist_port_command);
+            ? dist_port_commandv
+                    : dist_port_command);
 #else
@@ -2639,3 +2770,3 @@
     if (flags & DFLAG_DIST_HDR_ATOM_CACHE)
-	create_cache(dep);
+        create_cache(dep);
 
@@ -2645,11 +2776,11 @@
     send_nodes_mon_msgs(BIF_P,
-			am_nodeup,
-			BIF_ARG_1,
-			flags & DFLAG_PUBLISHED ? am_visible : am_hidden,
-			NIL);
- done:
+            am_nodeup,
+            BIF_ARG_1,
+            flags & DFLAG_PUBLISHED ? am_visible : am_hidden,
+                    NIL);
+    done:
 
     if (dep && dep != erts_this_dist_entry) {
-	erts_smp_de_rwunlock(dep);
-	erts_deref_dist_entry(dep);
+        erts_smp_de_rwunlock(dep);
+        erts_deref_dist_entry(dep);
     }
@@ -2657,3 +2788,3 @@
     if (pp)
-	erts_smp_port_unlock(pp);
+        erts_smp_port_unlock(pp);
 
@@ -2661,8 +2792,8 @@
 
- yield:
+    yield:
     ERTS_BIF_PREP_YIELD3(ret, bif_export[BIF_setnode_3], BIF_P,
-			 BIF_ARG_1, BIF_ARG_2, BIF_ARG_3);
+            BIF_ARG_1, BIF_ARG_2, BIF_ARG_3);
     goto done;
 
- badarg:
+    badarg:
     ERTS_BIF_PREP_ERROR(ret, BIF_P, BADARG);
@@ -2670,3 +2801,3 @@
 
- system_limit:
+    system_limit:
     ERTS_BIF_PREP_ERROR(ret, BIF_P, SYSTEM_LIMIT);
@@ -2690,8 +2821,8 @@
     if (is_not_external_pid(remote))
-	goto error;
+        goto error;
 
     rdep = external_dist_entry(remote);
-    
+
     if(rdep == erts_this_dist_entry)
-	goto error;
+        goto error;
 
@@ -2699,51 +2830,51 @@
     if (is_internal_pid(local)) {
-	Process *lp;
-	ErtsProcLocks lp_locks;
-	if (BIF_P->id == local) {
-	    lp_locks = ERTS_PROC_LOCKS_ALL;
-	    lp = BIF_P;
-	    erts_smp_proc_lock(BIF_P, ERTS_PROC_LOCKS_ALL_MINOR);
-	}
-	else {
-	    lp_locks = ERTS_PROC_LOCKS_XSIG_SEND;
-	    lp = erts_pid2proc_opt(BIF_P, ERTS_PROC_LOCK_MAIN,
-				   local, lp_locks,
-				   ERTS_P2P_FLG_SMP_INC_REFC);
-	    if (!lp) {
-		BIF_RET(am_true); /* ignore */
-	    }
-	}
-	
-	(void) erts_send_exit_signal(BIF_P,
-				     remote,
-				     lp,
-				     &lp_locks,
-				     BIF_ARG_2,
-				     NIL,
-				     NULL,
-				     0);
+        Process *lp;
+        ErtsProcLocks lp_locks;
+        if (BIF_P->id == local) {
+            lp_locks = ERTS_PROC_LOCKS_ALL;
+            lp = BIF_P;
+            erts_smp_proc_lock(BIF_P, ERTS_PROC_LOCKS_ALL_MINOR);
+        }
+        else {
+            lp_locks = ERTS_PROC_LOCKS_XSIG_SEND;
+            lp = erts_pid2proc_opt(BIF_P, ERTS_PROC_LOCK_MAIN,
+                    local, lp_locks,
+                    ERTS_P2P_FLG_SMP_INC_REFC);
+            if (!lp) {
+                BIF_RET(am_true); /* ignore */
+            }
+        }
+
+        (void) erts_send_exit_signal(BIF_P,
+                remote,
+                lp,
+                &lp_locks,
+                BIF_ARG_2,
+                NIL,
+                NULL,
+                0);
 #ifdef ERTS_SMP
-	if (lp == BIF_P)
-	    lp_locks &= ~ERTS_PROC_LOCK_MAIN;
+        if (lp == BIF_P)
+            lp_locks &= ~ERTS_PROC_LOCK_MAIN;
 #endif
-	erts_smp_proc_unlock(lp, lp_locks);
-	if (lp != BIF_P)
-	    erts_smp_proc_dec_refc(lp);
-	else {
-	    /*
-	     * We may have exited current process and may have to take action.
-	     */
-	    ERTS_BIF_CHK_EXITED(BIF_P);
-	    ERTS_SMP_BIF_CHK_PENDING_EXIT(BIF_P, ERTS_PROC_LOCK_MAIN);
-	}
+        erts_smp_proc_unlock(lp, lp_locks);
+        if (lp != BIF_P)
+            erts_smp_proc_dec_refc(lp);
+        else {
+            /*
+             * We may have exited current process and may have to take action.
+             */
+            ERTS_BIF_CHK_EXITED(BIF_P);
+            ERTS_SMP_BIF_CHK_PENDING_EXIT(BIF_P, ERTS_PROC_LOCK_MAIN);
+        }
     }
     else if (is_external_pid(local)
-	     && external_dist_entry(local) == erts_this_dist_entry) {
-	BIF_RET(am_true); /* ignore */
+            && external_dist_entry(local) == erts_this_dist_entry) {
+        BIF_RET(am_true); /* ignore */
     }
     else
-	goto error;
+        goto error;
     BIF_RET(am_true);
 
- error:
+    error:
     BIF_ERROR(BIF_P, BADARG);
@@ -2757,3 +2888,3 @@
     if (is_not_node_container(BIF_ARG_1))
-      BIF_ERROR(BIF_P, BADARG);
+        BIF_ERROR(BIF_P, BADARG);
     BIF_RET(node_container_node_name(BIF_ARG_1));
@@ -2776,3 +2907,3 @@
 {
-  return nodes_1(BIF_P, am_visible);
+    return nodes_1(BIF_P, am_visible);
 }
@@ -2800,14 +2931,14 @@
     if (is_atom(BIF_ARG_1))
-      arg_list = CONS(buf, BIF_ARG_1, NIL);
+        arg_list = CONS(buf, BIF_ARG_1, NIL);
 
     while (is_list(arg_list)) {
-      switch(CAR(list_val(arg_list))) {
-      case am_visible:   visible = 1;                                 break;
-      case am_hidden:    hidden = 1;                                  break;
-      case am_known:     visible = hidden = not_connected = this = 1; break;
-      case am_this:      this = 1;                                    break;
-      case am_connected: visible = hidden = 1;                        break;
-      default:           goto error;                                  break;
-      }
-      arg_list = CDR(list_val(arg_list));
+        switch(CAR(list_val(arg_list))) {
+            case am_visible:   visible = 1;                                 break;
+            case am_hidden:    hidden = 1;                                  break;
+            case am_known:     visible = hidden = not_connected = this = 1; break;
+            case am_this:      this = 1;                                    break;
+            case am_connected: visible = hidden = 1;                        break;
+            default:           goto error;                                  break;
+        }
+        arg_list = CDR(list_val(arg_list));
     }
@@ -2815,3 +2946,3 @@
     if (is_not_nil(arg_list)) {
-	goto error;
+        goto error;
     }
@@ -2826,9 +2957,9 @@
     if(not_connected)
-      length += erts_no_of_not_connected_dist_entries;
+        length += erts_no_of_not_connected_dist_entries;
     if(hidden)
-      length += erts_no_of_hidden_dist_entries;
+        length += erts_no_of_hidden_dist_entries;
     if(visible)
-      length += erts_no_of_visible_dist_entries;
+        length += erts_no_of_visible_dist_entries;
     if(this)
-      length++;
+        length++;
 
@@ -2837,4 +2968,4 @@
     if (length == 0) {
-	erts_smp_rwmtx_rwunlock(&erts_dist_table_rwmtx);
-	goto done;
+        erts_smp_rwmtx_rwunlock(&erts_dist_table_rwmtx);
+        goto done;
     }
@@ -2847,19 +2978,19 @@
     if(not_connected)
-      for(dep = erts_not_connected_dist_entries; dep; dep = dep->next) {
-	result = CONS(hp, dep->sysname, result);
-	hp += 2;
-      }
+        for(dep = erts_not_connected_dist_entries; dep; dep = dep->next) {
+            result = CONS(hp, dep->sysname, result);
+            hp += 2;
+        }
     if(hidden)
-      for(dep = erts_hidden_dist_entries; dep; dep = dep->next) {
-	result = CONS(hp, dep->sysname, result);
-	hp += 2;
-      }
+        for(dep = erts_hidden_dist_entries; dep; dep = dep->next) {
+            result = CONS(hp, dep->sysname, result);
+            hp += 2;
+        }
     if(visible)
-      for(dep = erts_visible_dist_entries; dep; dep = dep->next) {
-	result = CONS(hp, dep->sysname, result);
-	hp += 2;
-      }
+        for(dep = erts_visible_dist_entries; dep; dep = dep->next) {
+            result = CONS(hp, dep->sysname, result);
+            hp += 2;
+        }
     if(this) {
-	result = CONS(hp, erts_this_dist_entry->sysname, result);
-	hp += 2;
+        result = CONS(hp, erts_this_dist_entry->sysname, result);
+        hp += 2;
     }
@@ -2868,3 +2999,3 @@
 
-done:
+    done:
     UnUseTmpHeap(2,BIF_P);
@@ -2872,3 +3003,3 @@
 
-error:
+    error:
     UnUseTmpHeap(2,BIF_P);
@@ -2897,10 +3028,10 @@
     for (l = Options; l != NIL && is_list(l); l = CDR(list_val(l))) {
-	Eterm t = CAR(list_val(l));
-	/* allow_passive_connect the only available option right now */
-	if (t != am_allow_passive_connect) {
-	    BIF_ERROR(p, BADARG);
-	}
+        Eterm t = CAR(list_val(l));
+        /* allow_passive_connect the only available option right now */
+        if (t != am_allow_passive_connect) {
+            BIF_ERROR(p, BADARG);
+        }
     }
     if (l != NIL) {
-	BIF_ERROR(p, BADARG);
+        BIF_ERROR(p, BADARG);
     }
@@ -2908,6 +3039,6 @@
     if (is_not_atom(Node) ||
-	((Bool != am_true) && (Bool != am_false)) ||
-	((erts_this_node->sysname == am_Noname)
-	 && (Node != erts_this_node->sysname))) {
-	BIF_ERROR(p, BADARG);
+            ((Bool != am_true) && (Bool != am_false)) ||
+            ((erts_this_node->sysname == am_Noname)
+                    && (Node != erts_this_node->sysname))) {
+        BIF_ERROR(p, BADARG);
     }
@@ -2915,7 +3046,7 @@
     if (!dep) {
-    do_trap:
-	BIF_TRAP3(dmonitor_node_trap, p, Node, Bool, Options);
+        do_trap:
+        BIF_TRAP3(dmonitor_node_trap, p, Node, Bool, Options);
     }
     if (dep == erts_this_dist_entry)
-	goto done;
+        goto done;
 
@@ -2924,5 +3055,5 @@
     if (ERTS_DE_IS_NOT_CONNECTED(dep)) {
-	erts_smp_proc_unlock(p, ERTS_PROC_LOCK_LINK);
-	erts_smp_de_runlock(dep);
-	goto do_trap;
+        erts_smp_proc_unlock(p, ERTS_PROC_LOCK_LINK);
+        erts_smp_de_runlock(dep);
+        goto do_trap;
     }
@@ -2932,24 +3063,24 @@
     if (Bool == am_true) {
-	ASSERT(dep->cid != NIL);
-	lnk = erts_add_or_lookup_link(&(dep->node_links), LINK_NODE, 
-				      p->id);
-	++ERTS_LINK_REFC(lnk);
-	lnk = erts_add_or_lookup_link(&(p->nlinks), LINK_NODE, Node);
-	++ERTS_LINK_REFC(lnk);
+        ASSERT(dep->cid != NIL);
+        lnk = erts_add_or_lookup_link(&(dep->node_links), LINK_NODE, 
+                p->id);
+        ++ERTS_LINK_REFC(lnk);
+        lnk = erts_add_or_lookup_link(&(p->nlinks), LINK_NODE, Node);
+        ++ERTS_LINK_REFC(lnk);
     }
     else  {
-	lnk = erts_lookup_link(dep->node_links, p->id);
-	if (lnk != NULL) {
-	    if ((--ERTS_LINK_REFC(lnk)) == 0) {
-		erts_destroy_link(erts_remove_link(&(dep->node_links), 
-						   p->id));
-	    }
-	}
-	lnk = erts_lookup_link(p->nlinks, Node);
-	if (lnk != NULL) {
-	    if ((--ERTS_LINK_REFC(lnk)) == 0) {
-		erts_destroy_link(erts_remove_link(&(p->nlinks),
-						   Node));
-	    }
-	}
+        lnk = erts_lookup_link(dep->node_links, p->id);
+        if (lnk != NULL) {
+            if ((--ERTS_LINK_REFC(lnk)) == 0) {
+                erts_destroy_link(erts_remove_link(&(dep->node_links), 
+                        p->id));
+            }
+        }
+        lnk = erts_lookup_link(p->nlinks, Node);
+        if (lnk != NULL) {
+            if ((--ERTS_LINK_REFC(lnk)) == 0) {
+                erts_destroy_link(erts_remove_link(&(p->nlinks),
+                        Node));
+            }
+        }
     }
@@ -2959,3 +3090,3 @@
 
- done:
+    done:
     erts_deref_dist_entry(dep);
@@ -2982,3 +3113,3 @@
     if (is_not_pid(BIF_ARG_1)) {
-	BIF_ERROR(BIF_P,BADARG);
+        BIF_ERROR(BIF_P,BADARG);
     }
@@ -2987,3 +3118,3 @@
     if (de == erts_this_dist_entry) {
-	BIF_RET(am_true);
+        BIF_RET(am_true);
     }
@@ -2994,3 +3125,3 @@
 }
-    
+
 /*
@@ -3010,3 +3141,3 @@
 #define ERTS_NODES_MON_OPT_TYPES \
-  (ERTS_NODES_MON_OPT_TYPE_VISIBLE|ERTS_NODES_MON_OPT_TYPE_HIDDEN)
+        (ERTS_NODES_MON_OPT_TYPE_VISIBLE|ERTS_NODES_MON_OPT_TYPE_HIDDEN)
 
@@ -3014,7 +3145,7 @@
 struct ErtsNodesMonitor_ {
-    ErtsNodesMonitor *prev;
-    ErtsNodesMonitor *next;
-    Process *proc;
-    Uint16 opts;
-    Uint16 no;
+        ErtsNodesMonitor *prev;
+        ErtsNodesMonitor *next;
+        Process *proc;
+        Uint16 opts;
+        Uint16 no;
 };
@@ -3049,18 +3180,18 @@
     if (!nmp->opts) {
-	sz = 3;
+        sz = 3;
     }
     else {
-	sz = 0;
+        sz = 0;
 
-	if (nmp->opts & ERTS_NODES_MON_OPT_TYPES)
-	    sz += 2 + 3;
+        if (nmp->opts & ERTS_NODES_MON_OPT_TYPES)
+            sz += 2 + 3;
 
-	if (what == am_nodedown
-	    && (nmp->opts & ERTS_NODES_MON_OPT_DOWN_REASON)) {
-	    if (is_not_immed(reason))
-		sz += size_object(reason);
-	    sz += 2 + 3;
-	}
+        if (what == am_nodedown
+                && (nmp->opts & ERTS_NODES_MON_OPT_DOWN_REASON)) {
+            if (is_not_immed(reason))
+                sz += size_object(reason);
+            sz += 2 + 3;
+        }
 
-	sz += 4;
+        sz += 4;
     }
@@ -3071,9 +3202,9 @@
 send_nodes_mon_msg(Process *rp,
-		   ErtsProcLocks *rp_locksp,
-		   ErtsNodesMonitor *nmp,
-		   Eterm node,
-		   Eterm what,
-		   Eterm type,
-		   Eterm reason,
-		   Uint sz)
+        ErtsProcLocks *rp_locksp,
+        ErtsNodesMonitor *nmp,
+        Eterm node,
+        Eterm what,
+        Eterm type,
+        Eterm reason,
+        Uint sz)
 {
@@ -3088,5 +3219,5 @@
     if (!nmp->opts) {
-	msg = TUPLE2(hp, what, node);
+        msg = TUPLE2(hp, what, node);
 #ifdef DEBUG
-	hp += 3;
+        hp += 3;
 #endif
@@ -3094,34 +3225,34 @@
     else {
-	Eterm tup;
-	Eterm info = NIL;
+        Eterm tup;
+        Eterm info = NIL;
 
-	if (nmp->opts & (ERTS_NODES_MON_OPT_TYPE_VISIBLE
-			 | ERTS_NODES_MON_OPT_TYPE_HIDDEN)) {
+        if (nmp->opts & (ERTS_NODES_MON_OPT_TYPE_VISIBLE
+                | ERTS_NODES_MON_OPT_TYPE_HIDDEN)) {
+
+            tup = TUPLE2(hp, am_node_type, type);
+            hp += 3;
+            info = CONS(hp, tup, info);
+            hp += 2;
+        }
 
-	    tup = TUPLE2(hp, am_node_type, type);
-	    hp += 3;
-	    info = CONS(hp, tup, info);
-	    hp += 2;
-	}
-
-	if (what == am_nodedown
-	    && (nmp->opts & ERTS_NODES_MON_OPT_DOWN_REASON)) {
-	    Eterm rsn_cpy;
-	    
-	    if (is_immed(reason))
-		rsn_cpy = reason;
-	    else {
-		Eterm rsn_sz = size_object(reason);
-		rsn_cpy = copy_struct(reason, rsn_sz, &hp, ohp);
-	    }
-
-	    tup = TUPLE2(hp, am_nodedown_reason, rsn_cpy);
-	    hp += 3;
-	    info = CONS(hp, tup, info);
-	    hp += 2;
-	}
+        if (what == am_nodedown
+                && (nmp->opts & ERTS_NODES_MON_OPT_DOWN_REASON)) {
+            Eterm rsn_cpy;
+
+            if (is_immed(reason))
+                rsn_cpy = reason;
+            else {
+                Eterm rsn_sz = size_object(reason);
+                rsn_cpy = copy_struct(reason, rsn_sz, &hp, ohp);
+            }
+
+            tup = TUPLE2(hp, am_nodedown_reason, rsn_cpy);
+            hp += 3;
+            info = CONS(hp, tup, info);
+            hp += 2;
+        }
 
-	msg = TUPLE3(hp, what, node, info);
+        msg = TUPLE3(hp, what, node, info);
 #ifdef DEBUG
-	hp += 4;
+        hp += 4;
 #endif
@@ -3132,5 +3263,5 @@
 #ifdef USE_VM_PROBES
-		       , NIL
+               , NIL
 #endif
-		       );
+               );
 }
@@ -3164,4 +3295,4 @@
     ERTS_SMP_LC_ASSERT(!c_p
-		       || (erts_proc_lc_my_proc_locks(c_p)
-			   == ERTS_PROC_LOCK_MAIN));
+            || (erts_proc_lc_my_proc_locks(c_p)
+                    == ERTS_PROC_LOCK_MAIN));
     erts_smp_mtx_lock(&nodes_monitors_mtx);
@@ -3169,54 +3300,54 @@
     for (nmp = nodes_monitors; nmp; nmp = nmp->next) {
-	int i;
-	Uint16 no;
-	Uint sz;
-
-	ASSERT(nmp->proc != NULL);
-
-	if (!nmp->opts) {
-	    if (type != am_visible)
-		continue;
-	}
-	else {
-	    switch (type) {
-	    case am_hidden:
-		if (!(nmp->opts & ERTS_NODES_MON_OPT_TYPE_HIDDEN))
-		    continue;
-		break;
-	    case am_visible:
-		if ((nmp->opts & ERTS_NODES_MON_OPT_TYPES)
-		    && !(nmp->opts & ERTS_NODES_MON_OPT_TYPE_VISIBLE))
-		    continue;
-		break;
-	    default:
-		erl_exit(ERTS_ABORT_EXIT, "Bad node type found\n");
-	    }
-	}
-
-	if (rp != nmp->proc) {
-	    if (rp) {
-		if (rp == c_p)
-		    rp_locks &= ~ERTS_PROC_LOCK_MAIN;
-		erts_smp_proc_unlock(rp, rp_locks);
-	    }
-
-	    rp = nmp->proc;
-	    rp_locks = 0;
-	    if (rp == c_p)
-		rp_locks |= ERTS_PROC_LOCK_MAIN;
-	}
-
-	ASSERT(rp);
-
-	sz = nodes_mon_msg_sz(nmp, what, reason);
-
-	for (i = 0, no = nmp->no; i < no; i++)
-	    send_nodes_mon_msg(rp,
-			       &rp_locks,
-			       nmp,
-			       node,
-			       what,
-			       type,
-			       reason,
-			       sz);
+        int i;
+        Uint16 no;
+        Uint sz;
+
+        ASSERT(nmp->proc != NULL);
+
+        if (!nmp->opts) {
+            if (type != am_visible)
+                continue;
+        }
+        else {
+            switch (type) {
+                case am_hidden:
+                    if (!(nmp->opts & ERTS_NODES_MON_OPT_TYPE_HIDDEN))
+                        continue;
+                    break;
+                case am_visible:
+                    if ((nmp->opts & ERTS_NODES_MON_OPT_TYPES)
+                            && !(nmp->opts & ERTS_NODES_MON_OPT_TYPE_VISIBLE))
+                        continue;
+                    break;
+                default:
+                    erl_exit(ERTS_ABORT_EXIT, "Bad node type found\n");
+            }
+        }
+
+        if (rp != nmp->proc) {
+            if (rp) {
+                if (rp == c_p)
+                    rp_locks &= ~ERTS_PROC_LOCK_MAIN;
+                erts_smp_proc_unlock(rp, rp_locks);
+            }
+
+            rp = nmp->proc;
+            rp_locks = 0;
+            if (rp == c_p)
+                rp_locks |= ERTS_PROC_LOCK_MAIN;
+        }
+
+        ASSERT(rp);
+
+        sz = nodes_mon_msg_sz(nmp, what, reason);
+
+        for (i = 0, no = nmp->no; i < no; i++)
+            send_nodes_mon_msg(rp,
+                    &rp_locks,
+                    nmp,
+                    node,
+                    what,
+                    type,
+                    reason,
+                    sz);
     }
@@ -3224,5 +3355,5 @@
     if (rp) {
-	if (rp == c_p)
-	    rp_locks &= ~ERTS_PROC_LOCK_MAIN;
-	erts_smp_proc_unlock(rp, rp_locks);
+        if (rp == c_p)
+            rp_locks &= ~ERTS_PROC_LOCK_MAIN;
+        erts_smp_proc_unlock(rp, rp_locks);
     }
@@ -3244,72 +3375,72 @@
     if (xnmp) {
-	ASSERT(!xnmp->prev || xnmp->prev->proc != c_p);
+        ASSERT(!xnmp->prev || xnmp->prev->proc != c_p);
 
-	while (1) {
-	    ASSERT(xnmp->proc == c_p);
-	    if (xnmp->opts == opts)
-		break;
-	    if (!xnmp->next || xnmp->next->proc != c_p)
-		break;
-	    xnmp = xnmp->next;
-	}
-	ASSERT(xnmp);
-	ASSERT(xnmp->proc == c_p);
-	ASSERT(xnmp->opts == opts
-	       || !xnmp->next
-	       || xnmp->next->proc != c_p);
-
-	if (xnmp->opts != opts)
-	    goto alloc_new;
-	else {
-	    res = am_true;
-	    no = xnmp->no++;
-	    if (!xnmp->no) {
-		/*
-		 * 'no' wrapped; transfer all prevous monitors to new
-		 * element (which will be the next element in the list)
-		 * and set this to one...
-		 */
-		xnmp->no = 1;
-		goto alloc_new;
-	    }
-	}
+        while (1) {
+            ASSERT(xnmp->proc == c_p);
+            if (xnmp->opts == opts)
+                break;
+            if (!xnmp->next || xnmp->next->proc != c_p)
+                break;
+            xnmp = xnmp->next;
+        }
+        ASSERT(xnmp);
+        ASSERT(xnmp->proc == c_p);
+        ASSERT(xnmp->opts == opts
+                || !xnmp->next
+                || xnmp->next->proc != c_p);
+
+        if (xnmp->opts != opts)
+            goto alloc_new;
+        else {
+            res = am_true;
+            no = xnmp->no++;
+            if (!xnmp->no) {
+                /*
+                 * 'no' wrapped; transfer all prevous monitors to new
+                 * element (which will be the next element in the list)
+                 * and set this to one...
+                 */
+                xnmp->no = 1;
+                goto alloc_new;
+            }
+        }
     }
     else {
-    alloc_new:
-	nmp = erts_alloc(ERTS_ALC_T_NODES_MON, sizeof(ErtsNodesMonitor));
-	nmp->proc = c_p;
-	nmp->opts = opts;
-	nmp->no = no;
-
-	if (xnmp) {
-	    ASSERT(nodes_monitors);
-	    ASSERT(c_p->nodes_monitors);
-	    nmp->next = xnmp->next;
-	    nmp->prev = xnmp;
-	    xnmp->next = nmp;
-	    if (nmp->next) {
-		ASSERT(nodes_monitors_end != xnmp);
-		ASSERT(nmp->next->prev == xnmp);
-		nmp->next->prev = nmp;
-	    }
-	    else {
-		ASSERT(nodes_monitors_end == xnmp);
-		nodes_monitors_end = nmp;
-	    }
-	}
-	else {
-	    ASSERT(!c_p->nodes_monitors);
-	    c_p->nodes_monitors = nmp;
-	    nmp->next = NULL;
-	    nmp->prev = nodes_monitors_end;
-	    if (nodes_monitors_end) {
-		ASSERT(nodes_monitors);
-		nodes_monitors_end->next = nmp;
-	    }
-	    else {
-		ASSERT(!nodes_monitors);
-		nodes_monitors = nmp;
-	    }
-	    nodes_monitors_end = nmp;
-	}
+        alloc_new:
+        nmp = erts_alloc(ERTS_ALC_T_NODES_MON, sizeof(ErtsNodesMonitor));
+        nmp->proc = c_p;
+        nmp->opts = opts;
+        nmp->no = no;
+
+        if (xnmp) {
+            ASSERT(nodes_monitors);
+            ASSERT(c_p->nodes_monitors);
+            nmp->next = xnmp->next;
+            nmp->prev = xnmp;
+            xnmp->next = nmp;
+            if (nmp->next) {
+                ASSERT(nodes_monitors_end != xnmp);
+                ASSERT(nmp->next->prev == xnmp);
+                nmp->next->prev = nmp;
+            }
+            else {
+                ASSERT(nodes_monitors_end == xnmp);
+                nodes_monitors_end = nmp;
+            }
+        }
+        else {
+            ASSERT(!c_p->nodes_monitors);
+            c_p->nodes_monitors = nmp;
+            nmp->next = NULL;
+            nmp->prev = nodes_monitors_end;
+            if (nodes_monitors_end) {
+                ASSERT(nodes_monitors);
+                nodes_monitors_end->next = nmp;
+            }
+            else {
+                ASSERT(!nodes_monitors);
+                nodes_monitors = nmp;
+            }
+            nodes_monitors_end = nmp;
+        }
     }
@@ -3331,31 +3462,31 @@
     while (nmp && nmp->proc == c_p) {
-	if (!all && nmp->opts != opts)
-	    nmp = nmp->next;
-	else { /* if (all || nmp->opts == opts) */
-	    ErtsNodesMonitor *free_nmp;
-	    res = am_true;
-	    if (nmp->prev) {
-		ASSERT(nodes_monitors != nmp);
-		nmp->prev->next = nmp->next;
-	    }
-	    else {
-		ASSERT(nodes_monitors == nmp);
-		nodes_monitors = nmp->next;
-	    }
-	    if (nmp->next) {
-		ASSERT(nodes_monitors_end != nmp);
-		nmp->next->prev = nmp->prev;
-	    }
-	    else {
-		ASSERT(nodes_monitors_end == nmp);
-		nodes_monitors_end = nmp->prev;
-	    }
-	    free_nmp = nmp;
-	    nmp = nmp->next;
-	    if (c_p->nodes_monitors == free_nmp)
-		c_p->nodes_monitors = nmp && nmp->proc == c_p ? nmp : NULL;
-	    erts_free(ERTS_ALC_T_NODES_MON, free_nmp);
-	}
+        if (!all && nmp->opts != opts)
+            nmp = nmp->next;
+        else { /* if (all || nmp->opts == opts) */
+            ErtsNodesMonitor *free_nmp;
+            res = am_true;
+            if (nmp->prev) {
+                ASSERT(nodes_monitors != nmp);
+                nmp->prev->next = nmp->next;
+            }
+            else {
+                ASSERT(nodes_monitors == nmp);
+                nodes_monitors = nmp->next;
+            }
+            if (nmp->next) {
+                ASSERT(nodes_monitors_end != nmp);
+                nmp->next->prev = nmp->prev;
+            }
+            else {
+                ASSERT(nodes_monitors_end == nmp);
+                nodes_monitors_end = nmp->prev;
+            }
+            free_nmp = nmp;
+            nmp = nmp->next;
+            if (c_p->nodes_monitors == free_nmp)
+                c_p->nodes_monitors = nmp && nmp->proc == c_p ? nmp : NULL;
+            erts_free(ERTS_ALC_T_NODES_MON, free_nmp);
+        }
     }
-    
+
     ASSERT(!all || !c_p->nodes_monitors);
@@ -3369,5 +3500,5 @@
     if (c_p) {
-	ErtsProcLocks might_unlock = locks & ~ERTS_PROC_LOCK_MAIN;
-	if (might_unlock)
-	    erts_proc_lc_might_unlock(c_p, might_unlock);
+        ErtsProcLocks might_unlock = locks & ~ERTS_PROC_LOCK_MAIN;
+        if (might_unlock)
+            erts_proc_lc_might_unlock(c_p, might_unlock);
     }
@@ -3375,8 +3506,8 @@
     if (erts_smp_mtx_trylock(&nodes_monitors_mtx) == EBUSY) {
-	ErtsProcLocks unlock_locks = locks & ~ERTS_PROC_LOCK_MAIN;
-	if (c_p && unlock_locks)
-	    erts_smp_proc_unlock(c_p, unlock_locks);
-	erts_smp_mtx_lock(&nodes_monitors_mtx);
-	if (c_p && unlock_locks)
-	    erts_smp_proc_lock(c_p, unlock_locks);
+        ErtsProcLocks unlock_locks = locks & ~ERTS_PROC_LOCK_MAIN;
+        if (c_p && unlock_locks)
+            erts_smp_proc_unlock(c_p, unlock_locks);
+        erts_smp_mtx_lock(&nodes_monitors_mtx);
+        if (c_p && unlock_locks)
+            erts_smp_proc_lock(c_p, unlock_locks);
     }
@@ -3397,53 +3528,53 @@
     if (on != am_true && on != am_false)
-	return THE_NON_VALUE;
+        return THE_NON_VALUE;
 
     if (is_not_nil(opts_list)) {
-	int all = 0, visible = 0, hidden = 0;
+        int all = 0, visible = 0, hidden = 0;
 
-	while (is_list(opts_list)) {
-	    Eterm *cp = list_val(opts_list);
-	    Eterm opt = CAR(cp);
-	    opts_list = CDR(cp);
-	    if (opt == am_nodedown_reason)
-		opts |= ERTS_NODES_MON_OPT_DOWN_REASON;
-	    else if (is_tuple(opt)) {
-		Eterm* tp = tuple_val(opt);
-		if (arityval(tp[0]) != 2)
-		    return THE_NON_VALUE;
-		switch (tp[1]) {
-		case am_node_type:
-		    switch (tp[2]) {
-		    case am_visible:
-			if (hidden || all)
-			    return THE_NON_VALUE;
-			opts |= ERTS_NODES_MON_OPT_TYPE_VISIBLE;
-			visible = 1;
-			break;
-		    case am_hidden:
-			if (visible || all)
-			    return THE_NON_VALUE;
-			opts |= ERTS_NODES_MON_OPT_TYPE_HIDDEN;
-			hidden = 1;
-			break;
-		    case am_all:
-			if (visible || hidden)
-			    return THE_NON_VALUE;
-			opts |= ERTS_NODES_MON_OPT_TYPES;
-			all = 1;
-			break;
-		    default:
-			return THE_NON_VALUE;
-		    }
-		    break;
-		default:
-		    return THE_NON_VALUE;
-		}
-	    }
-	    else {
-		return THE_NON_VALUE;
-	    }
-	}
+        while (is_list(opts_list)) {
+            Eterm *cp = list_val(opts_list);
+            Eterm opt = CAR(cp);
+            opts_list = CDR(cp);
+            if (opt == am_nodedown_reason)
+                opts |= ERTS_NODES_MON_OPT_DOWN_REASON;
+            else if (is_tuple(opt)) {
+                Eterm* tp = tuple_val(opt);
+                if (arityval(tp[0]) != 2)
+                    return THE_NON_VALUE;
+                switch (tp[1]) {
+                    case am_node_type:
+                        switch (tp[2]) {
+                            case am_visible:
+                                if (hidden || all)
+                                    return THE_NON_VALUE;
+                                opts |= ERTS_NODES_MON_OPT_TYPE_VISIBLE;
+                                visible = 1;
+                                break;
+                            case am_hidden:
+                                if (visible || all)
+                                    return THE_NON_VALUE;
+                                opts |= ERTS_NODES_MON_OPT_TYPE_HIDDEN;
+                                hidden = 1;
+                                break;
+                            case am_all:
+                                if (visible || hidden)
+                                    return THE_NON_VALUE;
+                                opts |= ERTS_NODES_MON_OPT_TYPES;
+                                all = 1;
+                                break;
+                            default:
+                                return THE_NON_VALUE;
+                        }
+                        break;
+                            default:
+                                return THE_NON_VALUE;
+                }
+            }
+            else {
+                return THE_NON_VALUE;
+            }
+        }
 
-	if (is_not_nil(opts_list))
-	    return THE_NON_VALUE;
+        if (is_not_nil(opts_list))
+            return THE_NON_VALUE;
     }
@@ -3453,5 +3584,5 @@
     if (on == am_true)
-	res = insert_nodes_monitor(c_p, opts);
+        res = insert_nodes_monitor(c_p, opts);
     else
-	res = remove_nodes_monitors(c_p, opts, 0);
+        res = remove_nodes_monitors(c_p, opts, 0);
 
@@ -3487,3 +3618,3 @@
 
- bld_result:
+    bld_result:
     res = NIL;
@@ -3491,27 +3622,27 @@
     for (nmp = nodes_monitors_end; nmp; nmp = nmp->prev) {
-	Uint16 i;
-	for (i = 0; i < nmp->no; i++) {
-	    Eterm olist = NIL;
-	    if (nmp->opts & ERTS_NODES_MON_OPT_TYPES) {
-		Eterm type;
-		switch (nmp->opts & ERTS_NODES_MON_OPT_TYPES) {
-		case ERTS_NODES_MON_OPT_TYPES:        type = am_all;     break;
-		case ERTS_NODES_MON_OPT_TYPE_VISIBLE: type = am_visible; break;
-		case ERTS_NODES_MON_OPT_TYPE_HIDDEN:  type = am_hidden;  break;
-		default: erl_exit(ERTS_ABORT_EXIT, "Bad node type found\n");
-		}
-		olist = erts_bld_cons(hpp, szp, 
-				      erts_bld_tuple(hpp, szp, 2,
-						     am_node_type,
-						     type),
-				      olist);
-	    }
-	    if (nmp->opts & ERTS_NODES_MON_OPT_DOWN_REASON)
-		olist = erts_bld_cons(hpp, szp, am_nodedown_reason, olist);
-	    res = erts_bld_cons(hpp, szp,
-				erts_bld_tuple(hpp, szp, 2,
-					       nmp->proc->id,
-					       olist),
-				res);
-	}
+        Uint16 i;
+        for (i = 0; i < nmp->no; i++) {
+            Eterm olist = NIL;
+            if (nmp->opts & ERTS_NODES_MON_OPT_TYPES) {
+                Eterm type;
+                switch (nmp->opts & ERTS_NODES_MON_OPT_TYPES) {
+                    case ERTS_NODES_MON_OPT_TYPES:        type = am_all;     break;
+                    case ERTS_NODES_MON_OPT_TYPE_VISIBLE: type = am_visible; break;
+                    case ERTS_NODES_MON_OPT_TYPE_HIDDEN:  type = am_hidden;  break;
+                    default: erl_exit(ERTS_ABORT_EXIT, "Bad node type found\n");
+                }
+                olist = erts_bld_cons(hpp, szp, 
+                        erts_bld_tuple(hpp, szp, 2,
+                                am_node_type,
+                                type),
+                                olist);
+            }
+            if (nmp->opts & ERTS_NODES_MON_OPT_DOWN_REASON)
+                olist = erts_bld_cons(hpp, szp, am_nodedown_reason, olist);
+            res = erts_bld_cons(hpp, szp,
+                    erts_bld_tuple(hpp, szp, 2,
+                            nmp->proc->id,
+                            olist),
+                            res);
+        }
     }
@@ -3519,9 +3650,9 @@
     if (!hpp) {
-	hp = HAlloc(c_p, sz);
+        hp = HAlloc(c_p, sz);
 #ifdef DEBUG
-	hend = hp + sz;
+        hend = hp + sz;
 #endif
-	hpp = &hp;
-	szp = NULL;
-	goto bld_result;
+        hpp = &hp;
+        szp = NULL;
+        goto bld_result;
     }
diff -ruN1 otp/erts/emulator/beam/dist.h erlang2/erts/emulator/beam/dist.h
--- otp/erts/emulator/beam/dist.h	2013-06-25 16:35:13.399123162 +0200
+++ erlang2/erts/emulator/beam/dist.h	2013-06-25 16:36:07.531124502 +0200
@@ -274,2 +274,3 @@
 extern int erts_dsig_send_msg(ErtsDSigData *, Eterm, Eterm);
+extern int erts_dsig_send_msg_reliable(ErtsDSigData *, Eterm, Eterm, int);
 extern int erts_dsig_send_exit_tt(ErtsDSigData *, Eterm, Eterm, Eterm, Eterm);
@@ -277,2 +278,3 @@
 extern int erts_dsig_send_reg_msg(ErtsDSigData *, Eterm, Eterm);
+extern int erts_dsig_send_reg_msg_reliable(ErtsDSigData *, Eterm, Eterm, int);
 extern int erts_dsig_send_group_leader(ErtsDSigData *, Eterm, Eterm);
diff -ruN1 otp/erts/emulator/beam/erl_bif_unixtime.c erlang2/erts/emulator/beam/erl_bif_unixtime.c
--- otp/erts/emulator/beam/erl_bif_unixtime.c	1970-01-01 01:00:00.000000000 +0100
+++ erlang2/erts/emulator/beam/erl_bif_unixtime.c	2013-06-25 16:36:07.535124502 +0200
@@ -0,0 +1,110 @@
+#include <time.h>
+#include <sys/time.h>
+#include <sys/times.h>
+#include <sys/resource.h>
+
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#include "sys.h"
+#include "global.h"
+#include "bif.h"
+#include "erl_term.h"
+#include "big.h"
+
+BIF_RETTYPE unixtime_clock_0(BIF_ALIST_0)
+{
+    clock_t res;
+    Eterm* hp;
+
+    res = clock();
+    hp = HAlloc(BIF_P, BIG_UINT_HEAP_SIZE);
+    *hp = make_pos_bignum_header(1);
+    BIG_DIGIT(hp, 0) = res;
+    
+    BIF_RET(make_big(hp));
+}
+
+BIF_RETTYPE unixtime_gettimeofday_0(BIF_ALIST_0)
+{
+    struct timeval res;
+    Eterm* hp;
+    Eterm* hp2;
+    Eterm* hp3;
+    
+    gettimeofday(&res, NULL);
+    hp = HAlloc(BIF_P, 3);
+    hp2 = HAlloc(BIF_P, BIG_UINT_HEAP_SIZE);
+    *hp2 = make_pos_bignum_header(1);
+    BIG_DIGIT(hp2, 0) = res.tv_sec;
+    hp3 = HAlloc(BIF_P, BIG_UINT_HEAP_SIZE);
+    *hp3 = make_pos_bignum_header(1);
+    BIG_DIGIT(hp3, 0) = res.tv_usec;
+    
+    BIF_RET(TUPLE2(hp, make_big(hp2), make_big(hp3)));
+}
+
+BIF_RETTYPE unixtime_clock_gettime_0(BIF_ALIST_0)
+{
+    struct timespec res;
+    Eterm* hp;
+    Eterm* hp2;
+    Eterm* hp3;
+    
+#ifdef __mips__
+    clock_gettime(CLOCK_MONOTONIC, &res);
+#else
+    clock_gettime(CLOCK_MONOTONIC_RAW, &res);
+#endif
+    hp = HAlloc(BIF_P, 3);
+    hp2 = HAlloc(BIF_P, BIG_UINT_HEAP_SIZE);
+    *hp2 = make_pos_bignum_header(1);
+    BIG_DIGIT(hp2, 0) = res.tv_sec;
+    hp3 = HAlloc(BIF_P, BIG_UINT_HEAP_SIZE);
+    *hp3 = make_pos_bignum_header(1);
+    BIG_DIGIT(hp3, 0) = res.tv_nsec;
+    
+    BIF_RET(TUPLE2(hp, make_big(hp2), make_big(hp3)));
+}
+
+BIF_RETTYPE unixtime_times_0(BIF_ALIST_0)
+{
+    struct tms res;
+    Eterm* hp;
+    Eterm* hp2;
+    Eterm* hp3;
+    
+    times(&res);
+    hp = HAlloc(BIF_P, 3);
+    hp2 = HAlloc(BIF_P, BIG_UINT_HEAP_SIZE);
+    *hp2 = make_pos_bignum_header(1);
+    BIG_DIGIT(hp2, 0) = res.tms_utime;
+    hp3 = HAlloc(BIF_P, BIG_UINT_HEAP_SIZE);
+    *hp3 = make_pos_bignum_header(1);
+    BIG_DIGIT(hp3, 0) = res.tms_stime;
+    
+    BIF_RET(TUPLE2(hp, make_big(hp2), make_big(hp3)));
+}
+
+BIF_RETTYPE unixtime_getrusage_0(BIF_ALIST_0)
+{
+    struct rusage usg;
+    Eterm* hp;
+    Eterm* hp2;
+    Eterm* hp3;
+    uint64_t t1, t2;
+    
+    getrusage(RUSAGE_SELF, &usg);
+    t1 = usg.ru_utime.tv_sec * 1000000 + usg.ru_utime.tv_usec;
+    t2 = usg.ru_stime.tv_sec * 1000000 + usg.ru_stime.tv_usec;
+    hp = HAlloc(BIF_P, 3);
+    hp2 = HAlloc(BIF_P, BIG_UINT_HEAP_SIZE);
+    *hp2 = make_pos_bignum_header(1);
+    BIG_DIGIT(hp2, 0) = t1;
+    hp3 = HAlloc(BIF_P, BIG_UINT_HEAP_SIZE);
+    *hp3 = make_pos_bignum_header(1);
+    BIG_DIGIT(hp3, 0) = t2;
+    
+    BIF_RET(TUPLE2(hp, make_big(hp2), make_big(hp3)));
+}
diff -ruN1 otp/erts/emulator/beam/erl_init.c erlang2/erts/emulator/beam/erl_init.c
--- otp/erts/emulator/beam/erl_init.c	2013-06-25 16:35:13.407123162 +0200
+++ erlang2/erts/emulator/beam/erl_init.c	2013-06-25 16:36:07.539124502 +0200
@@ -248,2 +248,3 @@
     init_register_table();
+    init_pexport_table();
     init_message();
diff -ruN1 otp/erts/emulator/beam/erl_process.c erlang2/erts/emulator/beam/erl_process.c
--- otp/erts/emulator/beam/erl_process.c	2013-06-25 16:35:13.411123162 +0200
+++ erlang2/erts/emulator/beam/erl_process.c	2013-06-25 16:36:07.543124502 +0200
@@ -44,2 +44,3 @@
 #include "dtrace-wrapper.h"
+#include "pexport.h"
 
@@ -8896,4 +8897,8 @@
     if (p->reg) {
-	(void) erts_unregister_name(p, ERTS_PROC_LOCK_MAIN, NULL, THE_NON_VALUE);
-	ASSERT(!p->reg);
+        (void) erts_unexport_process_by_name(p, ERTS_PROC_LOCK_MAIN, NULL, p->reg->name);
+        (void) erts_unregister_name(p, ERTS_PROC_LOCK_MAIN, NULL, THE_NON_VALUE);
+        ASSERT(!p->reg);
+    }
+    else {
+        (void) erts_unexport_process_by_pid(p, ERTS_PROC_LOCK_MAIN, NULL, p->id);
     }
diff -ruN1 otp/erts/emulator/beam/external.c erlang2/erts/emulator/beam/external.c
--- otp/erts/emulator/beam/external.c	2013-06-25 16:35:13.419123162 +0200
+++ erlang2/erts/emulator/beam/external.c	2013-06-25 16:36:07.551124502 +0200
@@ -488,2 +488,10 @@
 
+void erts_encode_dist_reliability(byte **ext, int reliable)
+{
+    byte *ep = *ext;
+    if (reliable) *ep++ = 1;
+    else *ep++ = 0;
+    *ext = ep;
+}
+
 void erts_encode_ext(Eterm term, byte **ext)
@@ -567,4 +575,5 @@
 			  "** Got message from incompatible erlang on "
-			  "channel %d\n",
-			  dist_entry_channel_no(dep));
+			  "channel %d: version %d\n",
+			  dist_entry_channel_no(dep),
+              (unsigned short) ep[0]);
 	else
@@ -590,4 +599,6 @@
     if (ep[1] != DIST_HEADER) {
-	if (edep->flags & ERTS_DIST_EXT_DFLAG_HDR)
-	    ERTS_EXT_HDR_FAIL;
+	if (edep->flags & ERTS_DIST_EXT_DFLAG_HDR) {
+        erts_fprintf(stderr, "1\n");
+        ERTS_EXT_HDR_FAIL;
+    }
 	edep->attab.size = 0;
@@ -599,4 +610,6 @@
 
-	if (!(edep->flags & ERTS_DIST_EXT_DFLAG_HDR))
-	    ERTS_EXT_HDR_FAIL;
+	if (!(edep->flags & ERTS_DIST_EXT_DFLAG_HDR)) {
+        erts_fprintf(stderr, "2\n");
+        ERTS_EXT_HDR_FAIL;
+    }
 
@@ -609,4 +622,6 @@
 	no_atoms = (int) get_int8(ep);
-	if (no_atoms < 0 || ERTS_ATOM_CACHE_SIZE < no_atoms)
-	    ERTS_EXT_HDR_FAIL;
+	if (no_atoms < 0 || ERTS_ATOM_CACHE_SIZE < no_atoms) {
+        erts_fprintf(stderr, "3\n");
+        ERTS_EXT_HDR_FAIL;
+    }
 	ep++;
@@ -699,4 +714,6 @@
 		    atom = cache->in_arr[cix];
-		    if (!is_atom(atom))
-			ERTS_EXT_HDR_FAIL;
+		    if (!is_atom(atom)) {
+                erts_fprintf(stderr, "4\n");
+                ERTS_EXT_HDR_FAIL;
+            }
 		    edep->attab.atom[tix] = atom;
diff -ruN1 otp/erts/emulator/beam/external.h erlang2/erts/emulator/beam/external.h
--- otp/erts/emulator/beam/external.h	2013-06-25 16:35:13.419123162 +0200
+++ erlang2/erts/emulator/beam/external.h	2013-06-25 16:36:07.551124502 +0200
@@ -160,2 +160,3 @@
 void erts_encode_dist_ext(Eterm, byte **, Uint32, ErtsAtomCacheMap *);
+void erts_encode_dist_reliability(byte **, int);
 
diff -ruN1 otp/erts/emulator/beam/global.h erlang2/erts/emulator/beam/global.h
--- otp/erts/emulator/beam/global.h	2013-06-25 16:35:13.419123162 +0200
+++ erlang2/erts/emulator/beam/global.h	2013-06-25 16:36:07.551124502 +0200
@@ -768,2 +768,3 @@
 Eterm erl_send(Process *p, Eterm to, Eterm msg);
+Eterm erl_send_reliable(Process *p, Eterm to, Eterm msg, int reliable);
 
diff -ruN1 otp/erts/emulator/beam/io.c erlang2/erts/emulator/beam/io.c
--- otp/erts/emulator/beam/io.c	2013-06-25 16:35:13.419123162 +0200
+++ erlang2/erts/emulator/beam/io.c	2013-06-25 16:36:07.551124502 +0200
@@ -2999,2 +2999,4 @@
     init_b2t_states(&b2t);
+    
+    //erts_fprintf(stderr, "DEBUG: To %T\n", to);
 
@@ -3528,2 +3530,3 @@
     if (prt->status & ERTS_PORT_SFLG_DISTRIBUTION) {
+        erts_fprintf(stderr, "DEBUG: status %d and lengths %d - %d, on port connected to %T\n", prt->status & ERTS_PORT_SFLG_DISTRIBUTION, hlen, len, prt->connected);
 	if (len == 0)
diff -ruN1 otp/erts/emulator/beam/pexport.c erlang2/erts/emulator/beam/pexport.c
--- otp/erts/emulator/beam/pexport.c	1970-01-01 01:00:00.000000000 +0100
+++ erlang2/erts/emulator/beam/pexport.c	2013-06-25 16:36:07.551124502 +0200
@@ -0,0 +1,379 @@
+/*
+ * %CopyrightBegin%
+ *
+ * Copyright Ericsson AB 1996-2010. All Rights Reserved.
+ *
+ * The contents of this file are subject to the Erlang Public License,
+ * Version 1.1, (the "License"); you may not use this file except in
+ * compliance with the License. You should have received a copy of the
+ * Erlang Public License along with this software. If not, it can be
+ * retrieved online at http://www.erlang.org/.
+ *
+ * Software distributed under the License is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
+ * the License for the specific language governing rights and limitations
+ * under the License.
+ *
+ * %CopyrightEnd%
+ */
+
+/*
+ * Manage registered processes.
+ */
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#include "sys.h"
+#include "erl_vm.h"
+#include "global.h"
+#include "hash.h"
+#include "atom.h"
+#include "pexport.h"
+#include "register.h"
+
+static Hash process_exp;
+
+#define PEXP_HASH_SIZE 10
+
+#define EXP_HASH(term) ((HashValue) atom_val(term))
+
+static erts_smp_rwmtx_t exptab_rwmtx;
+
+#define exp_try_read_lock()		erts_smp_rwmtx_tryrlock(&exptab_rwmtx)
+#define exp_try_write_lock()		erts_smp_rwmtx_tryrwlock(&exptab_rwmtx)
+#define exp_read_lock()			erts_smp_rwmtx_rlock(&exptab_rwmtx)
+#define exp_write_lock()		erts_smp_rwmtx_rwlock(&exptab_rwmtx)
+#define exp_read_unlock()		erts_smp_rwmtx_runlock(&exptab_rwmtx)
+#define exp_write_unlock()		erts_smp_rwmtx_rwunlock(&exptab_rwmtx)
+
+#ifdef ERTS_SMP
+static ERTS_INLINE void
+exp_safe_read_lock(Process *c_p, ErtsProcLocks *c_p_locks)
+{
+    if (*c_p_locks) {
+	ASSERT(c_p);
+	ASSERT(c_p_locks);
+	ASSERT(*c_p_locks);
+
+	if (exp_try_read_lock() != EBUSY) {
+#ifdef ERTS_ENABLE_LOCK_CHECK
+	    erts_proc_lc_might_unlock(c_p, *c_p_locks);
+#endif
+	    return;
+	}
+
+	/* Release process locks in order to avoid deadlock */
+	erts_smp_proc_unlock(c_p, *c_p_locks);
+	*c_p_locks = 0;
+    }
+
+    exp_read_lock();
+}
+
+static ERTS_INLINE void
+exp_safe_write_lock(Process *c_p, ErtsProcLocks *c_p_locks)
+{
+    if (*c_p_locks) {
+	ASSERT(c_p);
+	ASSERT(c_p_locks);
+	ASSERT(*c_p_locks);
+
+	if (exp_try_write_lock() != EBUSY) {
+#ifdef ERTS_ENABLE_LOCK_CHECK
+	    erts_proc_lc_might_unlock(c_p, *c_p_locks);
+#endif
+	    return;
+	}
+
+	/* Release process locks in order to avoid deadlock */
+	erts_smp_proc_unlock(c_p, *c_p_locks);
+	*c_p_locks = 0;
+    }
+
+    exp_write_lock();
+}
+
+static ERTS_INLINE int
+is_proc_alive(Process *p)
+{
+    int res;
+    erts_pix_lock_t *pixlck = ERTS_PID2PIXLOCK(p->id);
+    erts_pix_lock(pixlck);
+    res = !p->is_exiting;
+    erts_pix_unlock(pixlck);
+    return res;
+}
+
+#endif
+
+static HashValue exp_hash(ExpProc* obj)
+{
+    if (obj->name == am_undefined) return EXP_HASH(obj->pid);
+    else return EXP_HASH(obj->name);
+}
+
+static int exp_cmp(ExpProc *tmpl, ExpProc *obj) {
+    return tmpl->name != obj->name && tmpl->pid != obj->pid;
+}
+
+static ExpProc* exp_alloc(ExpProc *tmpl)
+{
+    ExpProc* obj = (ExpProc*) erts_alloc(ERTS_ALC_T_REG_PROC, sizeof(ExpProc));
+    if (!obj) {
+	erl_exit(1, "Can't allocate %d bytes of memory\n", sizeof(ExpProc));
+    }
+    obj->name = tmpl->name;
+    obj->pid = tmpl->pid;
+    return obj;
+}
+
+static void exp_free(ExpProc *obj)
+{
+    erts_free(ERTS_ALC_T_REG_PROC, (void*) obj);
+}
+
+void init_pexport_table(void)
+{
+    HashFunctions f;
+    erts_smp_rwmtx_opt_t rwmtx_opt = ERTS_SMP_RWMTX_OPT_DEFAULT_INITER;
+    rwmtx_opt.type = ERTS_SMP_RWMTX_TYPE_FREQUENT_READ;
+    rwmtx_opt.lived = ERTS_SMP_RWMTX_LONG_LIVED;
+
+    erts_smp_rwmtx_init_opt(&exptab_rwmtx, &rwmtx_opt, "exp_tab");
+
+    f.hash = (H_FUN) exp_hash;
+    f.cmp  = (HCMP_FUN) exp_cmp;
+    f.alloc = (HALLOC_FUN) exp_alloc;
+    f.free = (HFREE_FUN) exp_free;
+
+    hash_init(ERTS_ALC_T_REG_TABLE, &process_exp, "process_exp",
+	      PEXP_HASH_SIZE, f);
+}
+
+int erts_export_process_by_name(Process *c_p, Eterm name)
+{
+    ExpProc r;
+    ERTS_SMP_CHK_HAVE_ONLY_MAIN_PROC_LOCK(c_p);
+
+    if ((is_not_atom(name) || name == am_undefined)) {
+        return 0;
+    }
+    
+    r.name = name;
+    r.pid = am_undefined;
+    
+    exp_write_lock();
+    hash_put(&process_exp, (void*) &r);
+    exp_write_unlock();
+    
+    return 1;
+}
+
+int erts_export_process_by_pid(Process *c_p, Eterm id)
+{
+    ExpProc r;
+    ERTS_SMP_CHK_HAVE_ONLY_MAIN_PROC_LOCK(c_p);
+
+    if (id == am_undefined) {
+        return 0;
+    }
+    
+    r.pid = id;
+    r.name = am_undefined;
+
+    exp_write_lock();
+    hash_put(&process_exp, (void*) &r);
+    exp_write_unlock();
+    
+    return 1;
+}
+
+int erts_unexport_process_by_pid(Process *c_p,
+			 ErtsProcLocks c_p_locks,
+			 Port *c_prt,
+			 Eterm id)
+{
+    int res = 0;
+    ExpProc r;
+
+    r.pid = id;
+    r.name = am_undefined;
+
+    exp_write_lock();
+    if (hash_get(&process_exp, (void*) &r) != NULL) {
+        hash_erase(&process_exp, (void*) &r);
+        res = 1;
+    }
+    else {
+        res = 0;
+    }
+    exp_write_unlock();
+
+    return res;
+}
+
+int erts_unexport_process_by_name(Process *c_p,
+             ErtsProcLocks c_p_locks,
+             Port *c_prt,
+             Eterm name)
+{
+    int res = 0;
+    ExpProc r;
+
+    r.pid = am_undefined;
+    r.name = name;
+
+    exp_write_lock();
+    if (hash_get(&process_exp, (void*) &r) != NULL) {
+        hash_erase(&process_exp, (void*) &r);
+        res = 1;
+    }
+    else {
+        res = 0;
+    }
+    exp_write_unlock();
+
+    return res;
+}
+
+int process_exp_size(void)
+{
+    int size;
+    int lock = !ERTS_IS_CRASH_DUMPING;
+    if (lock)
+	exp_read_lock();
+    size = process_exp.size;
+    if (lock)
+	exp_read_unlock();
+    return size;
+}
+
+int erts_is_exported_by_name(Process *c_p, Eterm name)
+{
+    int res = 0;
+    ExpProc r;
+
+    r.pid = am_undefined;
+    r.name = name;
+
+    exp_read_lock();
+    if (hash_get(&process_exp, (void*) &r) != NULL) {
+        res = 1;
+    }
+    else {
+        res = 0;
+    }
+    exp_read_unlock();
+
+    return res;
+}
+
+int erts_is_exported_by_pid(Process *c_p, Eterm id)
+{
+    int res = 0;
+    ExpProc r;
+
+    r.pid = id;
+    r.name = am_undefined;
+
+    exp_read_lock();
+    if (hash_get(&process_exp, (void*) &r) != NULL) {
+        res = 1;
+    }
+    else {
+        res = 0;
+    }
+    exp_read_unlock();
+
+    return res;
+}
+
+Eterm exported_noproc(Eterm* buf) {
+    int i;
+    Eterm res;
+    HashBucket **bucket;
+
+    bucket = process_exp.bucket;
+
+     /* scan through again and make the list */ 
+    res = NIL;
+
+    for (i = 0; i < process_exp.size; i++) {
+    HashBucket *b = bucket[i];
+    while (b != NULL) {
+        ExpProc *exp = (ExpProc *) b;
+        if (exp->name == am_undefined)
+            res = CONS(buf, exp->pid, res);
+        else
+            res = CONS(buf, exp->name, res);
+        buf += 2;
+        b = b->next;
+    }
+    }
+
+    exp_read_unlock();
+
+    return res;
+}
+
+/**********************************************************************/
+
+#include "bif.h"
+
+BIF_RETTYPE exported_0(BIF_ALIST_0)
+{
+    int i;
+    Eterm res;
+    Uint need;
+    Eterm* hp;
+    HashBucket **bucket;
+#ifdef ERTS_SMP
+    ErtsProcLocks proc_locks = ERTS_PROC_LOCK_MAIN;
+
+    ERTS_SMP_CHK_HAVE_ONLY_MAIN_PROC_LOCK(BIF_P);
+    exp_safe_read_lock(BIF_P, &proc_locks);
+    if (!proc_locks)
+	erts_smp_proc_lock(BIF_P, ERTS_PROC_LOCK_MAIN);
+#endif
+
+    bucket = process_exp.bucket;
+
+    /* work out how much heap we need & maybe garb, by scanning through
+       the registered process table */
+    need = 0;
+    for (i = 0; i < process_exp.size; i++) {
+	HashBucket *b = bucket[i];
+	while (b != NULL) {
+	    need += 2;
+	    b = b->next;
+	}
+    }
+
+    if (need == 0) {
+	exp_read_unlock();
+	BIF_RET(NIL);
+    }
+
+    hp = HAlloc(BIF_P, need);
+     
+     /* scan through again and make the list */ 
+    res = NIL;
+
+    for (i = 0; i < process_exp.size; i++) {
+	HashBucket *b = bucket[i];
+	while (b != NULL) {
+	    ExpProc *exp = (ExpProc *) b;
+	    if (exp->name == am_undefined)
+	        res = CONS(hp, exp->pid, res);
+	    else
+	        res = CONS(hp, exp->name, res);
+	    hp += 2;
+	    b = b->next;
+	}
+    }
+
+    exp_read_unlock();
+
+    BIF_RET(res);
+}
diff -ruN1 otp/erts/emulator/beam/pexport.h erlang2/erts/emulator/beam/pexport.h
--- otp/erts/emulator/beam/pexport.h	1970-01-01 01:00:00.000000000 +0100
+++ erlang2/erts/emulator/beam/pexport.h	2013-06-25 16:36:07.551124502 +0200
@@ -0,0 +1,56 @@
+/*
+ * %CopyrightBegin%
+ * 
+ * Copyright Ericsson AB 1996-2009. All Rights Reserved.
+ * 
+ * The contents of this file are subject to the Erlang Public License,
+ * Version 1.1, (the "License"); you may not use this file except in
+ * compliance with the License. You should have received a copy of the
+ * Erlang Public License along with this software. If not, it can be
+ * retrieved online at http://www.erlang.org/.
+ * 
+ * Software distributed under the License is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
+ * the License for the specific language governing rights and limitations
+ * under the License.
+ * 
+ * %CopyrightEnd%
+ */
+
+/*
+** Exported processes
+*/
+
+#ifndef __PEXPORT_H__
+#define __PEXPORT_H__
+
+#ifndef __SYS_H__
+#include "sys.h"
+#endif
+
+#ifndef __HASH_H__
+#include "hash.h"
+#endif
+
+#ifndef __PROCESS_H__
+#include "erl_process.h"
+#endif
+
+typedef struct exp_proc
+{
+    HashBucket bucket;  /* MUST BE LOCATED AT TOP OF STRUCT!!! */
+    Eterm pid;
+    Eterm name;
+} ExpProc;
+
+int process_exp_size(void);
+void init_pexport_table(void);
+int erts_export_process_by_name(Process *, Eterm);
+int erts_export_process_by_pid(Process *, Eterm);
+int erts_unexport_process_by_name(Process *, ErtsProcLocks, struct port *, Eterm);
+int erts_unexport_process_by_pid(Process *, ErtsProcLocks, struct port *, Eterm);
+int erts_is_exported_by_name(Process *, Eterm);
+int erts_is_exported_by_pid(Process *, Eterm);
+Eterm exported_noproc(Eterm*);
+
+#endif
diff -ruN1 otp/erts/emulator/beam/register.c erlang2/erts/emulator/beam/register.c
--- otp/erts/emulator/beam/register.c	2013-06-25 16:35:13.423123163 +0200
+++ erlang2/erts/emulator/beam/register.c	2013-06-25 16:36:07.551124502 +0200
@@ -179,3 +179,3 @@
 
-    if (is_not_atom(name) || name == am_undefined)
+    if (is_not_atom(name) || name == am_undefined || name == am_all)
 	return res;
diff -ruN1 otp/erts/emulator/Makefile.in erlang2/erts/emulator/Makefile.in
--- otp/erts/emulator/Makefile.in	2013-06-25 16:35:13.395123162 +0200
+++ erlang2/erts/emulator/Makefile.in	2013-06-25 16:36:07.527124502 +0200
@@ -753,3 +753,5 @@
 	$(OBJDIR)/erl_bif_binary.o      $(OBJDIR)/erl_ao_firstfit_alloc.o \
-	$(OBJDIR)/erl_thr_queue.o	$(OBJDIR)/erl_sched_spec_pre_alloc.o
+	$(OBJDIR)/erl_thr_queue.o	$(OBJDIR)/erl_sched_spec_pre_alloc.o \
+	$(OBJDIR)/pexport.o \
+	$(OBJDIR)/erl_bif_unixtime.o
 
Binary files otp/erts/preloaded/ebin/erlang.beam and erlang2/erts/preloaded/ebin/erlang.beam differ
Binary files otp/erts/preloaded/ebin/erl_prim_loader.beam and erlang2/erts/preloaded/ebin/erl_prim_loader.beam differ
Binary files otp/erts/preloaded/ebin/init.beam and erlang2/erts/preloaded/ebin/init.beam differ
Binary files otp/erts/preloaded/ebin/otp_ring0.beam and erlang2/erts/preloaded/ebin/otp_ring0.beam differ
Binary files otp/erts/preloaded/ebin/prim_file.beam and erlang2/erts/preloaded/ebin/prim_file.beam differ
Binary files otp/erts/preloaded/ebin/prim_inet.beam and erlang2/erts/preloaded/ebin/prim_inet.beam differ
Binary files otp/erts/preloaded/ebin/prim_zip.beam and erlang2/erts/preloaded/ebin/prim_zip.beam differ
Binary files otp/erts/preloaded/ebin/zlib.beam and erlang2/erts/preloaded/ebin/zlib.beam differ
diff -ruN1 otp/erts/preloaded/src/erlang.erl erlang2/erts/preloaded/src/erlang.erl
--- otp/erts/preloaded/src/erlang.erl	2013-06-25 16:35:13.451123163 +0200
+++ erlang2/erts/preloaded/src/erlang.erl	2013-06-25 16:36:07.615124504 +0200
@@ -25,2 +25,3 @@
 -export([spawn/1, spawn_link/1, spawn/2, spawn_link/2]).
+-export([spawn_cond/3, spawn_cond/5]).
 -export([yield/0]).
@@ -91,3 +92,3 @@
 
--spec spawn(Node, Fun) -> pid() when
+-spec spawn(Node, Fun) -> pid() | ok when
       Node :: node(),
@@ -103,2 +104,19 @@
 
+%% ELIoT
+
+-spec spawn_cond(Node, Fun, Cond) -> pid() | ok when
+      Node :: node(),
+      Fun :: function(),
+      Cond :: function().
+spawn_cond(N, F, C) when N =:= node() ->
+    spawn(F);
+spawn_cond(N, F, C) when is_function(F), is_function(C) ->
+    spawn_cond(N, erlang, apply, [F, []], C);
+spawn_cond(N, {M,F}=MF, C) when is_atom(M), is_atom(F), is_function(C) ->
+    spawn_cond(N, erlang, apply, [MF, []], C);
+spawn_cond(N, F, C) ->
+    erlang:error(badarg, [N, F, C]).
+
+%% End ELIoT
+
 -spec spawn_link(Fun) -> pid() when
@@ -179,3 +197,3 @@
 
--spec spawn(Node, Module, Function, Args) -> pid() when
+-spec spawn(Node, Module, Function, Args) -> pid() | ok when
       Node :: node(),
@@ -194,3 +212,3 @@
     case catch gen_server:call({net_kernel,N},
-			       {spawn,M,F,A,group_leader()},
+                   {spawn,M,F,A,group_leader(),N},
 			       infinity) of
@@ -198,2 +216,4 @@
 	    Pid;
+	ok when N == all ->
+        ok;
 	Error ->
@@ -209,2 +229,39 @@
 
+%% ELIoT
+
+-spec spawn_cond(Node, Module, Function, Args, Cond) -> pid() | ok when
+      Node :: node(),
+      Module :: module(),
+      Function :: atom(),
+      Args :: [term()],
+      Cond :: function().
+spawn_cond(N,M,F,A,C) when N =:= node(), is_atom(M), is_atom(F), is_list(A), is_function(C) ->
+    spawn(M,F,A);
+spawn_cond(N,M,F,A, C) when is_atom(N), is_atom(M), is_atom(F), is_function(C) ->
+    case is_well_formed_list(A) of
+    true ->
+        ok;
+    false ->
+        erlang:error(badarg, [N, M, F, A])
+    end,
+    case catch gen_server:call({net_kernel,N},
+                   {spawn_cond,M,F,A,C,group_leader(),N},
+                   infinity) of
+    Pid when is_pid(Pid) ->
+        Pid;
+    ok when N == all ->
+        ok;
+    Error ->
+        case remote_spawn_error(Error, {no_link, N, M, F, A, C, []}) of
+        {fault, Fault} ->
+            erlang:error(Fault, [N, M, F, A, C]);
+        Pid ->
+            Pid
+        end
+    end;
+spawn_cond(N,M,F,A,C) ->
+    erlang:error(badarg, [N, M, F, A, C]).
+
+%% End ELIoT
+
 -spec spawn_link(Node, Module, Function, Args) -> pid() when
diff -ruN1 otp/erts/start_scripts/Makefile erlang2/erts/start_scripts/Makefile
--- otp/erts/start_scripts/Makefile	2013-06-25 16:35:13.451123163 +0200
+++ erlang2/erts/start_scripts/Makefile	2013-06-25 16:36:07.619124504 +0200
@@ -28,3 +28,3 @@
 LIBPATH= $(ERL_TOP)/lib
-SCRIPT_PATH = -I$(LIBPATH)/kernel/ebin -I$(LIBPATH)/stdlib/ebin -I$(LIBPATH)/sasl/ebin
+SCRIPT_PATH = -I$(LIBPATH)/kernel/ebin -I$(LIBPATH)/stdlib/ebin -I$(LIBPATH)/sasl/ebin -I$(LIBPATH)/udp_dist/ebin
 BOOTSTRAP_LIBPATH=$(BOOTSTRAP_TOP)/lib
@@ -36,3 +36,5 @@
 	$(SS_ROOT)/start_sasl.boot \
-	$(SS_ROOT)/start_sasl.script
+	$(SS_ROOT)/start_sasl.script \
+	$(SS_ROOT)/start_udp.script \
+	$(SS_ROOT)/start_udp.boot
 
@@ -41,3 +43,4 @@
 	$(SS_ROOT)/start_sasl.rel \
-	$(SS_ROOT)/start_all_example.rel
+	$(SS_ROOT)/start_all_example.rel \
+	$(SS_ROOT)/start_udp.rel
 
@@ -59,2 +62,3 @@
 -include $(LIBPATH)/inets/vsn.mk
+-include $(LIBPATH)/udp_dist/vsn.mk
 
@@ -84,2 +88,8 @@
 
+$(SS_ROOT)/start_udp.script \
+$(SS_ROOT)/start_udp.boot:	$(SS_ROOT)/start_udp.rel
+	$(INSTALL_DIR) $(SS_TMP)
+	( cd $(SS_TMP) && \
+	$(ERLC) $(SASL_FLAGS) $(SCRIPT_PATH) +no_warn_sasl -o $(SS_ROOT) $< )
+
 $(SS_ROOT)/start_clean.rel: $(SS_ROOT)/start_clean.rel.src \
@@ -106,2 +116,14 @@
 
+$(SS_ROOT)/start_udp.rel:	$(SS_ROOT)/start_udp.rel.src \
+			../vsn.mk \
+			$(LIBPATH)/kernel/vsn.mk \
+			$(LIBPATH)/stdlib/vsn.mk \
+			$(LIBPATH)/udp_dist/vsn.mk
+	sed -e 's;%SYS_VSN%;$(SYSTEM_VSN);' \
+            -e 's;%ERTS_VSN%;$(VSN);' \
+            -e 's;%KERNEL_VSN%;$(KERNEL_VSN);' \
+            -e 's;%STDLIB_VSN%;$(STDLIB_VSN);' \
+            -e 's;%UDP_VSN%;$(UDP_VSN);' \
+          $(SS_ROOT)/start_udp.rel.src > $(SS_ROOT)/start_udp.rel
+
 $(SS_ROOT)/start_all_example.rel:	$(SS_ROOT)/start_all_example.rel.src \
@@ -137,2 +159,7 @@
 
+$(ERL_TOP)/bin/start_udp.script:
+	$(INSTALL_DIR) $(SS_TMP)
+	( cd $(SS_TMP) && \
+	  $(ERLC) $(SCRIPT_PATH) +no_warn_sasl +otp_build -o $@ $(SS_ROOT)/start_udp.rel )
+
 $(ERL_TOP)/bin/start_clean.script:
diff -ruN1 otp/erts/start_scripts/start_udp.rel.src erlang2/erts/start_scripts/start_udp.rel.src
--- otp/erts/start_scripts/start_udp.rel.src	1970-01-01 01:00:00.000000000 +0100
+++ erlang2/erts/start_scripts/start_udp.rel.src	2013-06-25 16:36:07.619124504 +0200
@@ -0,0 +1,22 @@
+%%
+%% %CopyrightBegin%
+%% 
+%% Copyright Ericsson AB 1996-2009. All Rights Reserved.
+%% 
+%% The contents of this file are subject to the Erlang Public License,
+%% Version 1.1, (the "License"); you may not use this file except in
+%% compliance with the License. You should have received a copy of the
+%% Erlang Public License along with this software. If not, it can be
+%% retrieved online at http://www.erlang.org/.
+%% 
+%% Software distributed under the License is distributed on an "AS IS"
+%% basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
+%% the License for the specific language governing rights and limitations
+%% under the License.
+%% 
+%% %CopyrightEnd%
+%%
+{release, {"OTP  APN 181 01","%SYS_VSN%"}, {erts, "%ERTS_VSN%"},
+ [{udp_dist, "%UDP_VSN%"},
+  {kernel,"%KERNEL_VSN%"},
+  {stdlib,"%STDLIB_VSN%"}]}.
diff -ruN1 otp/lib/appmon/src/appmon.erl erlang2/lib/appmon/src/appmon.erl
--- otp/lib/appmon/src/appmon.erl	2013-06-25 16:34:55.103122709 +0200
+++ erlang2/lib/appmon/src/appmon.erl	2013-06-25 16:36:07.627124504 +0200
@@ -132,8 +132,9 @@
 check_node(Node) ->
-    case rpc:call(Node, code, which, [appmon]) of
-	File when is_list(File) ->
-	    true;
-	_ -> % non_existing (| cover_compiled)
-	    false
-    end.
+    false.
+%    case rpc:call(Node, code, which, [appmon]) of
+%   File when is_list(File) ->
+%       true;
+%   _ -> % non_existing (| cover_compiled)
+%       false
+%    end.
 
diff -ruN1 otp/lib/kernel/src/dist_util.erl erlang2/lib/kernel/src/dist_util.erl
--- otp/lib/kernel/src/dist_util.erl	2013-06-25 16:35:13.591123167 +0200
+++ erlang2/lib/kernel/src/dist_util.erl	2013-06-25 16:36:08.047124515 +0200
@@ -102,2 +102,3 @@
 
+%% No atom cache for all: when broadcasting the cache cannot be synchronized!
 make_this_flags(RequestType, OtherNode) ->
@@ -116,8 +117,8 @@
 	 ?DFLAG_UNICODE_IO bor
-	 ?DFLAG_DIST_HDR_ATOM_CACHE bor
+	 %?DFLAG_DIST_HDR_ATOM_CACHE bor
 	 ?DFLAG_SMALL_ATOM_TAGS).
 
-handshake_other_started(#hs_data{request_type=ReqType}=HSData0) ->
-    {PreOtherFlags,Node,Version} = recv_name(HSData0),
+handshake_other_started(#hs_data{request_type=ReqType,other_node=Node}=HSData0) ->
     PreThisFlags = make_this_flags(ReqType, Node),
+    PreOtherFlags = make_this_flags(ReqType, node()),
     {ThisFlags, OtherFlags} = adjust_flags(PreThisFlags,
@@ -126,4 +127,2 @@
 			     other_flags=OtherFlags,
-			     other_version=Version,
-			     other_node=Node,
 			     other_started=true},
@@ -131,11 +130,3 @@
     is_allowed(HSData),
-    ?debug({"MD5 connection from ~p (V~p)~n",
-	    [Node, HSData#hs_data.other_version]}),
     mark_pending(HSData),
-    {MyCookie,HisCookie} = get_cookies(Node),
-    ChallengeA = gen_challenge(),
-    send_challenge(HSData, ChallengeA),
-    reset_timer(HSData#hs_data.timer),
-    ChallengeB = recv_challenge_reply(HSData, ChallengeA, MyCookie),
-    send_challenge_ack(HSData, gen_digest(ChallengeB, HisCookie)),
     ?debug({dist_util, self(), accept_connection, Node}),
@@ -151,3 +142,2 @@
 	false when Allowed =/= [] ->
-	    send_status(HSData, not_allowed),
 	    error_msg("** Connection attempt from "
@@ -185,3 +175,2 @@
 		true ->
-		    send_status(HSData, not_allowed),
 		    Dir = "from",
@@ -210,3 +199,2 @@
 	ok ->
-	    send_status(HSData, ok),
 	    reset_timer(HSData#hs_data.timer);
@@ -214,3 +202,2 @@
 	ok_pending ->
-	    send_status(HSData, ok_simultaneous),
 	    reset_timer(HSData#hs_data.timer);
@@ -218,3 +205,2 @@
 	nok_pending ->
-	    send_status(HSData, nok),
 	    ?shutdown(Node);
@@ -222,7 +208,2 @@
 	up_pending ->
-	    %% Check if connection is still alive, no
-	    %% implies that the connection is no longer pending
-	    %% due to simultaneous connect
-	    do_alive(HSData),
-
 	    %% This can happen if the other node goes down,
@@ -313,6 +294,4 @@
     PreThisFlags = make_this_flags(ReqType, Node),
+    PreOtherFlags = make_this_flags(ReqType, node()),
     HSData = PreHSData#hs_data{this_flags=PreThisFlags},
-    send_name(HSData),
-    recv_status(HSData),
-    {PreOtherFlags,ChallengeA} = recv_challenge(HSData),
     {ThisFlags,OtherFlags} = adjust_flags(PreThisFlags, PreOtherFlags),
@@ -322,8 +301,2 @@
     check_dflag_xnc(NewHSData),
-    MyChallenge = gen_challenge(),
-    {MyCookie,HisCookie} = get_cookies(Node),
-    send_challenge_reply(NewHSData,MyChallenge,
-			 gen_digest(ChallengeA,HisCookie)),
-    reset_timer(NewHSData#hs_data.timer),
-    recv_challenge_ack(NewHSData, MyChallenge, MyCookie),
     connection(NewHSData).
@@ -345,5 +318,8 @@
 	    Address = FAddress(Socket,Node),
+	    ?trace("DEBUG: Got address~n", []),
 	    mark_nodeup(HSData,Address),
+	    ?trace("DEBUG: Node marked as up~n", []),
 	    case FPostNodeup(Socket) of
 		ok ->
+            ?trace("DEBUG: Node postup~n", []),
 		    con_loop(HSData#hs_data.kernel_pid, 
@@ -416,4 +392,7 @@
 		{'EXIT', Other} ->
+            ?trace("DEBUG: Nodes ~p~n", [nodes()]),
+            ?trace("DEBUG: Error ~p~n", [Other]),
 		    exit(Other);
 		_Else ->
+            ?trace("DEBUG: Ok~n", []),
 		    ok
@@ -454,6 +433,9 @@
 	{tcp_closed, Socket} ->
+        ?trace("DEBUG: Tcp closed~n", []),
 	    ?shutdown2(Node, connection_closed);
 	{Kernel, disconnect} ->
+        ?trace("DEBUG: Kernel disconnect~n", []),
 	    ?shutdown2(Node, disconnected);
 	{Kernel, aux_tick} ->
+        ?trace("DEBUG: Kernel aux tick~n", []),
 	    case MFGetstat(Socket) of
@@ -467,2 +449,3 @@
 	{Kernel, tick} ->
+        ?trace("DEBUG: Kernel tick~n", []),
 	    case send_tick(Socket, Tick, Type, 
@@ -482,2 +465,3 @@
 	{From, get_status} ->
+        ?trace("DEBUG: Get status~n", []),
 	    case MFGetstat(Socket) of
@@ -701,2 +685,3 @@
 	  ticked = Ticked} = Tick,
+	io:format(standard_error, "TICK: ~p, ~p, ~p, ~p~n", [T0, Read, Write, Ticked]),
     T = T0 + 1,
diff -ruN1 otp/lib/kernel/src/global.erl erlang2/lib/kernel/src/global.erl
--- otp/lib/kernel/src/global.erl	2013-06-25 16:35:13.591123167 +0200
+++ erlang2/lib/kernel/src/global.erl	2013-06-25 16:36:08.051124515 +0200
@@ -160,6 +160,10 @@
 start() -> 
-    gen_server:start({local, global_name_server}, ?MODULE, [], []).
+    Res = gen_server:start({local, global_name_server}, ?MODULE, [], []),
+    erlang:export(global_name_server),
+    Res.
 
 start_link() -> 
-    gen_server:start_link({local, global_name_server}, ?MODULE, [], []).
+    Res = gen_server:start_link({local, global_name_server}, ?MODULE, [], []),
+    erlang:export(global_name_server),
+    Res.
 
@@ -1513,3 +1517,5 @@
 start_the_locker(DoTrace) ->
-    spawn_link(fun() -> init_the_locker(DoTrace) end).
+    Pid = spawn_link(fun() -> init_the_locker(DoTrace) end),
+    erlang:export(Pid),
+    Pid.
 
@@ -2176,3 +2182,5 @@
 start_the_registrar() ->
-    spawn_link(fun() -> loop_the_registrar() end).
+    Pid = spawn_link(fun() -> loop_the_registrar() end),
+    erlang:export(Pid),
+    Pid.
 
diff -ruN1 otp/lib/kernel/src/kernel.erl erlang2/lib/kernel/src/kernel.erl
--- otp/lib/kernel/src/kernel.erl	2013-06-25 16:34:55.495122719 +0200
+++ erlang2/lib/kernel/src/kernel.erl	2013-06-25 16:36:08.055124515 +0200
@@ -136,4 +136,4 @@
 	    {ok, {SupFlags,
-		  [Rpc, Global, InetDb | DistAC] ++ 
-		  [NetSup, Glo_grp, File, Code, 
+		  [InetDb | DistAC] ++ 
+          [Global, NetSup, File, Code, 
 		   StdError, User, Config, SafeSupervisor] ++ Timer}}
diff -ruN1 otp/lib/kernel/src/net_kernel.erl erlang2/lib/kernel/src/net_kernel.erl
--- otp/lib/kernel/src/net_kernel.erl	2013-06-25 16:35:13.595123167 +0200
+++ erlang2/lib/kernel/src/net_kernel.erl	2013-06-25 16:36:08.055124515 +0200
@@ -344,2 +344,3 @@
 	{ok, Pid} ->
+        erlang:export(net_kernel),
 	    {ok, Pid};
@@ -431,2 +432,30 @@
 %%
+%% The spawn/4 BIF plus node ends up here.
+%%
+handle_call({spawn,M,F,A,Gleader,N},{From,Tag},State) when is_pid(From) ->
+    do_spawn([no_link,{From,Tag},M,F,A,Gleader,N],[],State);
+
+%%
+%% The spawn_cond/5 BIF ends up here.
+%%
+handle_call({spawn_cond,M,F,A,C,Gleader},{From,Tag},State) when is_pid(From) ->
+    case C() of
+        true ->
+            do_spawn([no_link,{From,Tag},M,F,A,Gleader],[],State);
+        false ->
+            ok
+    end;
+
+%%
+%% The spawn_cond/5 BIF plus node ends up here.
+%%
+handle_call({spawn_cond,M,F,A,C,Gleader,N},{From,Tag},State) when is_pid(From) ->
+    case C() of
+        true ->
+            do_spawn([no_link,{From,Tag},M,F,A,Gleader,N],[],State);
+        false ->
+            ok
+    end;
+
+%%
 %% The spawn_link/4 BIF ends up here.
@@ -1044,3 +1073,3 @@
 	    ?MODULE:ticker_loop(Kernel, NewTick)
-    after Tick ->
+    after infinity ->
 	    Kernel ! tick,
@@ -1104,3 +1133,6 @@
     [_,From|_] = SpawnFuncArgs,
-    case catch spawn_opt(?MODULE, spawn_func, SpawnFuncArgs, SpawnOpts) of
+    [N|T] = lists:reverse(SpawnFuncArgs),
+    case catch spawn_opt(?MODULE, spawn_func, lists:reverse(T), SpawnOpts) of
+    _ when N == all ->
+        {noreply, State};
 	{'EXIT', {Reason,_}} ->
diff -ruN1 otp/lib/Makefile erlang2/lib/Makefile
--- otp/lib/Makefile	2013-06-25 16:35:13.451123163 +0200
+++ erlang2/lib/Makefile	2013-06-25 16:36:07.623124504 +0200
@@ -22,3 +22,3 @@
 ERTS_SUB_DIRECTORIES = stdlib sasl kernel compiler
-OTHER_SUB_DIRECTORIES = tools test_server common_test runtime_tools
+OTHER_SUB_DIRECTORIES = tools test_server common_test runtime_tools udp_dist
 ifdef BUILD_ALL
diff -ruN1 otp/lib/stdlib/src/erl_parse.yrl erlang2/lib/stdlib/src/erl_parse.yrl
--- otp/lib/stdlib/src/erl_parse.yrl	2013-06-25 16:35:13.755123171 +0200
+++ erlang2/lib/stdlib/src/erl_parse.yrl	2013-06-25 16:36:08.387124523 +0200
@@ -63,3 +63,3 @@
 '<<' '>>'
-'!' '=' '::' '..' '...'
+'!' '~' '=' '::' '..' '...'
 'spec' 'callback' % helper
@@ -223,2 +223,3 @@
 expr_100 -> expr_150 '!' expr_100 : ?mkop2('$1', '$2', '$3').
+expr_100 -> expr_150 '~' expr_100 : ?mkop2('$1', '$2', '$3').
 expr_100 -> expr_150 : '$1'.
@@ -1036,2 +1037,3 @@
 inop_prec('!') -> {150,100,100};
+inop_prec('~') -> {150,100,100};
 inop_prec('orelse') -> {160,150,150};
diff -ruN1 otp/lib/stdlib/src/gen.erl erlang2/lib/stdlib/src/gen.erl
--- otp/lib/stdlib/src/gen.erl	2013-06-25 16:35:13.759123171 +0200
+++ erlang2/lib/stdlib/src/gen.erl	2013-06-25 16:36:08.391124523 +0200
@@ -219,17 +219,29 @@
 		  [noconnect]),
-	    receive
-		{Mref, Reply} ->
-		    erlang:demonitor(Mref, [flush]),
-		    {ok, Reply};
-		{'DOWN', Mref, _, _, noconnection} ->
-		    exit({nodedown, Node});
-		{'DOWN', Mref, _, _, Reason} ->
-		    exit(Reason)
-	    after Timeout ->
-		    erlang:demonitor(Mref),
-		    receive
-			{'DOWN', Mref, _, _, _} -> true
-		    after 0 -> true
-		    end,
-		    exit(timeout)
+	    case Node of
+            all ->
+                {ok, ok};
+            _ ->
+                receive
+                {_, _, {Mref, Reply}} ->
+                    erlang:demonitor(Mref, [flush]),
+                    {ok, Reply};
+                {Mref, Reply} ->
+                    erlang:demonitor(Mref, [flush]),
+                    {ok, Reply};
+                {_, _, {'DOWN', Mref, _, _, noconnection}} ->
+                    exit({nodedown, Node});
+                {'DOWN', Mref, _, _, noconnection} ->
+                    exit({nodedown, Node});
+                {_, _, {'DOWN', Mref, _, _, Reason}} ->
+                    exit(Reason);
+                {'DOWN', Mref, _, _, Reason} ->
+                    exit(Reason)
+                after Timeout ->
+                    erlang:demonitor(Mref),
+                    receive
+                    {'DOWN', Mref, _, _, _} -> true
+                    after 0 -> true
+                    end,
+                    exit(timeout)
+                end
 	    end
diff -ruN1 otp/lib/stdlib/src/gen_server.erl erlang2/lib/stdlib/src/gen_server.erl
--- otp/lib/stdlib/src/gen_server.erl	2013-06-25 16:35:13.759123171 +0200
+++ erlang2/lib/stdlib/src/gen_server.erl	2013-06-25 16:36:08.391124523 +0200
@@ -586,2 +586,4 @@
 
+handle_msg({_, _, {'$gen_call', From, Msg}}, Parent, Name, State, Mod) ->
+    handle_msg({'$gen_call', From, Msg}, Parent, Name, State, Mod);
 handle_msg({'$gen_call', From, Msg}, Parent, Name, State, Mod) ->
diff -ruN1 otp/lib/stdlib/src/proc_lib.erl erlang2/lib/stdlib/src/proc_lib.erl
--- otp/lib/stdlib/src/proc_lib.erl	2013-06-25 16:35:13.759123171 +0200
+++ erlang2/lib/stdlib/src/proc_lib.erl	2013-06-25 16:36:08.391124523 +0200
@@ -28,2 +28,3 @@
          spawn_opt/2, spawn_opt/3, spawn_opt/4, spawn_opt/5,
+         spawn_cond/3, spawn_cond/5,
 	 start/3, start/4, start/5, start_link/3, start_link/4, start_link/5,
@@ -90,3 +91,3 @@
 
--spec spawn(Node, Fun) -> pid() when
+-spec spawn(Node, Fun) -> pid() | ok when
       Node :: node(),
@@ -99,3 +100,17 @@
 
--spec spawn(Node, Module, Function, Args) -> pid() when
+%% ELIoT
+
+-spec spawn_cond(Node, Fun, Cond) -> pid() | ok when
+      Node :: node(),
+      Fun :: function(),
+      Cond :: function().
+
+spawn_cond(Node, F, C) when is_function(F), is_function(C) ->
+    Parent = get_my_name(),
+    Ancestors = get_ancestors(),
+    erlang:spawn_cond(Node, ?MODULE, init_p, [Parent,Ancestors,F,C]).
+
+%% End ELIoT
+
+-spec spawn(Node, Module, Function, Args) -> pid() | ok when
       Node :: node(),
@@ -110,2 +125,18 @@
 
+%% ELIoT
+
+-spec spawn_cond(Node, Module, Function, Args, Cond) -> pid() | ok when
+      Node :: node(),
+      Module :: module(),
+      Function :: atom(),
+      Args :: [term()],
+      Cond :: function().
+
+spawn_cond(Node, M, F, A, C) when is_atom(M), is_atom(F), is_list(A), is_function(C) ->
+    Parent = get_my_name(),
+    Ancestors = get_ancestors(),
+    erlang:spawn_cond(Node, ?MODULE, init_p, [Parent,Ancestors,M,F,A,C]).
+
+%% End ELIoT
+
 -spec spawn_link(Node, Fun) -> pid() when
diff -ruN1 otp/lib/udp_dist/c_src/eliot_udp.c erlang2/lib/udp_dist/c_src/eliot_udp.c
--- otp/lib/udp_dist/c_src/eliot_udp.c	1970-01-01 01:00:00.000000000 +0100
+++ erlang2/lib/udp_dist/c_src/eliot_udp.c	2013-06-25 16:36:08.463124525 +0200
@@ -0,0 +1,891 @@
+/*
+ Copyright (c) 2012 Alessandro Sivieri <sivieri@elet.polimi.it>
+
+ This library is free software; you can redistribute it and/or
+ modify it under the terms of the GNU Library General Public
+ License version 3 as published by the Free Software Foundation.
+
+ This library is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ Library General Public License for more details.
+
+ You should have received a copy of the GNU Library General Public License
+ along with this library; see the file COPYING.LIB.  If not, write to
+ the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ Boston, MA 02110-1301, USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <math.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <errno.h>
+#include <erl_driver.h>
+
+#ifdef DEBUG
+#define FPRINTF(...) fprintf(__VA_ARGS__)
+#else
+#define FPRINTF(...)
+#endif
+
+#define PORT 4369
+#define BUF 1472
+#define HDR_SIZE 14
+#define MINIBUF 10
+#define DIST_MAGIC_RECV_TAG 131
+
+typedef enum hdr
+{
+    DATA_MSG,
+    DATA_MSG_ACK_REQUIRED,
+    TICK_MSG,
+    ACK_MSG
+} hdr_t;
+
+typedef enum state
+{
+    INIT, // 0
+    LISTEN, // 1
+    ACCEPT, // 2
+    SEND, // 3
+    RECEIVE, // 4
+    CONNECT, // 5
+    INTERMEDIATE, // 6
+    HANDSHAKED, // 7
+    BROADCAST // 8
+} state_t;
+
+typedef struct driver_data
+{
+    ErlDrvPort port;
+    struct sockaddr_in peer;
+    int clientSock;
+    state_t curstate;
+    unsigned char creation;
+    unsigned int sent;
+    unsigned int received;
+    uint32_t msg_number;
+    struct driver_data* next;
+} driver_data_t;
+
+typedef struct ip_data
+{
+    struct sockaddr_in peer;
+    struct ip_data* next;
+} ip_data_t;
+
+typedef struct int_data
+{
+    uint32_t number;
+    struct int_data *next;
+} int_data_t;
+
+typedef struct ack_data
+{
+     driver_data_t* res;
+     struct sockaddr_in peer;
+     char buf[BUF];
+     int len;
+     uint16_t msg;
+     int resend;
+     unsigned long last;
+     ErlDrvTermData caller;
+    struct ack_data* next;
+} ack_data_t;
+
+/*
+ * Driver functions
+ */
+static ErlDrvData drv_start(ErlDrvPort port, char* command);
+static void drv_stop(ErlDrvData handle);
+static void drv_ready_input(ErlDrvData handle, ErlDrvEvent event);
+static void drv_output(ErlDrvData handle, char* buf, ErlDrvSizeT len);
+static void drv_finish(void);
+static ErlDrvSSizeT drv_control(ErlDrvData handle, unsigned int cmd, char* buf, ErlDrvSizeT size, char** res,
+        ErlDrvSizeT res_size);
+/*
+ * Helper functions
+ */
+void free_entry(driver_data_t* element);
+void do_recv(driver_data_t* res);
+int do_send(driver_data_t* res, char* buf, int len, int reliable);
+int do_send2(driver_data_t* res, char* buf, int len, int reliable);
+void do_send_ack(int socket, uint16_t msg, struct sockaddr_in* client);
+void do_resend(ack_data_t* ack);
+void *do_beacon(void *data);
+int check_expired(unsigned long now, unsigned long last, int resend);
+void print_ports(void);
+void print_acks(void);
+void do_clean(driver_data_t *res);
+unsigned long get_current_time(void);
+unsigned long get_secs(void);
+void do_send_upstairs(ack_data_t *ack, driver_data_t *res);
+static void put_packet_length(char *b, int len);
+static int report_control_error(char **buffer, int buff_len, 
+                char *error_message);
+static void append_header(char *buf, int len, int rssi, unsigned int ip);
+
+static ErlDrvEntry udp_driver_entry = {
+        NULL,
+        drv_start,
+        drv_stop,
+        drv_output,
+        drv_ready_input,
+        NULL,
+        "eliot_udp",
+        drv_finish,
+        NULL,
+        drv_control,
+        NULL,
+        NULL,
+        NULL,
+        NULL,
+        NULL,
+        NULL,
+        ERL_DRV_EXTENDED_MARKER,
+        ERL_DRV_EXTENDED_MAJOR_VERSION,
+        ERL_DRV_EXTENDED_MINOR_VERSION,
+        ERL_DRV_FLAG_SOFT_BUSY,
+        NULL,
+        NULL,
+        NULL
+};
+
+static driver_data_t* head;
+static ip_data_t* peers;
+static ack_data_t* acks;
+static int counter;
+static int sock;
+static int sockBool;
+static unsigned long myaddress;
+static struct sockaddr_in sa;
+static ErlDrvMutex *mutex;
+static ErlDrvMutex *ack_mutex;
+
+/*
+ * Driver functions
+ */
+
+DRIVER_INIT(eliot_udp) {
+    head = NULL;
+    peers = NULL;
+    acks = NULL;
+    counter = 0;
+    mutex = erl_drv_mutex_create("UDP");
+    ack_mutex = erl_drv_mutex_create("UDP_acks");
+    memset(&sa, 0, sizeof(struct sockaddr_in));
+    sa.sin_family = AF_INET;
+    sa.sin_port = htons(PORT);
+    sa.sin_addr.s_addr = htonl(INADDR_ANY);
+    sock = socket(AF_INET, SOCK_DGRAM, 0);
+    if (sock < 0) {
+        FPRINTF(stderr, "DEBUG: Unable to create the socket\n");
+        return NULL;
+    }
+    if (bind(sock, (struct sockaddr*)&sa, sizeof(struct sockaddr_in)) < -1) {
+        FPRINTF(stderr, "DEBUG: Unable to bind the socket\n");
+        return NULL;
+    }
+    sockBool = 0;
+    myaddress = 0;
+    
+    FPRINTF(stderr, "DEBUG: UDP driver loaded\n");
+
+    return &udp_driver_entry;
+}
+
+static ErlDrvData drv_start(ErlDrvPort port, char* command) {
+    int res2, broadcastPermission = 1;
+    driver_data_t* res = (driver_data_t*)driver_alloc(sizeof(driver_data_t));
+    memset(&res->peer, 0, sizeof(struct sockaddr_in));
+    res->port = port;
+    res->clientSock = socket(AF_INET, SOCK_DGRAM, 0);
+    if (res->clientSock < 0) {
+        FPRINTF(stderr, "DEBUG: Unable to create a client socket\n");
+        return (ErlDrvData) NULL;
+    }
+    res2 = setsockopt(res->clientSock, SOL_SOCKET, SO_BROADCAST, (void *) &broadcastPermission, sizeof(broadcastPermission));
+    if (res2 < 0) fprintf(stderr,"DEBUG: Unable to set broadcast: %d\n", errno);
+    if (!sockBool) {
+        driver_select(port, (ErlDrvEvent)sock, ERL_DRV_READ, 1);
+        sockBool = 1;
+    }
+    res->curstate = INIT;
+    res->creation = ++counter;
+    res->sent = 0;
+    res->received = 0;
+    res->msg_number = 1;
+    res->next = head;
+    head = res;
+    FPRINTF(stderr, "DEBUG: (%ld) Driver instance created\n", (unsigned long) driver_connected(port));
+
+    return (ErlDrvData)res;
+}
+
+static void drv_stop(ErlDrvData handle) {
+    driver_data_t *iterator, *prev = NULL;
+    ack_data_t *iterator2, *prev2 = NULL, *tmp;
+    driver_data_t *res = (driver_data_t*)handle;
+    // remove pending acks
+    erl_drv_mutex_lock(ack_mutex);
+    iterator2 = acks;
+    while (iterator2 != NULL) {
+        // pointer comparison is fine here
+        if (iterator2->res == res) {
+            tmp = iterator2;
+            if (prev == NULL) {
+                acks = iterator2->next;
+            }
+            else {
+                prev2->next = iterator2->next;
+            }
+            iterator2 = iterator2->next;
+            driver_free(tmp);
+        }
+        else {
+            prev2 = iterator2;
+            iterator2 = iterator2->next;
+        }
+    }
+    erl_drv_mutex_unlock(ack_mutex);
+    // remove the resource
+    iterator = head;
+    while (iterator != NULL) {
+        if (iterator == res) {
+            break;
+        }
+        else {
+            prev = iterator;
+            iterator = iterator->next;
+        }
+    }
+    if (prev == NULL) {
+        head = res->next;
+    }
+    else {
+        prev->next = res->next;
+    }
+    free_entry(res);
+    FPRINTF(stderr, "DEBUG: Driver instance cleared\n");
+}
+
+static void drv_finish(void) {
+    driver_data_t *iterator = head, *tmp;
+    ip_data_t *iterator2 = peers, *tmp2;
+    ack_data_t *iterator3 = acks, *tmp3;
+    while (iterator != NULL) {
+        tmp = iterator;
+        iterator = tmp->next;
+        free_entry(tmp);
+    }
+    while (iterator2 != NULL) {
+        tmp2 = iterator2;
+        iterator2 = tmp2->next;
+        driver_free(tmp2);
+    }
+    while (iterator3 != NULL) {
+        tmp3 = iterator3;
+        iterator3 = tmp3->next;
+        driver_free(tmp3);
+    }
+    erl_drv_mutex_destroy(mutex);
+    erl_drv_mutex_destroy(ack_mutex);
+    close(sock);
+    fprintf(stderr, "DEBUG: UDP driver unloaded\n");
+}
+
+static void drv_ready_input(ErlDrvData handle, ErlDrvEvent event) {
+    // executed *only* by the first port, listening at 4369
+    driver_data_t* res = (driver_data_t*)handle;
+    FPRINTF(stderr, "DEBUG: (%ld) Input ready\n", (unsigned long) driver_connected(res->port));
+    do_recv(res);
+}
+
+static void drv_output(ErlDrvData handle, char* buf, ErlDrvSizeT len) {
+    driver_data_t* res = (driver_data_t*)handle;
+    ip_data_t* tmp;
+    int reliable;
+    char bufname[BUF], addr[16];
+
+    if (len == 0)
+        return;
+    if (res->curstate == HANDSHAKED) {
+        reliable = (int) buf[len - 1];
+        FPRINTF(stderr, "DEBUG: (%ld) Direct output (%d - %d)\n", (unsigned long) driver_connected(res->port), (int) buf[0], reliable);
+        if (reliable) buf[0] = DATA_MSG_ACK_REQUIRED;
+        else buf[0] = DATA_MSG;
+        do_send2(res, buf, len - 1, reliable);
+        return;
+    }
+    FPRINTF(stderr, "DEBUG: (%ld) Output: %c (%hd)\n", (unsigned long) driver_connected(res->port), (char) *buf, (unsigned short) *buf);
+    switch (*buf) {
+        case 'L':
+            res->curstate = LISTEN;
+            driver_output(res->port, "Lok", 3);
+            break;
+        case 'M':
+            memcpy(addr, buf + 1, len - 1);
+            addr[len - 1] = '\0';
+            myaddress = inet_addr(addr);
+            driver_output(res->port, "Mok", 3);
+            break;
+        case 'S':
+            res->curstate = SEND;
+            buf[0] = DATA_MSG;
+            do_send2(res, buf, len, 0);
+            break;
+        case 'R':
+            res->curstate = RECEIVE;
+            if (res->peer.sin_addr.s_addr == 0) {
+                if (peers == NULL) {
+                    FPRINTF(stderr, "DEBUG: Port in receive without a peer\n");
+                }
+                else {
+                    memcpy(&res->peer, &peers->peer, sizeof(struct sockaddr_in));
+                    tmp = peers;
+                    peers = tmp->next;
+                    driver_free(tmp);
+                    FPRINTF(stderr, "DEBUG: Found a waiting peer, assigned\n");
+                }
+            }
+            FPRINTF(stderr, "DEBUG: IP is %ld\n", (unsigned long) res->peer.sin_addr.s_addr);
+            driver_output(res->port, "Rok", 3);
+            break;
+        case 'A':
+            res->curstate = ACCEPT;
+            break;
+        case 'C':
+            // buffer does not have termination, we need to add it
+            memcpy(bufname, buf + 1, len - 1);
+            bufname[len - 1] = '\0';
+            FPRINTF(stderr, "DEBUG: Connection to %s\n", bufname);
+            res->curstate = CONNECT;
+            memset(&res->peer, 0, sizeof(struct sockaddr_in));
+            res->peer.sin_family = AF_INET;
+            res->peer.sin_port = htons(PORT);
+            res->peer.sin_addr.s_addr = inet_addr(bufname);
+            FPRINTF(stderr, "DEBUG: Address %d\n", res->peer.sin_addr.s_addr);
+            driver_output(res->port, "Cok", 3);
+            break;
+        case 'B':
+            // buffer does not have termination, we need to add it
+            memcpy(bufname, buf + 1, len - 1);
+            bufname[len - 1] = '\0';
+            FPRINTF(stderr, "DEBUG: Broadcast port set to %s\n", bufname);
+            res->curstate = BROADCAST;
+            memset(&res->peer, 0, sizeof(struct sockaddr_in));
+            res->peer.sin_family = AF_INET;
+            res->peer.sin_port = htons(PORT);
+            res->peer.sin_addr.s_addr = inet_addr(bufname);
+            driver_output(res->port, "Bok", 3);
+        default:
+            if (res->curstate == CONNECT || res->curstate == INTERMEDIATE) {
+                // someone is writing here too early: enqueue the data
+                FPRINTF(stderr, "DEBUG: Enqueuing %d bytes of data...\n", (int) len);
+                driver_enq(res->port, buf, len);
+            }
+            else {
+                FPRINTF(stderr, "DEBUG: Wrong command to UDP driver (%c, status being %d)\n", (char) *buf, res->curstate);
+            }
+            break;
+    }
+}
+
+static ErlDrvSSizeT drv_control(ErlDrvData handle, unsigned int cmd, char* buf, ErlDrvSizeT size, char** res,
+        ErlDrvSizeT res_size)
+{
+    /* Local macro to ensure large enough buffer. */
+#define ENSURE(N)               \
+       do {                     \
+           if (res_size < N) {          \
+           *res = driver_alloc(N);         \
+           }                    \
+       } while(0)
+    SysIOVec *iov;
+    int reliable, vlen, len;
+    driver_data_t *dres = (driver_data_t *)handle;
+    char tick = TICK_MSG, *buf2;
+    
+    FPRINTF(stderr, "DEBUG: Control: %c\n", (char) cmd);
+
+    switch (cmd) {
+        case 'S': {
+            ENSURE(13);
+            **res = 0;
+            put_packet_length((*res) + 1, dres->received);
+            put_packet_length((*res) + 5, dres->sent);
+            put_packet_length((*res) + 9, driver_sizeq(dres->port));
+            return 13;
+        }
+        case 'T': /* tick */
+            do_send2(dres, &tick, 1, 0);
+            ENSURE(1);
+            **res = 0;
+            return 1;
+        case 'R':
+            ENSURE(2);
+            (*res)[0] = 0;
+            (*res)[1] = dres->creation;
+            return 2;
+        case 'D':
+            dres->curstate = HANDSHAKED;
+            if (driver_sizeq(dres->port) > 0) {
+                // enqueued data to be sent away
+                iov = driver_peekq(dres->port, &vlen);
+                buf2 = (char *) iov[0].iov_base;
+                len = iov[0].iov_len;
+                reliable = (int) buf2[len - 1];
+                FPRINTF(stderr, "DEBUG: (%ld) Direct output (%d - %d)\n", (unsigned long) driver_connected(dres->port), (int) buf2[0], reliable);
+                if (reliable) buf2[0] = DATA_MSG_ACK_REQUIRED;
+                else buf2[0] = DATA_MSG;
+                do_send2(dres, buf2, len - 1, reliable);
+                driver_deq(dres->port, driver_sizeq(dres->port));
+            }
+            ENSURE(1);
+            **res = 0;
+            return 1;
+        case 'N':
+            FPRINTF(stderr, "DEBUG: Intermediate...\n");
+            dres->curstate = INTERMEDIATE;
+            ENSURE(1);
+            **res = 0;
+            return 1;
+        case 'P':
+            print_ports();
+            ENSURE(1);
+            **res = 0;
+            return 1;
+        case 'I':
+            ENSURE(5);
+            **res = 0;
+            put_packet_length((*res) + 1, dres->peer.sin_addr.s_addr);
+            return 5;
+        default:
+            return report_control_error(res, res_size, "einval");
+    }
+#undef ENSURE
+}
+
+/*
+ * Helper functions
+ */
+
+void do_send_ack(int socket, uint16_t msg, struct sockaddr_in* client) {
+    char buf[MINIBUF];
+    int size;
+    uint16_t type, number, hdr;
+    
+    buf[0] = ACK_MSG;
+    type = buf[0] & 0x000F;
+    number = msg & 0x0FFF;
+    hdr = type << 12 | number;
+    size = 2;
+    memcpy(buf, (char*) &hdr, sizeof(uint16_t));
+    size = sendto(socket, buf, sizeof(uint16_t), 0, (struct sockaddr*) client, sizeof(struct sockaddr_in));
+    if (size > 0) FPRINTF(stderr, "DEBUG: Sent ACK for message %d by %d\n", msg, client->sin_addr.s_addr);
+    else FPRINTF(stderr, "DEBUG: Unable to send ACK for message %d to %d\n", msg, client->sin_addr.s_addr);
+}
+
+void do_resend(ack_data_t* ack) {
+    int size = sendto(ack->res->clientSock, ack->buf, ack->len, 0, (struct sockaddr*) &ack->peer, sizeof(struct sockaddr_in));
+    if (size <= 0) FPRINTF(stderr, "DEBUG: Unable to resend message %d for the %d turn\n", ack->msg, ack->resend);
+    else FPRINTF(stderr, "DEBUG: Message %d resend for the %d turn\n", ack->msg, ack->resend);
+}
+
+void do_recv(driver_data_t* res) {
+    /*
+     * The buffer allocates always space for the message header, 
+     * but ignores it in the rest of the function (so it always remains free).
+     */
+    char buf[BUF + HDR_SIZE], msg_type;
+    struct sockaddr_in *client = driver_alloc(sizeof(struct sockaddr_in));
+    int size, size2;
+    socklen_t clientSize = sizeof(struct sockaddr_in);
+    int existing = 0;
+    driver_data_t* iterator = head;
+    ip_data_t *peer, *iterator2 = peers;
+    ack_data_t *iterator3, *prev = NULL;
+    uint16_t type, number, hdr;
+
+    memset(client, 0, sizeof(struct sockaddr_in));
+    erl_drv_mutex_lock(mutex);
+    FPRINTF(stderr, "DEBUG: Acquired lock for peeking\n");
+    size = recvfrom(sock, buf, BUF, MSG_PEEK, (struct sockaddr*)client, &clientSize);
+    erl_drv_mutex_unlock(mutex);
+    if (size > 0) {
+        memcpy(&hdr, buf, 2);
+        type = hdr >> 12;
+        number = hdr &0x0FFF;
+        msg_type = type;
+        FPRINTF(stderr, "DEBUG: Peeking %d bytes of type %c from %d:%d through UDP\n", size, msg_type, client->sin_addr.s_addr, client->sin_port);
+        // ignore it if it comes from us (but remove it from the socket)
+        if (myaddress == client->sin_addr.s_addr) {
+            recvfrom(sock, buf, BUF, 0, (struct sockaddr *) NULL, (socklen_t *) NULL);
+            driver_free(client);
+            return;
+        }
+        print_ports();
+        while (iterator != NULL) {
+            if (iterator->peer.sin_addr.s_addr == client->sin_addr.s_addr && (iterator->curstate == RECEIVE || iterator->curstate == INTERMEDIATE || iterator->curstate == HANDSHAKED)) {
+                existing = 1;
+                break;
+            }
+            iterator = iterator->next;
+        }
+        if (existing) {
+            if (iterator->curstate != HANDSHAKED) {
+                // we are still handshaking, BUT in a little time the message should be picked up,
+                // so for now let's just ignore it for the moment
+                driver_free(client);
+                return;
+            }
+            memset(buf, 0, BUF);
+            erl_drv_mutex_lock(mutex);
+            FPRINTF(stderr, "DEBUG: Acquired lock for receiving\n");
+            size2 = recvfrom(sock, buf, BUF, 0, (struct sockaddr *) NULL, (socklen_t *) NULL);
+            erl_drv_mutex_unlock(mutex);
+            if (size2 != size) {
+                FPRINTF(stderr, "DEBUG: Received sizes are different: %d vs. %d\n", size, size2);
+            }
+            else {
+                if (msg_type == ACK_MSG) {
+                    FPRINTF(stderr, "DEBUG: ACK for message %d\n", number);
+                    erl_drv_mutex_lock(ack_mutex);
+                    iterator3 = acks;
+                    while (iterator3 != NULL) {
+                        // pointers comparison is fine
+                        if (iterator3->res == iterator && iterator3->msg == number) {
+                            if (prev == NULL) {
+                                acks = iterator3->next;
+                            }
+                            else {
+                                prev->next = iterator3->next;
+                            }
+                            driver_free(iterator3);
+                            break;
+                        }
+                        prev = iterator3;
+                        iterator3 = iterator3->next;
+                    }
+                    erl_drv_mutex_unlock(ack_mutex);
+                }
+                else {
+                    FPRINTF(stderr, "DEBUG: Message %d\n", number);
+                    // overwrite the message internal header
+                    if (iterator->curstate == HANDSHAKED) {
+                        buf[1] = DIST_MAGIC_RECV_TAG;
+                    }
+                    else {
+                        buf[1] = 'R';
+                    }
+                    iterator->received += size2;
+                    if (msg_type == TICK_MSG) {
+                        driver_output(iterator->port, buf + 1, 0);
+                    }
+                    else {
+                        append_header(&buf[1], size2 - 1, 0, iterator->peer.sin_addr.s_addr);
+                        size2 += HDR_SIZE;
+                        driver_output(iterator->port, buf + 1, size2 - 1);
+                    }
+                    if (msg_type == DATA_MSG_ACK_REQUIRED) {
+                        client->sin_port = PORT;
+                        do_send_ack(iterator->clientSock, number, client);
+                    }
+                }
+            }
+        }
+        else {
+            while (iterator2 != NULL) {
+                if (iterator2->peer.sin_addr.s_addr == client->sin_addr.s_addr) {
+                    FPRINTF(stderr, "DEBUG: Address already waiting to be picked up, ignoring\n");
+                    driver_free(client);
+                    return;
+                }
+                iterator2 = iterator2->next;
+            }
+            FPRINTF(stderr, "DEBUG: Message for a non-existing peer, new connection for accept!\n");
+            iterator = head;
+            while (iterator != NULL) {
+                if (iterator->curstate == ACCEPT) {
+                    FPRINTF(stderr, "DEBUG: Routing done\n");
+                    peer = driver_alloc(sizeof(ip_data_t));
+                    memcpy(&peer->peer, client, sizeof(struct sockaddr_in));
+                    peer->peer.sin_port = htons(PORT);
+                    peer->next = peers;
+                    peers = peer;
+                    driver_output(iterator->port, "Aok", 3);
+                    break;
+                }
+                iterator = iterator->next;
+            }
+        }
+        driver_free(client);
+    }
+    else {
+        FPRINTF(stderr, "DEBUG: Unable to receive anything (%d - %d)\n", size, errno);
+    }
+}
+
+/* 
+ * Deprecated!!!
+ */
+int do_send(driver_data_t* res, char* buf, int len, int reliable) {
+    int size;
+
+    size = sendto(res->clientSock, buf, len, 0, (struct sockaddr*)&res->peer,
+                    sizeof(struct sockaddr_in));
+    if (size > 0) {
+        res->sent += size;
+    }
+    FPRINTF(stderr, "DEBUG: Sent message %d (%d bytes) to %d:%d through UDP (%d)\n", res->msg_number, size, res->peer.sin_addr.s_addr, res->peer.sin_port, errno);
+    res->msg_number++;
+    if (res->curstate != HANDSHAKED) driver_output(res->port, "Sok", 3);
+    
+    return size;
+}
+
+/*
+ * Message header is 2 bytes, structured as follows:
+ * 
+ * xxxxyyyy yyyyyyyy
+ * 
+ * where xxxx is the type (from the enum, max 16 types)
+ * and yyyy yyyyyyyy is the sequence number for acks (max 4096).
+ * This implies some bit shifting, of course.
+ */
+int do_send2(driver_data_t* res, char* buf, int len, int reliable) {
+    int size;
+    ack_data_t* ack;
+    uint16_t type, number, hdr;
+
+    ack = driver_alloc(sizeof(ack_data_t));
+    type = buf[0] & 0x000F;
+    number = res->msg_number & 0x0FFF;
+    hdr = type << 12 | number;
+    size = 2;
+    memcpy(ack->buf, (char*) &hdr, size);
+    FPRINTF(stderr, "DEBUG: Minibuf %d, buf %d\n", size, len);
+    memcpy(ack->buf + size, buf + 1, len - 1); // drop the initial character, already inserted at the beginning
+    size = sendto(res->clientSock, ack->buf, size + len - 1, 0, (struct sockaddr*)&res->peer,
+                    sizeof(struct sockaddr_in));
+    if (size > 0) {
+        res->sent += size;
+    }
+    FPRINTF(stderr, "DEBUG: Sent message %d (type %d, %d bytes, from %lu) to %d:%d through UDP (%d)\n", res->msg_number, ack->buf[0], size, driver_caller(res->port), res->peer.sin_addr.s_addr, res->peer.sin_port, errno);
+    if (res->curstate != HANDSHAKED) driver_output(res->port, "Sok", 3);
+    ack->resend = 1;
+    ack->len = size;
+    ack->last = get_current_time();
+    ack->msg = res->msg_number;
+    ack->res = res;
+    ack->caller = driver_caller(res->port);
+    memcpy(&ack->peer, &res->peer, sizeof(struct sockaddr_in));
+    if (ack->buf[0] == DATA_MSG_ACK_REQUIRED) {
+        erl_drv_mutex_lock(ack_mutex);
+        ack->next = acks;
+        acks = ack;
+        erl_drv_mutex_unlock(ack_mutex);
+    }
+    else {
+        driver_free(ack);
+    }
+    
+    res->msg_number++;
+    return size;
+}
+
+void do_send_upstairs(ack_data_t *ack, driver_data_t *res) {
+    ErlDrvTermData spec[] = {
+        ERL_DRV_ATOM, driver_mk_atom("nack"),
+        ERL_DRV_BUF2BINARY, (ErlDrvTermData) ack->buf, ack->len,
+        ERL_DRV_TUPLE, 2,
+    };
+    int result = driver_send_term(res->port, ack->caller, spec, sizeof(spec) / sizeof(spec[0]));
+    FPRINTF(stderr, "DEBUG: Nack sent upstairs, to %lu, with result %d\n", ack->caller, result);
+}
+
+void print_ports(void) {
+    driver_data_t *iterator = head;
+    while (iterator != NULL) {
+        FPRINTF(stderr, "PORT: connected to %d, status %d\n", iterator->peer.sin_addr.s_addr, iterator->curstate);
+        iterator = iterator->next;
+    }
+}
+
+void print_acks(void) {
+    ack_data_t *iterator = acks;
+    while (iterator != NULL) {
+        FPRINTF(stderr, "ACK: message %d waiting since %d turns\n", iterator->msg, iterator->resend);
+        iterator = iterator->next;
+    }
+}
+
+static void put_packet_length(char *b, int len)
+{      
+    unsigned char *p = (unsigned char *) b;
+    unsigned int n = (unsigned int) len;
+    p[0] = (n >> 24) & 0xFF;
+    p[1] = (n >> 16) & 0xFF;
+    p[2] = (n >> 8) & 0xFF;
+    p[3] = n & 0xFF;
+}
+
+static int report_control_error(char **buffer, int buff_len, 
+                char *error_message)
+{
+    int elen = strlen(error_message);
+    if (elen + 1 < buff_len) {
+    *buffer = driver_alloc(elen + 1);
+    }
+    **buffer = 1;
+    memcpy((*buffer) + 1, error_message, elen);
+    return elen + 1;
+}
+
+void free_entry(driver_data_t* element) {
+    int l;
+    
+    close(element->clientSock);
+    // empty the queue
+    l = driver_sizeq(element->port);
+    if (l > 0) {
+        driver_deq(element->port, l);
+    }
+    driver_free(element);
+}
+
+unsigned long get_current_time(void) {
+    unsigned long res;
+    ErlDrvNowData *now = driver_alloc(sizeof(ErlDrvNowData));
+    driver_get_now(now);
+    //res = now->secs + now->megasecs * 1000000;
+    res = now->secs * 1000 + now->microsecs / 1000;
+    driver_free(now);
+    
+    return res;
+}
+
+unsigned long get_secs(void) {
+    unsigned long res;
+    ErlDrvNowData *now = driver_alloc(sizeof(ErlDrvNowData));
+    driver_get_now(now);
+    res = now->secs;
+    driver_free(now);
+    
+    return res;
+}
+
+/**
+ * In Erlang terms:
+ * input:
+ * 131|Header|Msg
+ * output:
+ * 131|Header|{RSSI, IP, Msg}
+ * 
+ * In byte stream terms:
+ * input:
+ * 131,
+ *      131,
+ *          104, 2,
+ *              97, 2,
+ *              103,
+ *                  115, x, ...
+ *                  x, x, x, x
+ *                  x, x, x, x,
+ *                  x,
+ *      131,
+ *          x, ...
+ * or:
+ * 131,
+ *      131,
+ *          104, 2,
+ *              97, 6,
+ *              115, x, ...
+ *      131,
+ *          x, ...
+ * output:
+ * 131,
+ *      131,
+ *          104, 2,
+ *              97, 2,
+ *              103,
+ *                  115, x, ...
+ *                  x, x, x, x
+ *                  x, x, x, x,
+ *                  x,
+ *      131,
+ *          104, 3,
+ *              97, RSSI,
+ *              104, 4,
+ *                  97, A,
+ *                  97, B,
+ *                  97, C,
+ *                  97, D
+ *              x, ...
+ * or:
+ * 131,
+ *      131,
+ *          104, 2,
+ *              97, 6,
+ *              115, x, ...
+ *      131,
+ *          104, 3,
+ *              97, RSSI,
+ *              104, 4,
+ *                  97, A,
+ *                  97, B,
+ *                  97, C,
+ *                  97, D
+ *              x, ...
+ */
+void append_header(char *buf, int len, int rssi, unsigned int ip) {
+    char hdr[] = {104, 3,               /* payload tuple: {RSSI, SourceIP, Msg} */
+                                97, 47,          /* RSSI (uint8_t) */
+                                104, 4,          /* IPv4 tuple: {x, y, z, w} */
+                                    97, 192,    /* x (uint8_t) */
+                                    97, 168,    /* y (uint8_t) */
+                                    97, 1,        /* z (uint8_t) */
+                                    97, 2};      /* w (uint8_t) */
+    int i, msg_type, node_len, pre_hdr;
+    uint8_t rssi_fin[4], ip_fin[4];
+    
+    /* step 1: find out how long is the header (plus the leading 131 and the 131 of the message) */
+    msg_type = buf[5];
+    switch (msg_type) {
+        case 2:
+            node_len = buf[8];
+            pre_hdr = node_len + 19;
+            break;
+        case 6:
+            node_len = buf[7];
+            pre_hdr = node_len + 9;
+            break;
+        default:
+            /* forget about it */
+            FPRINTF(stderr, "DEBUG: we do not append headers to messages of type %d\n", msg_type);
+            return;
+    }
+    /* step 2: fill in the hdr with the passed values */
+    memcpy(rssi_fin, &rssi, 4);
+    memcpy(ip_fin, &ip, 4);
+    hdr[3] = rssi_fin[0];
+    hdr[7] = ip_fin[0];
+    hdr[9] = ip_fin[1];
+    hdr[11] = ip_fin[2];
+    hdr[13] = ip_fin[3];
+    /* step 3: shift the buffer onwards for HDR_SIZE positions */
+    for (i = BUF + HDR_SIZE - 2; i - HDR_SIZE >= pre_hdr; --i) {
+        buf[i] = buf[i - HDR_SIZE];
+    }
+    /* step 4: fill in the header */
+    for (i = 0; i < HDR_SIZE; ++i) {
+        buf[i + pre_hdr] = hdr[i];
+    }
+    /* voilà! */
+}
diff -ruN1 otp/lib/udp_dist/c_src/Makefile erlang2/lib/udp_dist/c_src/Makefile
--- otp/lib/udp_dist/c_src/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ erlang2/lib/udp_dist/c_src/Makefile	2013-06-25 16:36:08.463124525 +0200
@@ -0,0 +1,97 @@
+include $(ERL_TOP)/make/target.mk
+include $(ERL_TOP)/make/$(TARGET)/otp.mk
+include $(ERL_TOP)/make/$(TARGET)/otp_ded.mk
+
+CC = $(DED_CC)
+LD = $(DED_LD)
+LIBS = $(DED_LIBS)
+
+# ----------------------------------------------------
+# Application version
+# ----------------------------------------------------
+include ../vsn.mk
+VSN=$(UDP_VSN)
+
+# ----------------------------------------------------
+# Release directory specification
+# ----------------------------------------------------
+RELSYSDIR = $(RELEASE_PATH)/lib/udp_dist-$(VSN)
+
+
+# ----------------------------------------------------
+# FLAGS misc
+# ----------------------------------------------------
+
+EI_LIBDIR = $(ERL_TOP)/lib/erl_interface/obj/$(TARGET)
+EI_INCLUDES = $(ERL_TOP)/lib/erl_interface/include
+ERTS_INCLUDES = $(ERL_TOP)/erts/emulator/beam
+
+# ----------------------------------------------------
+# FLAGS
+# ----------------------------------------------------
+CFLAGS = $(DED_INCLUDES) $(EI_INCLUDES) $(ERTS_INCLUDES) $(DED_CFLAGS)
+LDFLAGS += $(DED_LDFLAGS) -fPIC -Wall -fmessage-length=0 -fno-common
+
+# ----------------------------------------------------
+# Target Specs
+# ----------------------------------------------------
+
+OBJ_FILES = $(OBJDIR)/eliot_udp.o
+
+
+ifeq ($(TARGET),win32)
+SHARED_OBJ_FILE = $(LIBDIR)/eliot_udp.dll
+CLIB_FLAGS =
+LN=cp
+else
+ifeq ($(findstring vxworks,$(TARGET)),vxworks)
+SHARED_OBJ_FILE = $(LIBDIR)/eliot_udp.eld
+CLIB_FLAGS =
+else
+SHARED_OBJ_FILE = $(LIBDIR)/eliot_udp.so
+CLIB_FLAGS = -lc
+endif
+LN= ln -s
+endif
+
+# ----------------------------------------------------
+# Targets
+# ----------------------------------------------------
+
+_create_dirs := $(shell mkdir -p $(OBJDIR) $(LIBDIR))
+
+opt: $(SHARED_OBJ_FILE)
+
+debug: opt
+
+clean:
+	rm -f core *~ 
+	rm -f $(LIBDIR)/*
+	rm -f $(OBJDIR)/*
+
+docs:
+
+# ----------------------------------------------------
+# Special Build Targets
+# ----------------------------------------------------
+
+
+$(OBJDIR)/%.o: %.c
+	$(CC) -c $(CFLAGS) -O3 -o $@ $<
+
+$(SHARED_OBJ_FILE): $(OBJ_FILES)
+	$(LD) $(LDFLAGS) -o $(SHARED_OBJ_FILE) $(OBJ_FILES) $(CLIB_FLAGS) $(LIBS)
+
+# ----------------------------------------------------
+# Release Target
+# ----------------------------------------------------
+include $(ERL_TOP)/make/otp_release_targets.mk
+
+release_spec: opt
+	$(INSTALL_DIR) "$(RELSYSDIR)/priv/lib"
+	$(INSTALL_PROGRAM) $(SHARED_OBJ_FILE) "$(RELSYSDIR)/priv/lib"
+	$(INSTALL_DIR) "$(RELSYSDIR)/c_src"
+	$(INSTALL_DATA) *.c "$(RELSYSDIR)/c_src"
+
+release_docs_spec:
+
diff -ruN1 otp/lib/udp_dist/include/udp.hrl erlang2/lib/udp_dist/include/udp.hrl
--- otp/lib/udp_dist/include/udp.hrl	1970-01-01 01:00:00.000000000 +0100
+++ erlang2/lib/udp_dist/include/udp.hrl	2013-06-25 16:36:08.463124525 +0200
@@ -0,0 +1,3 @@
+-define(NODENAME, "eliot").
+-define(INTERFACE, "eth0").
+-define(DRIVER_NAME,"eliot_udp").
diff -ruN1 otp/lib/udp_dist/info erlang2/lib/udp_dist/info
--- otp/lib/udp_dist/info	1970-01-01 01:00:00.000000000 +0100
+++ erlang2/lib/udp_dist/info	2013-06-25 16:36:08.463124525 +0200
@@ -0,0 +1,2 @@
+group: basic Basic Applications
+short: Provides the network driver
diff -ruN1 otp/lib/udp_dist/Makefile erlang2/lib/udp_dist/Makefile
--- otp/lib/udp_dist/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ erlang2/lib/udp_dist/Makefile	2013-06-25 16:36:08.463124525 +0200
@@ -0,0 +1,17 @@
+include $(ERL_TOP)/make/target.mk
+include $(ERL_TOP)/make/$(TARGET)/otp.mk
+
+#
+# Macros
+#
+SUB_DIRECTORIES = src c_src
+
+include vsn.mk
+VSN = $(UDP_VSN)
+
+SPECIAL_TARGETS = 
+
+#
+# Default Subdir Targets
+#
+include $(ERL_TOP)/make/otp_subdir.mk
diff -ruN1 otp/lib/udp_dist/src/Makefile erlang2/lib/udp_dist/src/Makefile
--- otp/lib/udp_dist/src/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ erlang2/lib/udp_dist/src/Makefile	2013-06-25 16:36:08.463124525 +0200
@@ -0,0 +1,105 @@
+#
+# %CopyrightBegin%
+# 
+# Copyright Ericsson AB 1997-2012. All Rights Reserved.
+# 
+# The contents of this file are subject to the Erlang Public License,
+# Version 1.1, (the "License"); you may not use this file except in
+# compliance with the License. You should have received a copy of the
+# Erlang Public License along with this software. If not, it can be
+# retrieved online at http://www.erlang.org/.
+# 
+# Software distributed under the License is distributed on an "AS IS"
+# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
+# the License for the specific language governing rights and limitations
+# under the License.
+# 
+# %CopyrightEnd%
+#
+#
+# Copyright (C) 1997, Ericsson Telecommunications
+# Author: Kenneth Lundin 
+#
+include $(ERL_TOP)/make/target.mk
+include $(ERL_TOP)/make/$(TARGET)/otp.mk
+
+# ----------------------------------------------------
+# Application version
+# ----------------------------------------------------
+include ../vsn.mk
+VSN=$(UDP_VSN)
+
+# ----------------------------------------------------
+# Release directory specification
+# ----------------------------------------------------
+RELSYSDIR = $(RELEASE_PATH)/lib/udp_dist-$(VSN)
+
+#
+# Common Macros
+#
+
+EBIN = ../ebin
+MODULES= \
+	udp \
+	udp_dist \
+	udp_server
+
+ERL_FILES = $(MODULES:%=%.erl)
+
+TARGET_FILES = $(MODULES:%=$(EBIN)/%.$(EMULATOR))
+
+HRL_DIR = ../include
+
+APP_FILE = udp_dist.app
+
+APP_SRC = $(APP_FILE).src
+APP_TARGET = $(EBIN)/$(APP_FILE)
+
+# ----------------------------------------------------
+# FLAGS
+# ----------------------------------------------------
+
+ERL_COMPILE_FLAGS += \
+	-I$(ERL_TOP)/lib/kernel/include \
+	-I$(HRL_DIR) \
+	+warn_unused_vars
+
+YRL_FLAGS = 
+
+# ----------------------------------------------------
+# Targets
+# ----------------------------------------------------
+
+debug opt: $(TARGET_FILES) $(APP_TARGET)
+
+
+clean:
+	rm -f $(TARGET_FILES) $(APP_TARGET)
+	rm -f core *~
+
+docs:
+
+
+info:
+	@echo "PARSER_SRC: $(PARSER_SRC)"
+	@echo "INSTALL_DATA: $(INSTALL_DATA)"
+
+$(APP_TARGET): $(APP_SRC) ../vsn.mk
+	sed -e 's;%VSN%;$(VSN);' $< > $@
+
+# ----------------------------------------------------
+# Release Target
+# ----------------------------------------------------
+include $(ERL_TOP)/make/otp_release_targets.mk
+
+release_spec: opt
+	$(INSTALL_DIR) "$(RELSYSDIR)/ebin"
+	$(INSTALL_DATA) $(TARGET_FILES) $(APP_TARGET) "$(RELSYSDIR)/ebin"
+	$(INSTALL_DIR) "$(RELSYSDIR)/src"
+	$(INSTALL_DATA)  $(ERL_FILES) $(HRL_FILES) $(APP_SRC) "$(RELSYSDIR)/src"
+
+# there are no include files to be used by the user
+#$(INSTALL_DIR) "$(RELSYSDIR)/include"
+#$(INSTALL_DATA) $(HRL_FILES) "$(RELSYSDIR)/include"
+
+release_docs_spec:
diff -ruN1 otp/lib/udp_dist/src/udp_dist.app.src erlang2/lib/udp_dist/src/udp_dist.app.src
--- otp/lib/udp_dist/src/udp_dist.app.src	1970-01-01 01:00:00.000000000 +0100
+++ erlang2/lib/udp_dist/src/udp_dist.app.src	2013-06-25 16:36:08.463124525 +0200
@@ -0,0 +1,7 @@
+{application,udp_dist,
+             [{description,[]},
+              {vsn,"1.0"},
+              {registered,[udp_server]},
+              {applications,[kernel,stdlib]},
+              {env,[]},
+              {modules,[udp,udp_dist,udp_server]}]}.
diff -ruN1 otp/lib/udp_dist/src/udp_dist.erl erlang2/lib/udp_dist/src/udp_dist.erl
--- otp/lib/udp_dist/src/udp_dist.erl	1970-01-01 01:00:00.000000000 +0100
+++ erlang2/lib/udp_dist/src/udp_dist.erl	2013-06-25 16:36:08.463124525 +0200
@@ -0,0 +1,373 @@
+-module(udp_dist).
+-export([childspecs/0, listen/1, accept/1, accept_connection/5,
+         setup/5, close/1, select/1, is_node_name/1]).
+-export([accept_loop/2, do_accept/6, do_setup/6, getstat/1,tick/1]).
+-export([split_node/3, splitnode/2]).
+-import(error_logger,[error_msg/2]).
+-include("net_address.hrl").
+-include("dist.hrl").
+-include("dist_util.hrl").
+-include("udp.hrl").
+-define(to_port(Socket, Data),
+        case udp:send(Socket, Data) of
+            {error, closed} ->
+                self() ! {udp_closed, Socket},
+                {error, closed};
+            R ->
+                R
+        end).
+
+% Public API
+
+%% -------------------------------------------------------------
+%% This function should return a valid childspec, so that 
+%% the primitive ssl_server gets supervised
+%% -------------------------------------------------------------
+childspecs() ->
+    {ok, [{udp_server,{udp_server, start_link, []},
+           permanent, 2000, worker, [udp_server]}]}.
+
+%% ------------------------------------------------------------
+%%  Select this protocol based on node name
+%%  select(Node) => Bool
+%% ------------------------------------------------------------
+
+select(all) ->
+    true;
+select(Node) ->
+    case split_node(atom_to_list(Node), $@, []) of
+    [_,_Host] -> 
+        true;
+    _ -> 
+        false
+    end.
+
+%% ------------------------------------------------------------
+%% Create the listen socket, i.e. the port that this erlang
+%% node is accessible through.
+%% ------------------------------------------------------------
+
+listen(Name) ->
+    case udp:listen(atom_to_list(Name)) of
+        {ok, Socket} ->
+            % Set my address in the driver
+            % (yeah, it sucks doing it here, but anyway...)
+            udp:myaddr(Socket, inet_parse:ntoa(get_host_ip())),
+            % Create the 'all' port
+            spawn(fun() -> net_kernel:connect_node(all) end),
+            {ok, {Socket, 
+                  #net_address{address = [], 
+                               host = inet:gethostname(),
+                               protocol = udp, 
+                               family = udp}, 
+                  udp:get_creation(Socket)}};
+        Error ->
+            Error
+    end.
+
+%% ------------------------------------------------------------
+%% Accepts new connection attempts from other Erlang nodes.
+%% ------------------------------------------------------------
+
+accept(Listen) ->
+    spawn_link(?MODULE, accept_loop, [self(), Listen]).
+
+accept_loop(Kernel, Listen) ->
+    process_flag(priority, max),
+    case udp:accept(Listen) of
+        {ok, Socket} ->
+            Kernel ! {accept,self(),Socket,udp,udp},
+            controller(Kernel, Socket),
+            accept_loop(Kernel, Listen);
+        Error ->
+            exit(Error)
+    end.
+
+controller(Kernel, Socket) ->
+    receive
+        {Kernel, controller, Pid} ->
+            udp:controlling_process(Socket, Pid),
+            Pid ! {self(), controller};
+        {Kernel, unsupported_protocol} ->
+            exit(unsupported_protocol)
+    end.
+
+%% ------------------------------------------------------------
+%% Accepts a new connection attempt from another Erlang node.
+%% Performs the handshake with the other side.
+%% ------------------------------------------------------------
+
+accept_connection(AcceptPid, Socket, MyNode, Allowed, SetupTime) ->
+    ?trace("DEBUG: Accepting a new connection...~n", []),
+    spawn_link(?MODULE, do_accept,
+               [self(), AcceptPid, Socket, MyNode,
+                Allowed, SetupTime]).
+
+do_accept(Kernel, AcceptPid, Socket, MyNode, Allowed, SetupTime) ->
+    process_flag(priority, max),
+    udp:recv(Socket),
+    {ok, IP} = udp:ip(Socket),
+    {D, C, B, A} = int_to_ip(IP),
+    ?trace("DEBUG: IP is ~p~n", [inet_parse:ntoa({A, B, C, D})]),
+    OtherNode = list_to_atom(?NODENAME ++ "@" ++ inet_parse:ntoa({A, B, C, D})),
+    receive
+        {AcceptPid, controller} ->
+            ?trace("DEBUG: Starting handshake (receiver side)~n", []),
+            Timer = dist_util:start_timer(SetupTime),
+            HSData = #hs_data{
+                              kernel_pid = Kernel,
+                              this_node = MyNode,
+                              other_node = OtherNode,
+                              other_version=1,
+                              socket = Socket,
+                              timer = Timer,
+                              this_flags = ?DFLAG_PUBLISHED bor
+                                               ?DFLAG_HIDDEN_ATOM_CACHE bor
+                                               ?DFLAG_EXTENDED_REFERENCES bor
+                                               ?DFLAG_DIST_MONITOR bor
+                                               ?DFLAG_FUN_TAGS,
+                              allowed = Allowed,
+                              f_send = fun(S,E) -> udp:send(S,E) end,
+                              f_recv = fun(S,_N,_T) -> udp:recv(S) 
+                                       end,
+                              f_setopts_pre_nodeup = 
+                                  fun(S) ->
+                                          udp:set_mode(S, intermediate)
+                                  end,
+                              f_setopts_post_nodeup = 
+                                  fun(S) ->
+                                          udp:set_mode(S, data)
+                                  end,
+                              f_getll = fun(S) ->
+                                                udp:get_port(S)
+                                        end,
+                              f_address = fun get_remote_id/2,
+                              mf_tick = {?MODULE, tick},
+                              mf_getstat = {?MODULE,getstat}
+                             },
+            dist_util:handshake_other_started(HSData),
+            ?trace("DEBUG: Handshake done~n", [])
+    end.
+
+%% ------------------------------------------------------------
+%% Get remote information about a Socket.
+%% ------------------------------------------------------------
+
+get_remote_id(_Socket, Node) ->
+    [_, Host] = split_node(atom_to_list(Node), $@, []),
+    #net_address {
+                  address = [],
+                  host = Host,
+                  protocol = udp,
+                  family = udp }.
+
+%% ------------------------------------------------------------
+%% Setup a new connection to another Erlang node.
+%% Performs the handshake with the other side.
+%% ------------------------------------------------------------
+
+setup(Node, Type, MyNode, LongOrShortNames,SetupTime) ->
+    spawn_link(?MODULE, do_setup, [self(),
+                                   Node,
+                                   Type,
+                                   MyNode,
+                                   LongOrShortNames,
+                                   SetupTime]).
+
+do_setup(Kernel, all, Type, MyNode, LongOrShortNames, SetupTime) ->
+    Timer = dist_util:start_timer(SetupTime),
+    case udp:broadcast(inet_parse:ntoa(get_bcast_addr())) of
+        {ok, Socket} ->
+            ?trace("DEBUG: Starting handshake (sender side)~n", []),
+            HSData = #hs_data{
+                              kernel_pid = Kernel,
+                              other_node = all,
+                              this_node = MyNode,
+                              socket = Socket,
+                              timer = Timer,
+                              this_flags = ?DFLAG_PUBLISHED bor
+                                               ?DFLAG_HIDDEN_ATOM_CACHE bor
+                                               ?DFLAG_EXTENDED_REFERENCES bor
+                                               ?DFLAG_DIST_MONITOR bor
+                                               ?DFLAG_FUN_TAGS,
+                              other_version = 1,
+                              f_send = fun(S,D) -> 
+                                               udp:send(S,D) 
+                                       end,
+                              f_recv = fun(S,_N,_T) -> 
+                                               udp:recv(S) 
+                                       end,
+                              f_setopts_pre_nodeup = 
+                                  fun(S) ->
+                                          udp:set_mode(S, intermediate)
+                                  end,
+                              f_setopts_post_nodeup = 
+                                  fun(S) ->
+                                          udp:set_mode(S, data)
+                                  end,
+                              f_getll = fun(S) ->
+                                                udp:get_port(S)
+                                        end,
+                              f_address = 
+                                  fun(_,_) ->
+                                          #net_address{
+                                                       address = {get_bcast_addr(), 4369},
+                                                       host = all,
+                                                       protocol = udp,
+                                                       family = udp}
+                                  end,
+                              request_type = Type,
+                              mf_tick = {?MODULE, tick},
+                              mf_getstat = {?MODULE,getstat}
+                             },
+            dist_util:handshake_we_started(HSData),
+            ?trace("DEBUG: Handshake done~n", []);
+        Other ->
+            ?trace("Inner: ~p~n", [Other]),
+            ?shutdown(all)
+    end;
+do_setup(Kernel, Node, Type, MyNode, LongOrShortNames,SetupTime) ->
+    process_flag(priority, max),
+    ?trace("~p~n",[{udp_dist,self(),setup,Node}]),
+    [Name, Address] = splitnode(Node, LongOrShortNames),
+     case inet:getaddr(Address, inet) of
+         {ok, IP} ->
+            Timer = dist_util:start_timer(SetupTime),
+            case udp:connect(IP) of
+                {ok, Socket} ->
+                    ?trace("DEBUG: Starting handshake (sender side)~n", []),
+                    HSData = #hs_data{
+                                      kernel_pid = Kernel,
+                                      other_node = Node,
+                                      this_node = MyNode,
+                                      socket = Socket,
+                                      timer = Timer,
+                                      this_flags = ?DFLAG_PUBLISHED bor
+                                                       ?DFLAG_HIDDEN_ATOM_CACHE bor
+                                                       ?DFLAG_EXTENDED_REFERENCES bor
+                                                       ?DFLAG_DIST_MONITOR bor
+                                                       ?DFLAG_FUN_TAGS,
+                                      other_version = 1,
+                                      f_send = fun(S,D) -> 
+                                                       udp:send(S,D) 
+                                               end,
+                                      f_recv = fun(S,_N,_T) -> 
+                                                       udp:recv(S) 
+                                               end,
+                                      f_setopts_pre_nodeup = 
+                                          fun(_S) ->
+                                                  ok
+                                          end,
+                                      f_setopts_post_nodeup = 
+                                          fun(S) ->
+                                                  udp:set_mode(S, data)
+                                          end,
+                                      f_getll = fun(S) ->
+                                                        udp:get_port(S)
+                                                end,
+                                      f_address = 
+                                          fun(_,_) ->
+                                                  #net_address{
+                                                               address = {IP, 4369},
+                                                               host = Address,
+                                                               protocol = udp,
+                                                               family = udp}
+                                          end,
+                                      request_type = Type,
+                                      mf_tick = {?MODULE, tick},
+                                      mf_getstat = {?MODULE,getstat}
+                                     },
+                    dist_util:handshake_we_started(HSData),
+                    ?trace("DEBUG: Handshake done~n", []);
+                Other ->
+                    ?trace("Inner: ~p~n", [Other]),
+                    ?shutdown(Node)
+            end;
+        _ ->
+            ?trace("Outer: getaddr failed~n", []),
+            ?shutdown(Node)
+    end.
+
+%%
+%% Close a socket.
+%%
+close(Socket) ->
+    udp:close(Socket).
+
+
+%% If Node is illegal terminate the connection setup!!
+splitnode(Node, LongOrShortNames) ->
+    case split_node(atom_to_list(Node), $@, []) of
+        [Name|Tail] when Tail /= [] ->
+            Host = lists:append(Tail),
+            case split_node(Host, $., []) of
+                [_] when LongOrShortNames == longnames ->
+                    error_msg("** System running to use "
+                                  "fully qualified "
+                                      "hostnames **~n"
+                                          "** Hostname ~s is illegal **~n",
+                                          [Host]),
+                    ?shutdown(Node);
+                L when length(L) > 1, LongOrShortNames == shortnames ->
+                    error_msg("** System NOT running to use fully qualified "
+                                  "hostnames **~n"
+                                      "** Hostname ~s is illegal **~n",
+                                      [Host]),
+                    ?shutdown(Node);
+                _ ->
+                    [Name, Host]
+            end;
+        [_] ->
+            error_msg("** Nodename ~p illegal, no '@' character **~n",
+                      [Node]),
+            ?shutdown(Node);
+        _ ->
+            error_msg("** Nodename ~p illegal **~n", [Node]),
+            ?shutdown(Node)
+    end.
+
+split_node([Chr|T], Chr, Ack) -> [lists:reverse(Ack)|split_node(T, Chr, [])];
+split_node([H|T], Chr, Ack)   -> split_node(T, Chr, [H|Ack]);
+split_node([], _, Ack)        -> [lists:reverse(Ack)].
+
+is_node_name(Node) when is_atom(Node) ->
+    select(Node);
+is_node_name(_) ->
+    false.
+
+tick(Sock) ->
+    udp:tick(Sock).
+getstat(Socket) ->
+    udp:get_status_counters(Socket).
+
+get_bcast_addr() ->
+    case inet:getifaddrs() of
+        {ok, IfList} when length(IfList) == 2 ->
+            [{_Real, IfOpts}] = lists:filter(fun({Name, _IfOpts}) when Name == "lo" -> false;
+                                     ({_Name, _IfOpts}) -> true end, IfList),
+            {broadaddr, Address} = lists:keyfind(broadaddr, 1, IfOpts),
+            Address;
+        {ok, IfList} ->
+            {?INTERFACE, IfOpts} = lists:keyfind(?INTERFACE, 1, IfList),
+            {broadaddr, Address} = lists:keyfind(broadaddr, 1, IfOpts),
+            Address
+    end.
+
+get_host_ip() ->
+    case inet:getifaddrs() of
+        {ok, IfList} when length(IfList) == 2 ->
+            [{_Real, IfOpts}] = lists:filter(fun({Name, _IfOpts}) when Name == "lo" -> false;
+                                     ({_Name, _IfOpts}) -> true end, IfList),
+            {addr, Address} = lists:keyfind(addr, 1, IfOpts),
+            Address;
+        {ok, IfList} ->
+            {?INTERFACE, IfOpts} = lists:keyfind(?INTERFACE, 1, IfList),
+            Addresses = proplists:lookup_all(addr, IfOpts),
+            Ip4Addresses = lists:filter(fun({addr, Addr}) when tuple_size(Addr) == 4 -> true;
+                                                           ({addr, _Addr}) -> false end, Addresses),
+            {addr, Address} = hd(Ip4Addresses),
+            Address
+    end.
+
+int_to_ip(Ip) ->
+    {Ip bsr 24, (Ip band 16711680) bsr 16, (Ip band 65280) bsr 8, Ip band 255}.
diff -ruN1 otp/lib/udp_dist/src/udp.erl erlang2/lib/udp_dist/src/udp.erl
--- otp/lib/udp_dist/src/udp.erl	1970-01-01 01:00:00.000000000 +0100
+++ erlang2/lib/udp_dist/src/udp.erl	2013-06-25 16:36:08.463124525 +0200
@@ -0,0 +1,218 @@
+-module(udp).
+
+-export([listen/1, connect/1, accept/1, send/2, recv/1, close/1,
+	 get_port/1, get_status_counters/1, controlling_process/2,
+	 tick/1, get_creation/1, start/0, set_mode/2, print_ports/1, broadcast/1, ip/1, myaddr/2]).
+-include("dist_util.hrl").
+-include("udp.hrl").
+-define(decode(A,B,C,D), (((A) bsl 24) bor 
+			  ((B) bsl 16) bor ((C) bsl 8) bor (D))).
+-define(encode(N), [(((N) bsr 24) band 16#FF), (((N) bsr 16) band 16#FF),  
+		    (((N) bsr 8) band 16#FF), ((N) band 16#FF)]).  
+-define(check_server(), case whereis(udp_server) of 
+			    undefined ->
+				exit(udp_server_not_started);
+			    _ ->
+				ok
+			end).
+
+listen(Name) ->
+    ?check_server(),
+    ?trace("DEBUG: Listening ~p...~n", [Name]),
+    command(port(),$L,Name).
+
+connect(Address) when is_tuple(Address) ->
+    ?check_server(),
+    AddrName = inet_parse:ntoa(Address),
+    ?trace("DEBUG: Connecting ~p...~n", [AddrName]),
+    command(port(),$C,AddrName);
+connect(Address) ->
+    ?check_server(),
+    ?trace("DEBUG: Connecting ~p...~n", [Address]),
+    command(port(),$C,Address).
+
+broadcast(Address) ->
+    ?check_server(),
+    ?trace("DEBUG: Start beaconing port...~n", []),
+    command(port(),$B,Address).
+
+accept(_Port) ->
+    ?check_server(),
+    ?trace("DEBUG: Accepting...~n", []),
+    command(port(),$A,[]).
+
+send(Port,Data) ->
+    ?check_server(),
+    ?trace("DEBUG: Sending  ~p...~n", [Data]),
+    command(Port, $S, Data).
+
+recv(Port) ->
+    ?check_server(),
+    ?trace("DEBUG: Receiving...~n", []),
+    command(Port, $R, []).
+
+close(Port) ->
+    ?check_server(),
+    ?trace("DEBUG: Closing...~n", []),
+    (catch unlink(Port)), %% Avoids problem with trap exits.
+    case (catch erlang:port_close(Port)) of
+	{'EXIT', _Reason} ->
+	    {error, closed};
+	_ ->
+	    ok
+    end.
+
+get_port(Port) ->
+    ?check_server(),
+    ?trace("DEBUG: Getting port...~n", []),
+    {ok,Port}.
+
+get_status_counters(Port) ->
+    ?check_server(),
+    ?trace("DEBUG: Getting counters...~n", []),
+    case control(Port, $S) of
+	{ok, {C0, C1, C2}} ->
+	    {ok, C0, C1, C2};
+	Other ->
+	    Other
+    end.
+
+get_creation(Port) ->
+    ?check_server(),
+    ?trace("DEBUG: Getting creation...~n", []),
+    case control(Port, $R) of
+	{ok, [A]} ->
+	    A;
+	Else ->
+	    Else
+    end.
+
+tick(Port) ->
+    ?check_server(),
+    ?trace("DEBUG: Tick...~n", []),
+    control(Port,$T).
+
+myaddr(Port, Address) ->
+    ?check_server(),
+    ?trace("DEBUG: Setting my address..~n", []),
+    command(Port, $M, Address).
+
+ip(Port) ->
+    ?check_server(),
+    ?trace("DEBUG: IP...~n", []),
+    control(Port, $I).
+
+set_mode(Port, intermediate) ->
+    ?check_server(),
+    ?trace("DEBUG: Mode set to intermediate...~n", []),
+    control(Port, $N);
+set_mode(Port,data) ->
+    ?check_server(),
+    ?trace("DEBUG: Mode set to data...~n", []),
+    control(Port,$D).
+
+print_ports(Port) ->
+    ?check_server(),
+    control(Port, $P).
+
+controlling_process(Port, Pid) ->
+    ?check_server(),
+    case (catch erlang:port_connect(Port, Pid)) of
+	true ->
+	    (catch unlink(Port)),
+	    ok;
+	{'EXIT', {badarg, _}} ->
+	    {error, closed};
+	Else ->
+	    exit({unexpected_driver_response, Else})
+    end.
+
+control(Port, Command) ->
+    case (catch erlang:port_control(Port, Command, [])) of
+	[0] ->
+	    ok;
+	[0,A] ->
+	    {ok, [A]};
+	[0,A,B,C,D] ->
+	    {ok, ?decode(A, B, C, D)};
+	[0,A1,B1,C1,D1,A2,B2,C2,D2,A3,B3,C3,D3] ->
+	    {ok, {?decode(A1,B1,C1,D1),?decode(A2,B2,C2,D2),
+		  ?decode(A3,B3,C3,D3)}};
+	[1|Error] ->
+	    exit({error, list_to_atom(Error)});
+	{'EXIT', {badarg, _}} ->
+	    {error, closed};
+	Else ->
+	    exit({unexpected_driver_response, Else})
+    end.
+
+command(Port, Command, Parameters) ->
+    SavedTrapExit = process_flag(trap_exit,true),
+    case (catch erlang:port_command(Port,[Command | Parameters])) of
+	true ->
+	    receive
+		{Port, {data, [Command, $o, $k]}} ->
+            ?trace("DEBUG: ~p ok~n", [Command]),
+		    process_flag(trap_exit,SavedTrapExit),
+		    {ok, Port};
+		{Port, {data, [Command |T]}} ->
+            ?trace("DEBUG: Received ~p:~p~n", [Command, T]),
+		    process_flag(trap_exit,SavedTrapExit),
+		    {ok, T};
+		{Port, Else} ->
+            ?trace("DEBUG: Unexpected response~n", []),
+		    process_flag(trap_exit,SavedTrapExit),
+		    exit({unexpected_driver_response, Else});
+		{'EXIT', Port, normal} ->
+            ?trace("DEBUG: Normal exit~n", []),
+		    process_flag(trap_exit,SavedTrapExit),
+		    {error, closed};
+		{'EXIT', Port, Error} ->
+            ?trace("DEBUG: Error exit~n", []),
+		    process_flag(trap_exit,SavedTrapExit),
+		    exit(Error)
+	    end;
+	{'EXIT', {badarg, _}} ->
+        ?trace("DEBUG: Badarg~n", []),
+	    process_flag(trap_exit,SavedTrapExit),
+	    {error, closed};
+	Unexpected ->
+        ?trace("DEBUG: Unexpected response 2~n", []),
+	    process_flag(trap_exit,SavedTrapExit),
+	    exit({unexpected_driver_response, Unexpected})
+    end.
+
+port() ->
+    SavedTrapExit = process_flag(trap_exit,true),
+    case open_port({spawn, "eliot_udp"},[]) of
+	P when is_port(P) ->
+	    process_flag(trap_exit,SavedTrapExit),
+	    P;
+	{'EXIT',Error} ->
+	    process_flag(trap_exit,SavedTrapExit),
+	    exit(Error);
+	Else ->
+	    process_flag(trap_exit,SavedTrapExit),
+	    exit({unexpected_driver_response, Else})
+    end.
+
+start() ->
+    Name = list_to_atom(?NODENAME ++ "@" ++ get_host_ip()),
+    net_kernel:start([Name, longnames]),
+    erlang:set_cookie(node(), 'abc').
+
+get_host_ip() ->
+    case inet:getifaddrs() of
+        {ok, IfList} when length(IfList) == 2 ->
+            [{_Real, IfOpts}] = lists:filter(fun({Name, _IfOpts}) when Name == "lo" -> false;
+                                     ({_Name, _IfOpts}) -> true end, IfList),
+            {addr, Address} = lists:keyfind(addr, 1, IfOpts),
+            inet_parse:ntoa(Address);
+        {ok, IfList} ->
+            {?INTERFACE, IfOpts} = lists:keyfind(?INTERFACE, 1, IfList),
+            Addresses = proplists:lookup_all(addr, IfOpts),
+            Ip4Addresses = lists:filter(fun({addr, Addr}) when tuple_size(Addr) == 4 -> true;
+                                                           ({addr, _Addr}) -> false end, Addresses),
+            {addr, Address} = hd(Ip4Addresses),
+            inet_parse:ntoa(Address)
+    end.
diff -ruN1 otp/lib/udp_dist/src/udp_server.erl erlang2/lib/udp_dist/src/udp_server.erl
--- otp/lib/udp_dist/src/udp_server.erl	1970-01-01 01:00:00.000000000 +0100
+++ erlang2/lib/udp_dist/src/udp_server.erl	2013-06-25 16:36:08.463124525 +0200
@@ -0,0 +1,87 @@
+-module(udp_server).
+-behaviour(gen_server).
+-export([start_link/0]).
+-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]).
+-include("udp.hrl").
+
+% Public API
+start_link() ->
+    gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).
+
+init([]) ->
+    process_flag(trap_exit,true),
+    Res = load_driver(),
+    case Res of
+	ok ->
+	    {ok, []};
+	{error, already_loaded} ->
+	    {ok, []};
+	Error ->
+	    exit(Error)
+    end.
+
+handle_call(_Request, _From, State) ->
+    Reply = ok,
+    {reply, Reply, State}.
+
+handle_cast(_Msg, State) ->
+    {noreply, State}.
+
+handle_info(_Info, State) ->
+    {noreply, State}.
+
+terminate(_Reason, _State) ->
+    erl_ddll:unload_driver(?DRIVER_NAME),
+    ok.
+
+code_change(_OldVsn, State, _Extra) ->
+    {ok, State}.
+
+% Private API
+
+load_driver() ->
+    Dir = find_priv_lib(),
+    erl_ddll:load_driver(filename:join(Dir, "lib"),?DRIVER_NAME).
+
+find_priv_lib() ->
+    case (catch code:priv_dir(udp_dist)) of
+		  {error, _} ->
+		      %% Code server probably not startet yet
+		      {ok, P} = erl_prim_loader:get_path(),
+		      ModuleFile = atom_to_list(?MODULE) ++ extension(),
+		      Pd = (catch lists:foldl
+			    (fun(X,Acc) ->
+				     M = filename:join([X, ModuleFile]),
+				     %% The file server probably not started
+				     %% either, has to use raw interface.
+				     case file:raw_read_file_info(M) of 
+					 {ok,_} -> 
+					     %% Found our own module in the
+					     %% path, lets bail out with
+					     %% the priv_dir of this directory
+					     Y = filename:split(X),
+					     throw(filename:join
+						   (lists:sublist
+						    (Y,length(Y) - 1) 
+						    ++ ["priv"])); 
+					 _ -> 
+					     Acc 
+				     end 
+			     end,
+			     false,P)),
+		      case Pd of
+			  false ->
+			      exit(udp_dist_priv_lib_indeterminate);
+			  _ ->
+			      Pd
+		      end;
+		  Dir ->
+		      Dir
+	      end.
+
+extension() ->
+    %% erlang:info(machine) returns machine name as text in all uppercase
+    "." ++ lists:map(fun(X) ->
+			     X + $a - $A
+		     end,
+		     erlang:info(machine)).
diff -ruN1 otp/lib/udp_dist/vsn.mk erlang2/lib/udp_dist/vsn.mk
--- otp/lib/udp_dist/vsn.mk	1970-01-01 01:00:00.000000000 +0100
+++ erlang2/lib/udp_dist/vsn.mk	2013-06-25 16:36:08.463124525 +0200
@@ -0,0 +1 @@
+UDP_VSN = 1.0
diff -ruN1 otp/.project erlang2/.project
--- otp/.project	1970-01-01 01:00:00.000000000 +0100
+++ erlang2/.project	2013-06-25 16:36:07.487124501 +0200
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>erlang2</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+	</buildSpec>
+	<natures>
+	</natures>
+</projectDescription>
