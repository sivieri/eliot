From b53a481ed3d6117a8cd4d2bdf529e4b2805b5dc6 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Sun, 29 Apr 2012 12:16:06 +0200
Subject: [PATCH 01/12] Broadcast operation integrated into the bang operator.

---
 erts/emulator/beam/bif.c |  120 +++++++++++++++++++++++++---------------------
 1 files changed, 66 insertions(+), 54 deletions(-)

diff --git a/erts/emulator/beam/bif.c b/erts/emulator/beam/bif.c
index 55f4798..37801b2 100644
--- a/erts/emulator/beam/bif.c
+++ b/erts/emulator/beam/bif.c
@@ -1973,66 +1973,78 @@ do_send(Process *p, Eterm to, Eterm msg, int suspend) {
 	return 0;
     } else if (is_tuple(to)) { /* Remote send */
 	int ret;
+	Eterm nodesInput, comparison;
 	tp = tuple_val(to);
 	if (*tp != make_arityval(2))
 	    return SEND_BADARG;
 	if (is_not_atom(tp[1]) || is_not_atom(tp[2]))
 	    return SEND_BADARG;
 	
-	/* sysname_to_connected_dist_entry will return NULL if there
-	   is no dist_entry or the dist_entry has no port,
-	   but remote_send() will handle that. */
-
-	dep = erts_sysname_to_connected_dist_entry(tp[2]);
-
-	if (dep == erts_this_dist_entry) {
-	    erts_deref_dist_entry(dep);
-	    if (IS_TRACED(p))
-		trace_send(p, to, msg);
-	    if (ERTS_PROC_GET_SAVED_CALLS_BUF(p))
-		save_calls(p, &exp_send);
-	    
-	    /* Need to virtual schedule out sending process
-	     * because of lock wait. This is only necessary
-	     * for internal port calling but the lock is bundled.
-	     */
-	    
-	    if (IS_TRACED_FL(p, F_TRACE_SCHED_PROCS)) {
-	    	trace_virtual_sched(p, am_out);
-	    }
-	    if (erts_system_profile_flags.runnable_procs && erts_system_profile_flags.exclusive) {
-	    	profile_runnable_proc(p, am_inactive);
-	    }
-
-	    erts_whereis_name(p, ERTS_PROC_LOCK_MAIN,
-			      tp[1],
-			      &rp, 0, ERTS_P2P_FLG_SMP_INC_REFC,
-			      &pt);
-	    if (pt) {
-		portid = pt->id;
-		goto port_common;
-	    }
-	    /* Port lookup failed, virtually schedule the process
-	     * back in.
-	     */
-
-	    if (IS_TRACED_FL(p, F_TRACE_SCHED_PROCS)) {
-	    	trace_virtual_sched(p, am_in);
-	    }
-	    if (erts_system_profile_flags.runnable_procs && erts_system_profile_flags.exclusive) {
-	    	profile_runnable_proc(p, am_active);
-	    }
-
-	    if (!rp) {
-		return 0;
-	    }
-	    goto send_message;
-	}
-
-	ret = remote_send(p, dep, tp[1], to, msg, suspend);
-	if (dep)
-	    erts_deref_dist_entry(dep);
-	return ret;
+	nodesInput = am_atom_put("visible", sys_strlen("visible"));
+	comparison = am_atom_put("all", sys_strlen("all"));
+	
+    if (comparison != tp[2]) { /* Send to a single node (default mode) */
+        
+        /* sysname_to_connected_dist_entry will return NULL if there
+           is no dist_entry or the dist_entry has no port,
+           but remote_send() will handle that. */
+        dep = erts_sysname_to_connected_dist_entry(tp[2]);
+        if (dep == erts_this_dist_entry) {
+            erts_deref_dist_entry(dep);
+            if (IS_TRACED(p))
+            trace_send(p, to, msg);
+            if (ERTS_PROC_GET_SAVED_CALLS_BUF(p))
+            save_calls(p, &exp_send);
+            /* Need to virtual schedule out sending process
+             * because of lock wait. This is only necessary
+             * for internal port calling but the lock is bundled.
+             */
+            
+            if (IS_TRACED_FL(p, F_TRACE_SCHED_PROCS)) {
+                trace_virtual_sched(p, am_out);
+            }
+            if (erts_system_profile_flags.runnable_procs && erts_system_profile_flags.exclusive) {
+                profile_runnable_proc(p, am_inactive);
+            }
+            erts_whereis_name(p, ERTS_PROC_LOCK_MAIN,
+                      tp[1],
+                      &rp, 0, ERTS_P2P_FLG_SMP_INC_REFC,
+                      &pt);
+            if (pt) {
+            portid = pt->id;
+            goto port_common;
+            }
+            /* Port lookup failed, virtually schedule the process
+             * back in.
+             */
+            if (IS_TRACED_FL(p, F_TRACE_SCHED_PROCS)) {
+                trace_virtual_sched(p, am_in);
+            }
+            if (erts_system_profile_flags.runnable_procs && erts_system_profile_flags.exclusive) {
+                profile_runnable_proc(p, am_active);
+            }
+            if (!rp) {
+            return 0;
+            }
+            goto send_message;
+        }
+    
+        ret = remote_send(p, dep, tp[1], to, msg, suspend);
+        if (dep)
+            erts_deref_dist_entry(dep);
+        return ret;
+    }
+    else { /* Broadcast to all nodes */
+        Eterm nodesOutput = nodes_1(p, &nodesInput);
+        ret = 0;
+        while (is_list(nodesOutput)) {
+            Eterm* hp = HAlloc(p, 3);
+            Eterm arg = TUPLE2(hp, tp[1], CAR(list_val(nodesOutput)));
+            ret = erl_send(p, arg, msg) || ret;
+            nodesOutput = CDR(list_val(nodesOutput));
+        }
+        return ret;
+    }
     } else {
 	if (IS_TRACED(p)) /* XXX Is this really neccessary ??? */
 	    trace_send(p, to, msg);
-- 
1.7.7.5 (Apple Git-26)


From b271e9ad5f8abdbe5de6f9431ed26ffbcfda2986 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Sun, 29 Apr 2012 12:16:25 +0200
Subject: [PATCH 02/12] Added project file.

---
 .project |   11 +++++++++++
 1 files changed, 11 insertions(+), 0 deletions(-)
 create mode 100644 .project

diff --git a/.project b/.project
new file mode 100644
index 0000000..52d5dc2
--- /dev/null
+++ b/.project
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>erlang</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+	</buildSpec>
+	<natures>
+	</natures>
+</projectDescription>
-- 
1.7.7.5 (Apple Git-26)


From 2d5e7ec75998ed3180a497b55d55a63481ea0912 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Tue, 1 May 2012 18:59:41 +0200
Subject: [PATCH 03/12] Broadcast messages, part II.

---
 erts/emulator/beam/bif.c |   96 ++++++++++++++++++++++++++++------------------
 1 files changed, 58 insertions(+), 38 deletions(-)

diff --git a/erts/emulator/beam/bif.c b/erts/emulator/beam/bif.c
index 37801b2..39b2371 100644
--- a/erts/emulator/beam/bif.c
+++ b/erts/emulator/beam/bif.c
@@ -1843,45 +1843,65 @@ do_send(Process *p, Eterm to, Eterm msg, int suspend) {
 	}
 	return remote_send(p, dep, to, to, msg, suspend);
     } else if (is_atom(to)) {
+        int ret;
+        Eterm nodesInput, comparison, receiver;
+        
+        nodesInput = am_atom_put("visible", sys_strlen("visible"));
+        comparison = am_atom_put("all", sys_strlen("all"));
+        receiver = am_atom_put("eliot_dispatcher", sys_strlen("eliot_dispatcher"));
+        
+        if (comparison != to) { /* Standard send invocation */
 	
-	/* Need to virtual schedule out sending process
-	 * because of lock wait. This is only necessary
-	 * for internal port calling but the lock is bundled
-	 * with name lookup.
-	 */
-	    
-	if (IS_TRACED_FL(p, F_TRACE_SCHED_PROCS)) {
-	    trace_virtual_sched(p, am_out);
-	}
-	if (erts_system_profile_flags.runnable_procs && erts_system_profile_flags.exclusive) {
-	    profile_runnable_proc(p, am_inactive);
-	}
-	erts_whereis_name(p, ERTS_PROC_LOCK_MAIN,
-			  to,
-			  &rp, 0, ERTS_P2P_FLG_SMP_INC_REFC,
-			  &pt);
-
-	if (pt) {
-	    portid = pt->id;
-	    goto port_common;
-	}
-	
-	/* Not a port virtually schedule the process back in */
-	if (IS_TRACED_FL(p, F_TRACE_SCHED_PROCS)) {
-	    trace_virtual_sched(p, am_in);
-	}
-	if (erts_system_profile_flags.runnable_procs && erts_system_profile_flags.exclusive) {
-	    profile_runnable_proc(p, am_active);
-	}
-
-	if (IS_TRACED(p))
-	    trace_send(p, to, msg);
-	if (ERTS_PROC_GET_SAVED_CALLS_BUF(p))
-	    save_calls(p, &exp_send);
-	
-	if (!rp) {
-	    return SEND_BADARG;
-	}
+            /* Need to virtual schedule out sending process
+             * because of lock wait. This is only necessary
+             * for internal port calling but the lock is bundled
+             * with name lookup.
+             */
+                
+            if (IS_TRACED_FL(p, F_TRACE_SCHED_PROCS)) {
+                trace_virtual_sched(p, am_out);
+            }
+            if (erts_system_profile_flags.runnable_procs && erts_system_profile_flags.exclusive) {
+                profile_runnable_proc(p, am_inactive);
+            }
+            erts_whereis_name(p, ERTS_PROC_LOCK_MAIN,
+                      to,
+                      &rp, 0, ERTS_P2P_FLG_SMP_INC_REFC,
+                      &pt);
+        
+            if (pt) {
+                portid = pt->id;
+                goto port_common;
+            }
+            
+            /* Not a port virtually schedule the process back in */
+            if (IS_TRACED_FL(p, F_TRACE_SCHED_PROCS)) {
+                trace_virtual_sched(p, am_in);
+            }
+            if (erts_system_profile_flags.runnable_procs && erts_system_profile_flags.exclusive) {
+                profile_runnable_proc(p, am_active);
+            }
+        
+            if (IS_TRACED(p))
+                trace_send(p, to, msg);
+            if (ERTS_PROC_GET_SAVED_CALLS_BUF(p))
+                save_calls(p, &exp_send);
+            
+            if (!rp) {
+                return SEND_BADARG;
+            }
+        }
+        else { /* Broadcast to all nodes */
+            Eterm nodesOutput = nodes_1(p, &nodesInput);
+            ret = 0;
+            while (is_list(nodesOutput)) {
+                Eterm* hp = HAlloc(p, 3);
+                Eterm arg = TUPLE2(hp, receiver, CAR(list_val(nodesOutput)));
+                ret = erl_send(p, arg, msg) || ret;
+                nodesOutput = CDR(list_val(nodesOutput));
+            }
+            return ret;
+        }
     } else if (is_external_port(to)
 	       && (external_port_dist_entry(to)
 		   == erts_this_dist_entry)) {
-- 
1.7.7.5 (Apple Git-26)


From 6adb3a74a12214137037c0fc15b7d3b16b68e0cb Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Thu, 3 May 2012 11:16:25 +0200
Subject: [PATCH 04/12] Changes in semantics.

---
 erts/emulator/beam/bif.c |   11 ++++++++---
 1 files changed, 8 insertions(+), 3 deletions(-)

diff --git a/erts/emulator/beam/bif.c b/erts/emulator/beam/bif.c
index 39b2371..2cc2da2 100644
--- a/erts/emulator/beam/bif.c
+++ b/erts/emulator/beam/bif.c
@@ -1848,7 +1848,7 @@ do_send(Process *p, Eterm to, Eterm msg, int suspend) {
         
         nodesInput = am_atom_put("visible", sys_strlen("visible"));
         comparison = am_atom_put("all", sys_strlen("all"));
-        receiver = am_atom_put("eliot_dispatcher", sys_strlen("eliot_dispatcher"));
+        receiver = am_atom_put("dispatcher", sys_strlen("dispatcher"));
         
         if (comparison != to) { /* Standard send invocation */
 	
@@ -2055,12 +2055,17 @@ do_send(Process *p, Eterm to, Eterm msg, int suspend) {
         return ret;
     }
     else { /* Broadcast to all nodes */
+        Eterm dest, connect;
         Eterm nodesOutput = nodes_1(p, &nodesInput);
+        dest = am_atom_put("dispatcher", sys_strlen("dispatcher"));
+        connect = am_atom_put("connect", sys_strlen("connect"));
         ret = 0;
         while (is_list(nodesOutput)) {
             Eterm* hp = HAlloc(p, 3);
-            Eterm arg = TUPLE2(hp, tp[1], CAR(list_val(nodesOutput)));
-            ret = erl_send(p, arg, msg) || ret;
+            Eterm* hp2 = HAlloc(p, 4);
+            Eterm arg = TUPLE2(hp, dest, CAR(list_val(nodesOutput)));
+            Eterm arg2 = TUPLE3(hp2, connect, tp[1], msg);
+            ret = erl_send(p, arg, arg2) || ret;
             nodesOutput = CDR(list_val(nodesOutput));
         }
         return ret;
-- 
1.7.7.5 (Apple Git-26)


From 8715f1458731dafe64f6f502d2e125c53101fdce Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Fri, 4 May 2012 16:45:02 +0200
Subject: [PATCH 05/12] Porting export table down below.

---
 erts/emulator/beam/bif.c     |   33 +
 erts/emulator/beam/bif.tab   |    9 +
 erts/emulator/beam/dist.c    | 3282 +++++++++++++++++++++---------------------
 erts/emulator/beam/pexport.c |  643 +++++++++
 erts/emulator/beam/pexport.h |   52 +
 5 files changed, 2379 insertions(+), 1640 deletions(-)
 create mode 100644 erts/emulator/beam/pexport.c
 create mode 100644 erts/emulator/beam/pexport.h

diff --git a/erts/emulator/beam/bif.c b/erts/emulator/beam/bif.c
index 2cc2da2..9f1aec9 100644
--- a/erts/emulator/beam/bif.c
+++ b/erts/emulator/beam/bif.c
@@ -4570,3 +4570,36 @@ BIF_RETTYPE get_module_info_2(BIF_ALIST_2)
     }
     BIF_RET(ret);
 }
+
+/* export(atom|Process) exports a process
+   (for this node) */
+
+BIF_RETTYPE export_1(BIF_ALIST_1)   /* (Atom|Pid)   */
+{
+    erts_printf("DEBUG: Exporting %T\n", BIF_ARG_1);
+    BIF_RET(am_true);
+}
+
+
+/**********************************************************************/
+
+/* removes the export of a process */
+
+BIF_RETTYPE unexport_1(BIF_ALIST_1)
+{
+    erts_printf("DEBUG: Unexporting %T\n", BIF_ARG_1);
+    BIF_RET(am_true);
+}
+
+/**********************************************************************/
+
+/* list all exported processes */
+
+BIF_RETTYPE exported_0(BIF_ALIST_0)
+{
+    Eterm* hp = HAlloc(BIF_P, 2);
+    erts_printf("DEBUG: Listing exported processes\n");
+    BIF_RET(CONS(hp, NIL, NIL));
+}
+
+/**********************************************************************/
diff --git a/erts/emulator/beam/bif.tab b/erts/emulator/beam/bif.tab
index 8cc568b..63b64be 100644
--- a/erts/emulator/beam/bif.tab
+++ b/erts/emulator/beam/bif.tab
@@ -817,3 +817,12 @@ bif erlang:posixtime_to_universaltime/1
 #
 
 bif erlang:hash/2
+
+#
+# New in ELIoT
+bif erlang:export/1
+bif 'erl.lang.node':export/1      ebif_export_1
+bif erlang:exported/0
+bif 'erl.lang.node':exported/0    ebif_exported_0
+bif erlang:unexport/1
+bif 'erl.lang.node':unexport/1    ebif_unexport_1
diff --git a/erts/emulator/beam/dist.c b/erts/emulator/beam/dist.c
index bee61e7..15754a7 100644
--- a/erts/emulator/beam/dist.c
+++ b/erts/emulator/beam/dist.c
@@ -68,26 +68,26 @@ dist_msg_dbg(ErtsDistExternal *edep, char *what, byte *buf, int sz)
     Eterm msg;
     Sint size = erts_decode_dist_ext_size(edep, 0);
     if (size < 0) {
-	erts_fprintf(stderr,
-		     "DIST MSG DEBUG: erts_decode_dist_ext_size(%s) failed:\n",
-		     what);
-	bw(buf, sz);
+        erts_fprintf(stderr,
+                "DIST MSG DEBUG: erts_decode_dist_ext_size(%s) failed:\n",
+                what);
+        bw(buf, sz);
     }
     else {
-	Eterm *hp;
-	ErlHeapFragment *mbuf = new_message_buffer(size);
-	hp = mbuf->mem;
-	msg = erts_decode_dist_ext(&hp, &mbuf->off_heap, edep);
-	if (is_value(msg))
-	    erts_fprintf(stderr, "    %s: %T\n", what, msg);
-	else {
-	    erts_fprintf(stderr,
-			 "DIST MSG DEBUG: erts_decode_dist_ext(%s) failed:\n",
-			 what);
-	    bw(buf, sz);
-	}
-	free_message_buffer(mbuf);
-	edep->extp = extp;
+        Eterm *hp;
+        ErlHeapFragment *mbuf = new_message_buffer(size);
+        hp = mbuf->mem;
+        msg = erts_decode_dist_ext(&hp, &mbuf->off_heap, edep);
+        if (is_value(msg))
+            erts_fprintf(stderr, "    %s: %T\n", what, msg);
+        else {
+            erts_fprintf(stderr,
+                    "DIST MSG DEBUG: erts_decode_dist_ext(%s) failed:\n",
+                    what);
+            bw(buf, sz);
+        }
+        free_message_buffer(mbuf);
+        edep->extp = extp;
     }
 }
 
@@ -128,9 +128,9 @@ static void
 delete_cache(ErtsAtomCache *cache)
 {
     if (cache) {
-	erts_free(ERTS_ALC_T_DCACHE, (void *) cache);
-	ASSERT(erts_smp_atomic_read_nob(&no_caches) > 0);
-	erts_smp_atomic_dec_nob(&no_caches);
+        erts_free(ERTS_ALC_T_DCACHE, (void *) cache);
+        ASSERT(erts_smp_atomic_read_nob(&no_caches) > 0);
+        erts_smp_atomic_dec_nob(&no_caches);
     }
 }
 
@@ -142,16 +142,16 @@ create_cache(DistEntry *dep)
     ErtsAtomCache *cp;
 
     ERTS_SMP_LC_ASSERT(
-	is_internal_port(dep->cid)
-	&& erts_lc_is_port_locked(&erts_port[internal_port_index(dep->cid)]));
+            is_internal_port(dep->cid)
+            && erts_lc_is_port_locked(&erts_port[internal_port_index(dep->cid)]));
     ASSERT(!dep->cache);
 
     dep->cache = cp = (ErtsAtomCache*) erts_alloc(ERTS_ALC_T_DCACHE,
-						  sizeof(ErtsAtomCache));
+            sizeof(ErtsAtomCache));
     erts_smp_atomic_inc_nob(&no_caches);
     for (i = 0; i < sizeof(cp->in_arr)/sizeof(cp->in_arr[0]); i++) {
-	cp->in_arr[i] = THE_NON_VALUE;
-	cp->out_arr[i] = THE_NON_VALUE;
+        cp->in_arr[i] = THE_NON_VALUE;
+        cp->out_arr[i] = THE_NON_VALUE;
     }
 }
 
@@ -166,78 +166,78 @@ get_suspended_on_de(DistEntry *dep, Uint32 unset_qflgs)
     ERTS_SMP_LC_ASSERT(erts_smp_lc_mtx_is_locked(&dep->qlock));
     dep->qflgs &= ~unset_qflgs;
     if (dep->qflgs & ERTS_DE_QFLG_EXIT) {
-	/* No resume when exit has been scheduled */
-	return NULL;
+        /* No resume when exit has been scheduled */
+        return NULL;
     }
     else {
-	ErtsProcList *plp;
-	plp = dep->suspended.first;
-	dep->suspended.first = NULL;
-	dep->suspended.last = NULL;
-	return plp;
+        ErtsProcList *plp;
+        plp = dep->suspended.first;
+        dep->suspended.first = NULL;
+        dep->suspended.last = NULL;
+        return plp;
     }
 }
 
 /*
-** A full node name constists of a "n@h"
-**
-** n must be a valid node name: string of ([a-z][A-Z][0-9]_-)+
-** 
-** h is not checked at all, we assume that we have a properly
-** configured machine where the networking is ok for the OS
-**
-** We do check that there is not a second @ in the string, since
-** many distributed operations are guaranteed not to work then.
-*/
+ ** A full node name constists of a "n@h"
+ **
+ ** n must be a valid node name: string of ([a-z][A-Z][0-9]_-)+
+ ** 
+ ** h is not checked at all, we assume that we have a properly
+ ** configured machine where the networking is ok for the OS
+ **
+ ** We do check that there is not a second @ in the string, since
+ ** many distributed operations are guaranteed not to work then.
+ */
 
 
 static int is_node_name(char *ptr, int len)
 {
-   int c = '\0';		/* suppress use-before-set warning */
-   int pos = 0;
+    int c = '\0';		/* suppress use-before-set warning */
+    int pos = 0;
 
-   while (pos < len) {
-      c = ptr[pos++];
-      if (! ((c == '-') || (c == '_') ||
-	     ((c >= 'a') && (c <= 'z')) ||
-	     ((c >= 'A') && (c <= 'Z')) ||
-	     ((c >= '0') && (c <= '9'))))
-	 break;
-   }
+    while (pos < len) {
+        c = ptr[pos++];
+        if (! ((c == '-') || (c == '_') ||
+                ((c >= 'a') && (c <= 'z')) ||
+                ((c >= 'A') && (c <= 'Z')) ||
+                ((c >= '0') && (c <= '9'))))
+            break;
+    }
 
-   /* Scanned past the host name: now we want to see a '@', and there
+    /* Scanned past the host name: now we want to see a '@', and there
       should be text both before and after it. */
-   if (c != '@' || pos < 2 || pos == len)
-      return 0;
+    if (c != '@' || pos < 2 || pos == len)
+        return 0;
 
-   while (pos < len) {
-      c = ptr[pos++];
-      if (c == '@')
-	 return 0;
-   }
+    while (pos < len) {
+        c = ptr[pos++];
+        if (c == '@')
+            return 0;
+    }
 
-   return 1;
+    return 1;
 }
 
 int is_node_name_atom(Eterm a)
 {
     int i;
     if(is_not_atom(a))
-	return 0;
+        return 0;
     i = atom_val(a);
     ASSERT((i > 0) && (i < atom_table_size()) &&  (atom_tab(i) != NULL));
     return is_node_name((char*)atom_tab(i)->name, atom_tab(i)->len);
 }
 
 typedef struct {
-    DistEntry *dep;
-    Eterm *lhp;
+        DistEntry *dep;
+        Eterm *lhp;
 } NetExitsContext;
 
 /* 
-** This function is called when a distribution 
-** port or process terminates
-*/
+ ** This function is called when a distribution 
+ ** port or process terminates
+ */
 static void doit_monitor_net_exits(ErtsMonitor *mon, void *vnecp)
 {
     Process *rp;
@@ -247,53 +247,53 @@ static void doit_monitor_net_exits(ErtsMonitor *mon, void *vnecp)
 
     rp = erts_pid2proc(NULL, 0, mon->pid, rp_locks);
     if (!rp)
-	goto done;
+        goto done;
 
     if (mon->type == MON_ORIGIN) {
-	/* local pid is beeing monitored */
-	rmon = erts_remove_monitor(&(rp->monitors),mon->ref);
-	/* ASSERT(rmon != NULL); nope, can happen during process exit */
-	if (rmon != NULL) {
-	    erts_destroy_monitor(rmon);
-	}
+        /* local pid is beeing monitored */
+        rmon = erts_remove_monitor(&(rp->monitors),mon->ref);
+        /* ASSERT(rmon != NULL); nope, can happen during process exit */
+        if (rmon != NULL) {
+            erts_destroy_monitor(rmon);
+        }
     } else {
-	DeclareTmpHeapNoproc(lhp,3);
-	Eterm watched;
-	UseTmpHeapNoproc(3);
-	ASSERT(mon->type == MON_TARGET);
-	rmon = erts_remove_monitor(&(rp->monitors),mon->ref);
-	/* ASSERT(rmon != NULL); can happen during process exit */
-	if (rmon != NULL) {
-	    ASSERT(is_atom(rmon->name) || is_nil(rmon->name));
-	    watched = (is_atom(rmon->name)
-		       ? TUPLE2(lhp, rmon->name, dep->sysname)
-		       : rmon->pid);
+        DeclareTmpHeapNoproc(lhp,3);
+        Eterm watched;
+        UseTmpHeapNoproc(3);
+        ASSERT(mon->type == MON_TARGET);
+        rmon = erts_remove_monitor(&(rp->monitors),mon->ref);
+        /* ASSERT(rmon != NULL); can happen during process exit */
+        if (rmon != NULL) {
+            ASSERT(is_atom(rmon->name) || is_nil(rmon->name));
+            watched = (is_atom(rmon->name)
+                    ? TUPLE2(lhp, rmon->name, dep->sysname)
+                            : rmon->pid);
 #ifdef ERTS_SMP
-	    rp_locks |= ERTS_PROC_LOCKS_MSG_SEND;
-	    erts_smp_proc_lock(rp, ERTS_PROC_LOCKS_MSG_SEND);
+            rp_locks |= ERTS_PROC_LOCKS_MSG_SEND;
+            erts_smp_proc_lock(rp, ERTS_PROC_LOCKS_MSG_SEND);
 #endif
-	    erts_queue_monitor_message(rp, &rp_locks, mon->ref, am_process, 
-				       watched, am_noconnection);
-	    erts_destroy_monitor(rmon);
-	}
-	UnUseTmpHeapNoproc(3);
+            erts_queue_monitor_message(rp, &rp_locks, mon->ref, am_process, 
+                    watched, am_noconnection);
+            erts_destroy_monitor(rmon);
+        }
+        UnUseTmpHeapNoproc(3);
     }
     erts_smp_proc_unlock(rp, rp_locks);
- done:
+    done:
     erts_destroy_monitor(mon);
 }
-	
+
 typedef struct {
-    NetExitsContext *necp;
-    ErtsLink *lnk;
+        NetExitsContext *necp;
+        ErtsLink *lnk;
 } LinkNetExitsContext;
 
 /* 
-** This is the function actually doing the job of sending exit messages
-** for links in a dist entry upon net_exit (the node goes down), NB,
-** only process links, not node monitors are handled here, 
-** they reside in a separate tree....
-*/
+ ** This is the function actually doing the job of sending exit messages
+ ** for links in a dist entry upon net_exit (the node goes down), NB,
+ ** only process links, not node monitors are handled here, 
+ ** they reside in a separate tree....
+ */
 static void doit_link_net_exits_sub(ErtsLink *sublnk, void *vlnecp)
 {
     ErtsLink *lnk = ((LinkNetExitsContext *) vlnecp)->lnk; /* the local pid */
@@ -302,47 +302,47 @@ static void doit_link_net_exits_sub(ErtsLink *sublnk, void *vlnecp)
 
     ASSERT(lnk->type == LINK_PID);
     if (is_internal_pid(lnk->pid)) {
-	int xres;
-	ErtsProcLocks rp_locks = ERTS_PROC_LOCK_LINK|ERTS_PROC_LOCKS_XSIG_SEND;
-
-	rp = erts_pid2proc(NULL, 0, lnk->pid, rp_locks);
-	if (!rp) {
-	    goto done;
-	}
-
-	rlnk = erts_remove_link(&(rp->nlinks), sublnk->pid);
-	xres = erts_send_exit_signal(NULL,
-				     sublnk->pid,
-				     rp,
-				     &rp_locks,
-				     am_noconnection,
-				     NIL,
-				     NULL,
-				     0);
-
-	if (rlnk) {
-	    erts_destroy_link(rlnk);
-	    if (xres >= 0 && IS_TRACED_FL(rp, F_TRACE_PROCS)) {
-		/* We didn't exit the process and it is traced */
-		trace_proc(NULL, rp, am_getting_unlinked, sublnk->pid);
-	    }
-	}
-	erts_smp_proc_unlock(rp, rp_locks);
-    }
- done:
+        int xres;
+        ErtsProcLocks rp_locks = ERTS_PROC_LOCK_LINK|ERTS_PROC_LOCKS_XSIG_SEND;
+
+        rp = erts_pid2proc(NULL, 0, lnk->pid, rp_locks);
+        if (!rp) {
+            goto done;
+        }
+
+        rlnk = erts_remove_link(&(rp->nlinks), sublnk->pid);
+        xres = erts_send_exit_signal(NULL,
+                sublnk->pid,
+                rp,
+                &rp_locks,
+                am_noconnection,
+                NIL,
+                NULL,
+                0);
+
+        if (rlnk) {
+            erts_destroy_link(rlnk);
+            if (xres >= 0 && IS_TRACED_FL(rp, F_TRACE_PROCS)) {
+                /* We didn't exit the process and it is traced */
+                trace_proc(NULL, rp, am_getting_unlinked, sublnk->pid);
+            }
+        }
+        erts_smp_proc_unlock(rp, rp_locks);
+    }
+    done:
     erts_destroy_link(sublnk);
 
 }
-    
+
 
 
 
 
 /* 
-** This function is called when a distribution 
-** port or process terminates, once for each link on the high level, 
-** it in turn traverses the link subtree for the specific link node...
-*/
+ ** This function is called when a distribution 
+ ** port or process terminates, once for each link on the high level, 
+ ** it in turn traverses the link subtree for the specific link node...
+ */
 static void doit_link_net_exits(ErtsLink *lnk, void *vnecp)
 {
     LinkNetExitsContext lnec = {(NetExitsContext *) vnecp, lnk};
@@ -364,32 +364,32 @@ static void doit_node_link_net_exits(ErtsLink *lnk, void *vnecp)
     Uint i,n;
     ASSERT(lnk->type == LINK_NODE)
     if (is_internal_pid(lnk->pid)) {
-	ErtsProcLocks rp_locks = ERTS_PROC_LOCK_LINK;
-	rp = erts_pid2proc(NULL, 0, lnk->pid, rp_locks);
-	if (!rp) {
-	    goto done;
-	}
-	rlnk = erts_remove_link(&(rp->nlinks), name);
-	if (rlnk != NULL) {
-	    ASSERT(is_atom(rlnk->pid) && (rlnk->type == LINK_NODE));
-	    erts_destroy_link(rlnk);
-	}
-	n = ERTS_LINK_REFC(lnk);
-	for (i = 0; i < n; ++i) {
-	    ErlHeapFragment* bp;
-	    ErlOffHeap *ohp;
-	    Eterm tup;
-	    Eterm *hp = erts_alloc_message_heap(3,&bp,&ohp,rp,&rp_locks);
-	    tup = TUPLE2(hp, am_nodedown, name);
-	    erts_queue_message(rp, &rp_locks, bp, tup, NIL);
-	}
-	erts_smp_proc_unlock(rp, rp_locks);
-    }
- done:
+        ErtsProcLocks rp_locks = ERTS_PROC_LOCK_LINK;
+        rp = erts_pid2proc(NULL, 0, lnk->pid, rp_locks);
+        if (!rp) {
+            goto done;
+        }
+        rlnk = erts_remove_link(&(rp->nlinks), name);
+        if (rlnk != NULL) {
+            ASSERT(is_atom(rlnk->pid) && (rlnk->type == LINK_NODE));
+            erts_destroy_link(rlnk);
+        }
+        n = ERTS_LINK_REFC(lnk);
+        for (i = 0; i < n; ++i) {
+            ErlHeapFragment* bp;
+            ErlOffHeap *ohp;
+            Eterm tup;
+            Eterm *hp = erts_alloc_message_heap(3,&bp,&ohp,rp,&rp_locks);
+            tup = TUPLE2(hp, am_nodedown, name);
+            erts_queue_message(rp, &rp_locks, bp, tup, NIL);
+        }
+        erts_smp_proc_unlock(rp, rp_locks);
+    }
+    done:
     erts_destroy_link(lnk);
 }
 
-	
+
 /*
  * proc is currently running or exiting process.
  */
@@ -398,104 +398,104 @@ int erts_do_net_exits(DistEntry *dep, Eterm reason)
     Eterm nodename;
 
     if (dep == erts_this_dist_entry) {  /* Net kernel has died (clean up!!) */
-	Eterm nd_reason = (reason == am_no_network
-			   ? am_no_network
-			   : am_net_kernel_terminated);
-	erts_smp_rwmtx_rwlock(&erts_dist_table_rwmtx);
-
-	/* KILL all port controllers */
-	while(erts_visible_dist_entries || erts_hidden_dist_entries) {
-	    DistEntry *tdep;
-	    Eterm prt_id;
-	    Port *prt;
-	    if(erts_hidden_dist_entries)
-		tdep = erts_hidden_dist_entries;
-	    else
-		tdep = erts_visible_dist_entries;
-	    prt_id = tdep->cid;
-	    ASSERT(is_internal_port(prt_id));
-	    erts_smp_rwmtx_rwunlock(&erts_dist_table_rwmtx);
-
-	    prt = erts_id2port(prt_id, NULL, 0);
-	    if (prt) {
-		ASSERT(prt->status & ERTS_PORT_SFLG_DISTRIBUTION);
-		ASSERT(prt->dist_entry);
-		/* will call do_net_exists !!! */
-		erts_do_exit_port(prt, prt_id, nd_reason);
-		erts_port_release(prt);
-	    }
-
-	    erts_smp_rwmtx_rwlock(&erts_dist_table_rwmtx);
-	}
-
-	erts_smp_rwmtx_rwunlock(&erts_dist_table_rwmtx);
-
-	nodename = erts_this_dist_entry->sysname;
-	erts_smp_thr_progress_block();
-	erts_set_this_node(am_Noname, 0);
-	erts_is_alive = 0;
-	send_nodes_mon_msgs(NULL, am_nodedown, nodename, am_visible, nd_reason);
-	erts_smp_thr_progress_unblock();
+        Eterm nd_reason = (reason == am_no_network
+                ? am_no_network
+                        : am_net_kernel_terminated);
+        erts_smp_rwmtx_rwlock(&erts_dist_table_rwmtx);
+
+        /* KILL all port controllers */
+        while(erts_visible_dist_entries || erts_hidden_dist_entries) {
+            DistEntry *tdep;
+            Eterm prt_id;
+            Port *prt;
+            if(erts_hidden_dist_entries)
+                tdep = erts_hidden_dist_entries;
+            else
+                tdep = erts_visible_dist_entries;
+            prt_id = tdep->cid;
+            ASSERT(is_internal_port(prt_id));
+            erts_smp_rwmtx_rwunlock(&erts_dist_table_rwmtx);
+
+            prt = erts_id2port(prt_id, NULL, 0);
+            if (prt) {
+                ASSERT(prt->status & ERTS_PORT_SFLG_DISTRIBUTION);
+                ASSERT(prt->dist_entry);
+                /* will call do_net_exists !!! */
+                erts_do_exit_port(prt, prt_id, nd_reason);
+                erts_port_release(prt);
+            }
+
+            erts_smp_rwmtx_rwlock(&erts_dist_table_rwmtx);
+        }
+
+        erts_smp_rwmtx_rwunlock(&erts_dist_table_rwmtx);
+
+        nodename = erts_this_dist_entry->sysname;
+        erts_smp_thr_progress_block();
+        erts_set_this_node(am_Noname, 0);
+        erts_is_alive = 0;
+        send_nodes_mon_msgs(NULL, am_nodedown, nodename, am_visible, nd_reason);
+        erts_smp_thr_progress_unblock();
 
     }
     else { /* recursive call via erts_do_exit_port() will end up here */
-	NetExitsContext nec = {dep};
-	ErtsLink *nlinks;
-	ErtsLink *node_links;
-	ErtsMonitor *monitors;
-	Uint32 flags;
+        NetExitsContext nec = {dep};
+        ErtsLink *nlinks;
+        ErtsLink *node_links;
+        ErtsMonitor *monitors;
+        Uint32 flags;
 
-	erts_smp_atomic_set_mb(&dep->dist_cmd_scheduled, 1);
-	erts_smp_de_rwlock(dep);
+        erts_smp_atomic_set_mb(&dep->dist_cmd_scheduled, 1);
+        erts_smp_de_rwlock(dep);
 
-	ERTS_SMP_LC_ASSERT(is_internal_port(dep->cid)
-			   && erts_lc_is_port_locked(&erts_port[internal_port_index(dep->cid)]));
+        ERTS_SMP_LC_ASSERT(is_internal_port(dep->cid)
+                && erts_lc_is_port_locked(&erts_port[internal_port_index(dep->cid)]));
 
-	if (erts_port_task_is_scheduled(&dep->dist_cmd))
-	    erts_port_task_abort(dep->cid, &dep->dist_cmd);
+        if (erts_port_task_is_scheduled(&dep->dist_cmd))
+            erts_port_task_abort(dep->cid, &dep->dist_cmd);
 
-	if (dep->status & ERTS_DE_SFLG_EXITING) {
+        if (dep->status & ERTS_DE_SFLG_EXITING) {
 #ifdef DEBUG
-	    erts_smp_mtx_lock(&dep->qlock);
-	    ASSERT(dep->qflgs & ERTS_DE_QFLG_EXIT);
-	    erts_smp_mtx_unlock(&dep->qlock);
+            erts_smp_mtx_lock(&dep->qlock);
+            ASSERT(dep->qflgs & ERTS_DE_QFLG_EXIT);
+            erts_smp_mtx_unlock(&dep->qlock);
 #endif
-	}
-	else {
-	    dep->status |= ERTS_DE_SFLG_EXITING;
-	    erts_smp_mtx_lock(&dep->qlock);
-	    ASSERT(!(dep->qflgs & ERTS_DE_QFLG_EXIT));
-	    dep->qflgs |= ERTS_DE_QFLG_EXIT;
-	    erts_smp_mtx_unlock(&dep->qlock);
-	}
-
-	erts_smp_de_links_lock(dep);
-	monitors	= dep->monitors;
+        }
+        else {
+            dep->status |= ERTS_DE_SFLG_EXITING;
+            erts_smp_mtx_lock(&dep->qlock);
+            ASSERT(!(dep->qflgs & ERTS_DE_QFLG_EXIT));
+            dep->qflgs |= ERTS_DE_QFLG_EXIT;
+            erts_smp_mtx_unlock(&dep->qlock);
+        }
+
+        erts_smp_de_links_lock(dep);
+        monitors	= dep->monitors;
         nlinks		= dep->nlinks;
-	node_links	= dep->node_links;
-	dep->monitors	= NULL;
+        node_links	= dep->node_links;
+        dep->monitors	= NULL;
         dep->nlinks	= NULL;
-	dep->node_links	= NULL;
-	erts_smp_de_links_unlock(dep);
+        dep->node_links	= NULL;
+        erts_smp_de_links_unlock(dep);
 
-	nodename = dep->sysname;
-	flags = dep->flags;
+        nodename = dep->sysname;
+        flags = dep->flags;
 
-	erts_set_dist_entry_not_connected(dep);
+        erts_set_dist_entry_not_connected(dep);
 
-	erts_smp_de_rwunlock(dep);
+        erts_smp_de_rwunlock(dep);
 
-	erts_sweep_monitors(monitors, &doit_monitor_net_exits, (void *) &nec);
-	erts_sweep_links(nlinks, &doit_link_net_exits, (void *) &nec);
-	erts_sweep_links(node_links, &doit_node_link_net_exits, (void *) &nec);
+        erts_sweep_monitors(monitors, &doit_monitor_net_exits, (void *) &nec);
+        erts_sweep_links(nlinks, &doit_link_net_exits, (void *) &nec);
+        erts_sweep_links(node_links, &doit_node_link_net_exits, (void *) &nec);
 
-	send_nodes_mon_msgs(NULL,
-			    am_nodedown,
-			    nodename,
-			    flags & DFLAG_PUBLISHED ? am_visible : am_hidden,
-			    reason == am_normal ? am_connection_closed : reason);
+        send_nodes_mon_msgs(NULL,
+                am_nodedown,
+                nodename,
+                flags & DFLAG_PUBLISHED ? am_visible : am_hidden,
+                        reason == am_normal ? am_connection_closed : reason);
 
-	clear_dist_entry(dep);
+        clear_dist_entry(dep);
 
     }
     return 1;
@@ -526,7 +526,7 @@ void init_dist(void)
 }
 
 #define ErtsDistOutputBuf2Binary(OB) \
-  ((Binary *) (((char *) (OB)) - offsetof(Binary, orig_bytes)))
+        ((Binary *) (((char *) (OB)) - offsetof(Binary, orig_bytes)))
 
 static ERTS_INLINE ErtsDistOutputBuf *
 alloc_dist_obuf(Uint size)
@@ -551,7 +551,7 @@ free_dist_obuf(ErtsDistOutputBuf *obuf)
     Binary *bin = ErtsDistOutputBuf2Binary(obuf);
     ASSERT(obuf->dbg_pattern == ERTS_DIST_OUTPUT_BUF_DBG_PATTERN);
     if (erts_refc_dectest(&bin->refc, 0) == 0)
-	erts_bin_free(bin);
+        erts_bin_free(bin);
 }
 
 static ERTS_INLINE Sint
@@ -583,10 +583,10 @@ static void clear_dist_entry(DistEntry *dep)
     erts_smp_mtx_lock(&dep->qlock);
 
     if (!dep->out_queue.last)
-	obuf = dep->finalized_out_queue.first;
+        obuf = dep->finalized_out_queue.first;
     else {
-	dep->out_queue.last->next = dep->finalized_out_queue.first;
-	obuf = dep->out_queue.first;
+        dep->out_queue.last->next = dep->finalized_out_queue.first;
+        obuf = dep->out_queue.first;
     }
 
     dep->out_queue.first = NULL;
@@ -606,18 +606,18 @@ static void clear_dist_entry(DistEntry *dep)
     delete_cache(cache);
 
     while (obuf) {
-	ErtsDistOutputBuf *fobuf;
-	fobuf = obuf;
-	obuf = obuf->next;
-	obufsize += size_obuf(fobuf);
-	free_dist_obuf(fobuf);
+        ErtsDistOutputBuf *fobuf;
+        fobuf = obuf;
+        obuf = obuf->next;
+        obufsize += size_obuf(fobuf);
+        free_dist_obuf(fobuf);
     }
 
     if (obufsize) {
-	erts_smp_mtx_lock(&dep->qlock);
-	ASSERT(dep->qsize >= obufsize);
-	dep->qsize -= obufsize;
-	erts_smp_mtx_unlock(&dep->qlock);
+        erts_smp_mtx_lock(&dep->qlock);
+        ASSERT(dep->qsize >= obufsize);
+        dep->qsize -= obufsize;
+        erts_smp_mtx_unlock(&dep->qlock);
     }
 }
 
@@ -633,8 +633,8 @@ static void clear_dist_entry(DistEntry *dep)
  */
 
 /*
-** Send a DOP_LINK link message
-*/
+ ** Send a DOP_LINK link message
+ */
 int
 erts_dsig_send_link(ErtsDSigData *dsdp, Eterm local, Eterm remote)
 {
@@ -667,7 +667,7 @@ erts_dsig_send_unlink(ErtsDSigData *dsdp, Eterm local, Eterm remote)
    which is rather sad as only the ref is needed, no pid's... */
 int
 erts_dsig_send_m_exit(ErtsDSigData *dsdp, Eterm watcher, Eterm watched, 
-			  Eterm ref, Eterm reason)
+        Eterm ref, Eterm reason)
 {
     Eterm ctl;
     DeclareTmpHeapNoproc(ctl_heap,6);
@@ -676,7 +676,7 @@ erts_dsig_send_m_exit(ErtsDSigData *dsdp, Eterm watcher, Eterm watched,
     UseTmpHeapNoproc(6);
 
     ctl = TUPLE5(&ctl_heap[0], make_small(DOP_MONITOR_P_EXIT),
-		 watched, watcher, ref, reason);
+            watched, watcher, ref, reason);
 
 #ifdef DEBUG
     erts_smp_de_links_lock(dsdp->dep);
@@ -694,7 +694,7 @@ erts_dsig_send_m_exit(ErtsDSigData *dsdp, Eterm watcher, Eterm watched,
    needed on the other side... */
 int
 erts_dsig_send_monitor(ErtsDSigData *dsdp, Eterm watcher, Eterm watched,
-		       Eterm ref)
+        Eterm ref)
 {
     Eterm ctl;
     DeclareTmpHeapNoproc(ctl_heap,5);
@@ -702,8 +702,8 @@ erts_dsig_send_monitor(ErtsDSigData *dsdp, Eterm watcher, Eterm watched,
 
     UseTmpHeapNoproc(5);
     ctl = TUPLE4(&ctl_heap[0],
-		 make_small(DOP_MONITOR_P),
-		 watcher, watched, ref);
+            make_small(DOP_MONITOR_P),
+            watcher, watched, ref);
 
     res = dsig_send(dsdp, ctl, THE_NON_VALUE, 0);
     UnUseTmpHeapNoproc(5);
@@ -716,7 +716,7 @@ erts_dsig_send_monitor(ErtsDSigData *dsdp, Eterm watcher, Eterm watched,
    rather redundant as only the ref will be needed on the other side... */
 int
 erts_dsig_send_demonitor(ErtsDSigData *dsdp, Eterm watcher,
-			 Eterm watched, Eterm ref, int force)
+        Eterm watched, Eterm ref, int force)
 {
     Eterm ctl;
     DeclareTmpHeapNoproc(ctl_heap,5);
@@ -724,8 +724,8 @@ erts_dsig_send_demonitor(ErtsDSigData *dsdp, Eterm watcher,
 
     UseTmpHeapNoproc(5);
     ctl = TUPLE4(&ctl_heap[0],
-		 make_small(DOP_DEMONITOR_P),
-		 watcher, watched, ref);
+            make_small(DOP_DEMONITOR_P),
+            watcher, watched, ref);
 
     res = dsig_send(dsdp, ctl, THE_NON_VALUE, force);
     UnUseTmpHeapNoproc(5);
@@ -743,16 +743,16 @@ erts_dsig_send_msg(ErtsDSigData *dsdp, Eterm remote, Eterm message)
 
     UseTmpHeapNoproc(5);
     if (SEQ_TRACE_TOKEN(sender) != NIL) {
-	seq_trace_update_send(sender);
-	token = SEQ_TRACE_TOKEN(sender);
-	seq_trace_output(token, message, SEQ_TRACE_SEND, remote, sender);
+        seq_trace_update_send(sender);
+        token = SEQ_TRACE_TOKEN(sender);
+        seq_trace_output(token, message, SEQ_TRACE_SEND, remote, sender);
     }
 
     if (token != NIL)
-	ctl = TUPLE4(&ctl_heap[0],
-		     make_small(DOP_SEND_TT), am_Cookie, remote, token);
+        ctl = TUPLE4(&ctl_heap[0],
+                make_small(DOP_SEND_TT), am_Cookie, remote, token);
     else
-	ctl = TUPLE3(&ctl_heap[0], make_small(DOP_SEND), am_Cookie, remote);
+        ctl = TUPLE3(&ctl_heap[0], make_small(DOP_SEND), am_Cookie, remote);
     res = dsig_send(dsdp, ctl, message, 0);
     UnUseTmpHeapNoproc(5);
     return res;
@@ -769,17 +769,17 @@ erts_dsig_send_reg_msg(ErtsDSigData *dsdp, Eterm remote_name, Eterm message)
 
     UseTmpHeapNoproc(6);
     if (SEQ_TRACE_TOKEN(sender) != NIL) {
-	seq_trace_update_send(sender);
-	token = SEQ_TRACE_TOKEN(sender);
-	seq_trace_output(token, message, SEQ_TRACE_SEND, remote_name, sender);
+        seq_trace_update_send(sender);
+        token = SEQ_TRACE_TOKEN(sender);
+        seq_trace_output(token, message, SEQ_TRACE_SEND, remote_name, sender);
     }
 
     if (token != NIL)
-	ctl = TUPLE5(&ctl_heap[0], make_small(DOP_REG_SEND_TT),
-		     sender->id, am_Cookie, remote_name, token);
+        ctl = TUPLE5(&ctl_heap[0], make_small(DOP_REG_SEND_TT),
+                sender->id, am_Cookie, remote_name, token);
     else
-	ctl = TUPLE4(&ctl_heap[0], make_small(DOP_REG_SEND),
-		     sender->id, am_Cookie, remote_name);
+        ctl = TUPLE4(&ctl_heap[0], make_small(DOP_REG_SEND),
+                sender->id, am_Cookie, remote_name);
     res = dsig_send(dsdp, ctl, message, 0);
     UnUseTmpHeapNoproc(6);
     return res;
@@ -788,7 +788,7 @@ erts_dsig_send_reg_msg(ErtsDSigData *dsdp, Eterm remote_name, Eterm message)
 /* local has died, deliver the exit signal to remote */
 int
 erts_dsig_send_exit_tt(ErtsDSigData *dsdp, Eterm local, Eterm remote, 
-		       Eterm reason, Eterm token)
+        Eterm reason, Eterm token)
 {
     Eterm ctl;
     DeclareTmpHeapNoproc(ctl_heap,6);
@@ -796,12 +796,12 @@ erts_dsig_send_exit_tt(ErtsDSigData *dsdp, Eterm local, Eterm remote,
 
     UseTmpHeapNoproc(6);
     if (token != NIL) {	
-	seq_trace_update_send(dsdp->proc);
-	seq_trace_output_exit(token, reason, SEQ_TRACE_SEND, remote, local);
-	ctl = TUPLE5(&ctl_heap[0],
-		     make_small(DOP_EXIT_TT), local, remote, token, reason);
+        seq_trace_update_send(dsdp->proc);
+        seq_trace_output_exit(token, reason, SEQ_TRACE_SEND, remote, local);
+        ctl = TUPLE5(&ctl_heap[0],
+                make_small(DOP_EXIT_TT), local, remote, token, reason);
     } else {
-	ctl = TUPLE4(&ctl_heap[0], make_small(DOP_EXIT), local, remote, reason);
+        ctl = TUPLE4(&ctl_heap[0], make_small(DOP_EXIT), local, remote, reason);
     }
     /* forced, i.e ignore busy */
     res = dsig_send(dsdp, ctl, THE_NON_VALUE, 1);
@@ -818,7 +818,7 @@ erts_dsig_send_exit(ErtsDSigData *dsdp, Eterm local, Eterm remote, Eterm reason)
 
     UseTmpHeapNoproc(5);
     ctl = TUPLE4(&ctl_heap[0],
-		 make_small(DOP_EXIT), local, remote, reason);
+            make_small(DOP_EXIT), local, remote, reason);
     /* forced, i.e ignore busy */
     res =  dsig_send(dsdp, ctl, THE_NON_VALUE, 1);
     UnUseTmpHeapNoproc(5);
@@ -834,7 +834,7 @@ erts_dsig_send_exit2(ErtsDSigData *dsdp, Eterm local, Eterm remote, Eterm reason
 
     UseTmpHeapNoproc(5);
     ctl = TUPLE4(&ctl_heap[0],
-		 make_small(DOP_EXIT2), local, remote, reason);
+            make_small(DOP_EXIT2), local, remote, reason);
 
     res = dsig_send(dsdp, ctl, THE_NON_VALUE, 0);
     UnUseTmpHeapNoproc(5);
@@ -851,7 +851,7 @@ erts_dsig_send_group_leader(ErtsDSigData *dsdp, Eterm leader, Eterm remote)
 
     UseTmpHeapNoproc(4);
     ctl = TUPLE3(&ctl_heap[0],
-		 make_small(DOP_GROUP_LEADER), leader, remote);
+            make_small(DOP_GROUP_LEADER), leader, remote);
 
     res = dsig_send(dsdp, ctl, THE_NON_VALUE, 0);
     UnUseTmpHeapNoproc(4);
@@ -860,7 +860,7 @@ erts_dsig_send_group_leader(ErtsDSigData *dsdp, Eterm leader, Eterm remote)
 
 #if defined(PURIFY)
 #  define PURIFY_MSG(msg) \
-    purify_printf("%s, line %d: %s", __FILE__, __LINE__, msg)
+        purify_printf("%s, line %d: %s", __FILE__, __LINE__, msg)
 #elif defined(VALGRIND)
 #include <valgrind/valgrind.h>
 #include <valgrind/memcheck.h>
@@ -870,36 +870,36 @@ erts_dsig_send_group_leader(ErtsDSigData *dsdp, Eterm leader, Eterm remote)
 #endif
 
 #  define PURIFY_MSG(msg)                                                \
-    do {								 \
-	char buf__[1]; size_t bufsz__ = sizeof(buf__);			 \
-	if (erts_sys_getenv("VALGRIND_LOG_XML", buf__, &bufsz__) >= 0) { \
-	    VALGRIND_PRINTF_XML("<erlang_error_log>"			 \
-			    "%s, line %d: %s</erlang_error_log>\n",	 \
-			    __FILE__, __LINE__, msg);			 \
-	} else {							 \
-	    VALGRIND_PRINTF("%s, line %d: %s", __FILE__, __LINE__, msg); \
-	}								 \
-    } while (0)
+        do {								 \
+            char buf__[1]; size_t bufsz__ = sizeof(buf__);			 \
+            if (erts_sys_getenv("VALGRIND_LOG_XML", buf__, &bufsz__) >= 0) { \
+                VALGRIND_PRINTF_XML("<erlang_error_log>"			 \
+                        "%s, line %d: %s</erlang_error_log>\n",	 \
+                        __FILE__, __LINE__, msg);			 \
+            } else {							 \
+                VALGRIND_PRINTF("%s, line %d: %s", __FILE__, __LINE__, msg); \
+            }								 \
+        } while (0)
 #else
 #  define PURIFY_MSG(msg)
 #endif
 
 /*
-** Input from distribution port.
-**  Input follows the distribution protocol v4.5
-**  
-**   The protocol is a 4 byte header protocol
-**   the DOP_DATA is stripped by driver_output
-**
-**   assert  hlen == 0 !!!
-*/
+ ** Input from distribution port.
+ **  Input follows the distribution protocol v4.5
+ **  
+ **   The protocol is a 4 byte header protocol
+ **   the DOP_DATA is stripped by driver_output
+ **
+ **   assert  hlen == 0 !!!
+ */
 
 int erts_net_message(Port *prt,
-		     DistEntry *dep,
-		     byte *hbuf,
-		     ErlDrvSizeT hlen,
-		     byte *buf,
-		     ErlDrvSizeT len)
+        DistEntry *dep,
+        byte *hbuf,
+        ErlDrvSizeT hlen,
+        byte *buf,
+        ErlDrvSizeT len)
 {
 #define DIST_CTL_DEFAULT_SIZE 64
     ErtsDistExternal ede;
@@ -937,14 +937,14 @@ int erts_net_message(Port *prt,
     ERTS_SMP_LC_ASSERT(erts_lc_is_port_locked(prt));
 
     if (!erts_is_alive) {
-	UnUseTmpHeapNoproc(DIST_CTL_DEFAULT_SIZE);
-	return 0;
+        UnUseTmpHeapNoproc(DIST_CTL_DEFAULT_SIZE);
+        return 0;
     }
     if (hlen != 0)
-	goto data_error;
+        goto data_error;
     if (len == 0) {  /* HANDLE TICK !!! */
-	UnUseTmpHeapNoproc(DIST_CTL_DEFAULT_SIZE);
-	return 0;
+        UnUseTmpHeapNoproc(DIST_CTL_DEFAULT_SIZE);
+        return 0;
     }
 
 #ifdef ERTS_RAW_DIST_MSG_DBG
@@ -953,52 +953,52 @@ int erts_net_message(Port *prt,
 #endif
 
     if (dep->flags & DFLAG_DIST_HDR_ATOM_CACHE)
-	t = buf;
+        t = buf;
     else {
-	/* Skip PASS_THROUGH */
-	t = buf+1;
-	len--;
+        /* Skip PASS_THROUGH */
+        t = buf+1;
+        len--;
     }
 
     if (len == 0) {
-	PURIFY_MSG("data error");
-	goto data_error;
+        PURIFY_MSG("data error");
+        goto data_error;
     }
 
     res = erts_prepare_dist_ext(&ede, t, len, dep, dep->cache);
 
     if (res >= 0)
-	res = ctl_len = erts_decode_dist_ext_size(&ede);
+        res = ctl_len = erts_decode_dist_ext_size(&ede);
     else {
 #ifdef ERTS_DIST_MSG_DBG
-	erts_fprintf(stderr, "DIST MSG DEBUG: erts_prepare_dist_ext() failed:\n");
-	bw(buf, orig_len);
+        erts_fprintf(stderr, "DIST MSG DEBUG: erts_prepare_dist_ext() failed:\n");
+        bw(buf, orig_len);
 #endif
-	ctl_len = 0;
+        ctl_len = 0;
     }
 
     if (res < 0) {
 #ifdef ERTS_DIST_MSG_DBG
-	erts_fprintf(stderr, "DIST MSG DEBUG: erts_decode_dist_ext_size(CTL) failed:\n");
-	bw(buf, orig_len);
+        erts_fprintf(stderr, "DIST MSG DEBUG: erts_decode_dist_ext_size(CTL) failed:\n");
+        bw(buf, orig_len);
 #endif
-	PURIFY_MSG("data error");
-	goto data_error;
+        PURIFY_MSG("data error");
+        goto data_error;
     }
 
     if (ctl_len > DIST_CTL_DEFAULT_SIZE) {
-	ctl = erts_alloc(ERTS_ALC_T_DCTRL_BUF, ctl_len * sizeof(Eterm));
+        ctl = erts_alloc(ERTS_ALC_T_DCTRL_BUF, ctl_len * sizeof(Eterm));
     }
     hp = ctl;
 
     arg = erts_decode_dist_ext(&hp, &off_heap, &ede);
     if (is_non_value(arg)) {
 #ifdef ERTS_DIST_MSG_DBG
-	erts_fprintf(stderr, "DIST MSG DEBUG: erts_dist_ext_size(CTL) failed:\n");
-	bw(buf, orig_len);
+        erts_fprintf(stderr, "DIST MSG DEBUG: erts_dist_ext_size(CTL) failed:\n");
+        bw(buf, orig_len);
 #endif
-	PURIFY_MSG("data error");
-	goto data_error;
+        PURIFY_MSG("data error");
+        goto data_error;
     }
     ctl_len = t - buf;
 
@@ -1007,502 +1007,504 @@ int erts_net_message(Port *prt,
 #endif
 
     if (is_not_tuple(arg) || 
-	(tuple = tuple_val(arg), (tuple_arity = arityval(*tuple)) < 1) ||
-	is_not_small(tuple[1])) {
- 	goto invalid_message;
+            (tuple = tuple_val(arg), (tuple_arity = arityval(*tuple)) < 1) ||
+            is_not_small(tuple[1])) {
+        goto invalid_message;
     }
 
     token_size = 0;
 
     switch (type = unsigned_val(tuple[1])) {
-    case DOP_LINK:
-	if (tuple_arity != 3) {
-	    goto invalid_message;
-	}
-	from = tuple[2];
-	to   = tuple[3];  /* local proc to link to */
-
-	if (is_not_pid(from) || is_not_pid(to)) {
-	    goto invalid_message;
-	}
-
-	rp = erts_pid2proc_opt(NULL, 0,
-			       to, ERTS_PROC_LOCK_LINK,
-			       ERTS_P2P_FLG_ALLOW_OTHER_X);
-	if (!rp) {
-	    /* This is tricky (we MUST force a distributed send) */
-	    ErtsDSigData dsd;
-	    int code;
-	    code = erts_dsig_prepare(&dsd, dep, NULL, ERTS_DSP_NO_LOCK, 0);
-	    if (code == ERTS_DSIG_PREP_CONNECTED) {
-		code = erts_dsig_send_exit(&dsd, to, from, am_noproc);
-		ASSERT(code == ERTS_DSIG_SEND_OK);
-	    }
-	    break;
-	}
-
-	erts_smp_de_links_lock(dep);
-	res = erts_add_link(&(rp->nlinks), LINK_PID, from);
-
-	if (res < 0) {
-	    /* It was already there! Lets skip the rest... */
-	    erts_smp_de_links_unlock(dep);
-	    erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_LINK);
-	    break;
-	}
-	lnk = erts_add_or_lookup_link(&(dep->nlinks), LINK_PID, rp->id);
-	erts_add_link(&(ERTS_LINK_ROOT(lnk)), LINK_PID, from);
-	erts_smp_de_links_unlock(dep);
-
-	if (IS_TRACED_FL(rp, F_TRACE_PROCS))
-	    trace_proc(NULL, rp, am_getting_linked, from);
-
-	erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_LINK);
-	break;
-
-    case DOP_UNLINK: {
-	ErtsDistLinkData dld;
-	if (tuple_arity != 3) {
-	    goto invalid_message;
-	}
-	from = tuple[2];
-	to = tuple[3];
-	if (is_not_pid(from) || is_not_pid(to)) {
-	    goto invalid_message;
-	}
-	
-	rp = erts_pid2proc_opt(NULL, 0,
-			       to, ERTS_PROC_LOCK_LINK,
-			       ERTS_P2P_FLG_ALLOW_OTHER_X);
-	if (!rp)
-	    break;
-
-	lnk = erts_remove_link(&(rp->nlinks), from);
-
-	if (IS_TRACED_FL(rp, F_TRACE_PROCS) && lnk != NULL) {
-	    trace_proc(NULL, rp, am_getting_unlinked, from);
-	}
-
-	erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_LINK);
-
-	erts_remove_dist_link(&dld, to, from, dep);
-	erts_destroy_dist_link(&dld);
-	if (lnk)
-	    erts_destroy_link(lnk);
-	break;
-    }
-    
-    case DOP_MONITOR_P: {
-	/* A remote process wants to monitor us, we get:
+        case DOP_LINK:
+            if (tuple_arity != 3) {
+                goto invalid_message;
+            }
+            from = tuple[2];
+            to   = tuple[3];  /* local proc to link to */
+
+            if (is_not_pid(from) || is_not_pid(to)) {
+                goto invalid_message;
+            }
+
+            rp = erts_pid2proc_opt(NULL, 0,
+                    to, ERTS_PROC_LOCK_LINK,
+                    ERTS_P2P_FLG_ALLOW_OTHER_X);
+            if (!rp) {
+                /* This is tricky (we MUST force a distributed send) */
+                ErtsDSigData dsd;
+                int code;
+                code = erts_dsig_prepare(&dsd, dep, NULL, ERTS_DSP_NO_LOCK, 0);
+                if (code == ERTS_DSIG_PREP_CONNECTED) {
+                    code = erts_dsig_send_exit(&dsd, to, from, am_noproc);
+                    ASSERT(code == ERTS_DSIG_SEND_OK);
+                }
+                break;
+            }
+
+            erts_smp_de_links_lock(dep);
+            res = erts_add_link(&(rp->nlinks), LINK_PID, from);
+
+            if (res < 0) {
+                /* It was already there! Lets skip the rest... */
+                erts_smp_de_links_unlock(dep);
+                erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_LINK);
+                break;
+            }
+            lnk = erts_add_or_lookup_link(&(dep->nlinks), LINK_PID, rp->id);
+            erts_add_link(&(ERTS_LINK_ROOT(lnk)), LINK_PID, from);
+            erts_smp_de_links_unlock(dep);
+
+            if (IS_TRACED_FL(rp, F_TRACE_PROCS))
+                trace_proc(NULL, rp, am_getting_linked, from);
+
+            erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_LINK);
+            break;
+
+        case DOP_UNLINK: {
+            ErtsDistLinkData dld;
+            if (tuple_arity != 3) {
+                goto invalid_message;
+            }
+            from = tuple[2];
+            to = tuple[3];
+            if (is_not_pid(from) || is_not_pid(to)) {
+                goto invalid_message;
+            }
+
+            rp = erts_pid2proc_opt(NULL, 0,
+                    to, ERTS_PROC_LOCK_LINK,
+                    ERTS_P2P_FLG_ALLOW_OTHER_X);
+            if (!rp)
+                break;
+
+            lnk = erts_remove_link(&(rp->nlinks), from);
+
+            if (IS_TRACED_FL(rp, F_TRACE_PROCS) && lnk != NULL) {
+                trace_proc(NULL, rp, am_getting_unlinked, from);
+            }
+
+            erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_LINK);
+
+            erts_remove_dist_link(&dld, to, from, dep);
+            erts_destroy_dist_link(&dld);
+            if (lnk)
+                erts_destroy_link(lnk);
+            break;
+        }
+
+        case DOP_MONITOR_P: {
+            /* A remote process wants to monitor us, we get:
 	   {DOP_MONITOR_P, Remote pid, local pid or name, ref} */
-	Eterm name;
-	
-	if (tuple_arity != 4) {
-	    goto invalid_message;
-	}
-
-	watcher = tuple[2];
-	watched = tuple[3];  /* local proc to monitor */
-	ref     = tuple[4];
-
-	if (is_not_ref(ref)) {
-	    goto invalid_message;
-	}
-
-	if (is_atom(watched)) {
-	    name = watched;
-	    rp = erts_whereis_process(NULL, 0,
-				      watched, ERTS_PROC_LOCK_LINK,
-				      ERTS_P2P_FLG_ALLOW_OTHER_X);
-	}
-	else {
-	    name = NIL;
-	    rp = erts_pid2proc_opt(NULL, 0,
-				   watched, ERTS_PROC_LOCK_LINK,
-				   ERTS_P2P_FLG_ALLOW_OTHER_X);
-	}
-
-	if (!rp) {
-	    ErtsDSigData dsd;
-	    int code;
-	    code = erts_dsig_prepare(&dsd, dep, NULL, ERTS_DSP_NO_LOCK, 0);
-	    if (code == ERTS_DSIG_PREP_CONNECTED) {
-		code = erts_dsig_send_m_exit(&dsd, watcher, watched, ref,
-					     am_noproc);
-		ASSERT(code == ERTS_DSIG_SEND_OK);
-	    }
-	}
-	else {
-	    if (is_atom(watched))
-		watched = rp->id;
-	    erts_smp_de_links_lock(dep);
-	    erts_add_monitor(&(dep->monitors), MON_ORIGIN, ref, watched, name);
-	    erts_add_monitor(&(rp->monitors), MON_TARGET, ref, watcher, name);
-	    erts_smp_de_links_unlock(dep);
-	    erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_LINK);
-	}
-
-	break;
-    }
-
-    case DOP_DEMONITOR_P:
-	/* A remote node informs us that a local pid in no longer monitored
+            Eterm name;
+
+            if (tuple_arity != 4) {
+                goto invalid_message;
+            }
+
+            watcher = tuple[2];
+            watched = tuple[3];  /* local proc to monitor */
+            ref     = tuple[4];
+
+            if (is_not_ref(ref)) {
+                goto invalid_message;
+            }
+
+            if (is_atom(watched)) {
+                name = watched;
+                rp = erts_whereis_process(NULL, 0,
+                        watched, ERTS_PROC_LOCK_LINK,
+                        ERTS_P2P_FLG_ALLOW_OTHER_X);
+            }
+            else {
+                name = NIL;
+                rp = erts_pid2proc_opt(NULL, 0,
+                        watched, ERTS_PROC_LOCK_LINK,
+                        ERTS_P2P_FLG_ALLOW_OTHER_X);
+            }
+
+            if (!rp) {
+                ErtsDSigData dsd;
+                int code;
+                code = erts_dsig_prepare(&dsd, dep, NULL, ERTS_DSP_NO_LOCK, 0);
+                if (code == ERTS_DSIG_PREP_CONNECTED) {
+                    code = erts_dsig_send_m_exit(&dsd, watcher, watched, ref,
+                            am_noproc);
+                    ASSERT(code == ERTS_DSIG_SEND_OK);
+                }
+            }
+            else {
+                if (is_atom(watched))
+                    watched = rp->id;
+                erts_smp_de_links_lock(dep);
+                erts_add_monitor(&(dep->monitors), MON_ORIGIN, ref, watched, name);
+                erts_add_monitor(&(rp->monitors), MON_TARGET, ref, watcher, name);
+                erts_smp_de_links_unlock(dep);
+                erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_LINK);
+            }
+
+            break;
+        }
+
+        case DOP_DEMONITOR_P:
+            /* A remote node informs us that a local pid in no longer monitored
 	   We get {DOP_DEMONITOR_P, Remote pid, Local pid or name, ref},
 	   We need only the ref of course */
 
-	if (tuple_arity != 4) {
-	    goto invalid_message;
-	}
-	/* watcher = tuple[2]; */
-	/* watched = tuple[3]; May be an atom in case of monitor name */
-	ref = tuple[4];
-
-	if(is_not_ref(ref)) {
-	    goto invalid_message;
-	}
-
-	erts_smp_de_links_lock(dep);
-	mon = erts_remove_monitor(&(dep->monitors),ref);
-	erts_smp_de_links_unlock(dep);
-	/* ASSERT(mon != NULL); can happen in case of broken dist message */
-	if (mon == NULL) {
-	    break;
-	}
-	watched = mon->pid;
-	erts_destroy_monitor(mon);
-	rp = erts_pid2proc_opt(NULL, 0,
-			       watched, ERTS_PROC_LOCK_LINK,
-			       ERTS_P2P_FLG_ALLOW_OTHER_X);
-	if (!rp) {
-	    break;
-	}
-	mon = erts_remove_monitor(&(rp->monitors),ref);
-	erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_LINK);
-	ASSERT(mon != NULL);
-	if (mon == NULL) {
-	    break;
-	}
-	erts_destroy_monitor(mon);
-	break;
-
-    case DOP_REG_SEND_TT:
-	if (tuple_arity != 5) {
-	    goto invalid_message;
-	}
-
-	token_size = size_object(tuple[5]);
-	/* Fall through ... */
-    case DOP_REG_SEND:
-	/* {DOP_REG_SEND, From, Cookie, ToName} -- Message */
-	/* {DOP_REG_SEND_TT, From, Cookie, ToName, TraceToken} -- Message */
-
-	/*
-	 * There is intentionally no testing of the cookie (it is always '')
-	 * from R9B and onwards.
-	 */
-	if (type != DOP_REG_SEND_TT && tuple_arity != 4) {
-	    goto invalid_message;
-	}
+            if (tuple_arity != 4) {
+                goto invalid_message;
+            }
+            /* watcher = tuple[2]; */
+            /* watched = tuple[3]; May be an atom in case of monitor name */
+            ref = tuple[4];
+
+            if(is_not_ref(ref)) {
+                goto invalid_message;
+            }
+
+            erts_smp_de_links_lock(dep);
+            mon = erts_remove_monitor(&(dep->monitors),ref);
+            erts_smp_de_links_unlock(dep);
+            /* ASSERT(mon != NULL); can happen in case of broken dist message */
+            if (mon == NULL) {
+                break;
+            }
+            watched = mon->pid;
+            erts_destroy_monitor(mon);
+            rp = erts_pid2proc_opt(NULL, 0,
+                    watched, ERTS_PROC_LOCK_LINK,
+                    ERTS_P2P_FLG_ALLOW_OTHER_X);
+            if (!rp) {
+                break;
+            }
+            mon = erts_remove_monitor(&(rp->monitors),ref);
+            erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_LINK);
+            ASSERT(mon != NULL);
+            if (mon == NULL) {
+                break;
+            }
+            erts_destroy_monitor(mon);
+            break;
+
+        case DOP_REG_SEND_TT:
+            if (tuple_arity != 5) {
+                goto invalid_message;
+            }
+
+            token_size = size_object(tuple[5]);
+            /* Fall through ... */
+        case DOP_REG_SEND:
+            /* {DOP_REG_SEND, From, Cookie, ToName} -- Message */
+            /* {DOP_REG_SEND_TT, From, Cookie, ToName, TraceToken} -- Message */
+
+            /*
+             * There is intentionally no testing of the cookie (it is always '')
+             * from R9B and onwards.
+             */
+            if (type != DOP_REG_SEND_TT && tuple_arity != 4) {
+                goto invalid_message;
+            }
 
 #ifdef ERTS_DIST_MSG_DBG
-	dist_msg_dbg(&ede, "MSG", buf, orig_len);
+            dist_msg_dbg(&ede, "MSG", buf, orig_len);
 #endif
 
-	from = tuple[2];
-	to = tuple[4];
-	if (is_not_pid(from) || is_not_atom(to)){
-	    goto invalid_message;
-	}
-	rp = erts_whereis_process(NULL, 0, to, 0, ERTS_P2P_FLG_SMP_INC_REFC);
-	if (rp) {
-	    Uint xsize = (type == DOP_REG_SEND
-			  ? 0
-			  : ERTS_HEAP_FRAG_SIZE(token_size));
-	    ErtsProcLocks locks = 0;
-	    ErtsDistExternal *ede_copy;
-
-	    ede_copy = erts_make_dist_ext_copy(&ede, xsize);
-	    if (type == DOP_REG_SEND) {
-		token = NIL;
-	    } else {
-		ErlHeapFragment *heap_frag;
-		ErlOffHeap *ohp;
-		ASSERT(xsize);
-		heap_frag = erts_dist_ext_trailer(ede_copy);
-		ERTS_INIT_HEAP_FRAG(heap_frag, token_size);
-		hp = heap_frag->mem;
-		ohp = &heap_frag->off_heap;
-		token = tuple[5];
-		token = copy_struct(token, token_size, &hp, ohp);
-	    }
-
-	    erts_queue_dist_message(rp, &locks, ede_copy, token);
-	    if (locks)
-		erts_smp_proc_unlock(rp, locks);
-	    erts_smp_proc_dec_refc(rp);
-	}
-	break;
-
-    case DOP_SEND_TT:
-	if (tuple_arity != 4) {
-	    goto invalid_message;
-	}
-	
-	token_size = size_object(tuple[4]);
-	/* Fall through ... */
-    case DOP_SEND:
-	/*
-	 * There is intentionally no testing of the cookie (it is always '')
-	 * from R9B and onwards.
-	 */
+            from = tuple[2];
+            to = tuple[4];
+            if (is_not_pid(from) || is_not_atom(to)){
+                goto invalid_message;
+            }
+            erts_printf("DEBUG: Message received from %T, to %T\n", from, to);
+            rp = erts_whereis_process(NULL, 0, to, 0, ERTS_P2P_FLG_SMP_INC_REFC);
+            if (rp) {
+                Uint xsize = (type == DOP_REG_SEND
+                        ? 0
+                                : ERTS_HEAP_FRAG_SIZE(token_size));
+                ErtsProcLocks locks = 0;
+                ErtsDistExternal *ede_copy;
+
+                ede_copy = erts_make_dist_ext_copy(&ede, xsize);
+                if (type == DOP_REG_SEND) {
+                    token = NIL;
+                } else {
+                    ErlHeapFragment *heap_frag;
+                    ErlOffHeap *ohp;
+                    ASSERT(xsize);
+                    heap_frag = erts_dist_ext_trailer(ede_copy);
+                    ERTS_INIT_HEAP_FRAG(heap_frag, token_size);
+                    hp = heap_frag->mem;
+                    ohp = &heap_frag->off_heap;
+                    token = tuple[5];
+                    token = copy_struct(token, token_size, &hp, ohp);
+                }
+
+                erts_queue_dist_message(rp, &locks, ede_copy, token);
+                if (locks)
+                    erts_smp_proc_unlock(rp, locks);
+                erts_smp_proc_dec_refc(rp);
+            }
+            break;
+
+        case DOP_SEND_TT:
+            if (tuple_arity != 4) {
+                goto invalid_message;
+            }
+
+            token_size = size_object(tuple[4]);
+            /* Fall through ... */
+        case DOP_SEND:
+            /*
+             * There is intentionally no testing of the cookie (it is always '')
+             * from R9B and onwards.
+             */
 #ifdef ERTS_DIST_MSG_DBG
-	dist_msg_dbg(&ede, "MSG", buf, orig_len);
+            dist_msg_dbg(&ede, "MSG", buf, orig_len);
 #endif
-	if (type != DOP_SEND_TT && tuple_arity != 3) {
-	    goto invalid_message;
-	}
-	to = tuple[3];
-	if (is_not_pid(to)) {
-	    goto invalid_message;
-	}
-	rp = erts_pid2proc_opt(NULL, 0, to, 0, ERTS_P2P_FLG_SMP_INC_REFC);
-	if (rp) {
-	    Uint xsize = type == DOP_SEND ? 0 : ERTS_HEAP_FRAG_SIZE(token_size);
-	    ErtsProcLocks locks = 0;
-	    ErtsDistExternal *ede_copy;
-
-	    ede_copy = erts_make_dist_ext_copy(&ede, xsize);
-	    if (type == DOP_SEND) {
-		token = NIL;
-	    } else {
-		ErlHeapFragment *heap_frag;
-		ErlOffHeap *ohp;
-		ASSERT(xsize);
-		heap_frag = erts_dist_ext_trailer(ede_copy);
-		ERTS_INIT_HEAP_FRAG(heap_frag, token_size);
-		hp = heap_frag->mem;
-		ohp = &heap_frag->off_heap;
-		token = tuple[4];
-		token = copy_struct(token, token_size, &hp, ohp);
-	    }
-
-	    erts_queue_dist_message(rp, &locks, ede_copy, token);
-	    if (locks)
-		erts_smp_proc_unlock(rp, locks);
-	    erts_smp_proc_dec_refc(rp);
-	}
-	break;
-
-    case DOP_MONITOR_P_EXIT: {
-	/* We are monitoring a process on the remote node which dies, we get
+            if (type != DOP_SEND_TT && tuple_arity != 3) {
+                goto invalid_message;
+            }
+            to = tuple[3];
+            if (is_not_pid(to)) {
+                goto invalid_message;
+            }
+            erts_printf("DEBUG: Message received for %T\n", to);
+            rp = erts_pid2proc_opt(NULL, 0, to, 0, ERTS_P2P_FLG_SMP_INC_REFC);
+            if (rp) {
+                Uint xsize = type == DOP_SEND ? 0 : ERTS_HEAP_FRAG_SIZE(token_size);
+                ErtsProcLocks locks = 0;
+                ErtsDistExternal *ede_copy;
+
+                ede_copy = erts_make_dist_ext_copy(&ede, xsize);
+                if (type == DOP_SEND) {
+                    token = NIL;
+                } else {
+                    ErlHeapFragment *heap_frag;
+                    ErlOffHeap *ohp;
+                    ASSERT(xsize);
+                    heap_frag = erts_dist_ext_trailer(ede_copy);
+                    ERTS_INIT_HEAP_FRAG(heap_frag, token_size);
+                    hp = heap_frag->mem;
+                    ohp = &heap_frag->off_heap;
+                    token = tuple[4];
+                    token = copy_struct(token, token_size, &hp, ohp);
+                }
+
+                erts_queue_dist_message(rp, &locks, ede_copy, token);
+                if (locks)
+                    erts_smp_proc_unlock(rp, locks);
+                erts_smp_proc_dec_refc(rp);
+            }
+            break;
+
+        case DOP_MONITOR_P_EXIT: {
+            /* We are monitoring a process on the remote node which dies, we get
 	   {DOP_MONITOR_P_EXIT, Remote pid or name, Local pid, ref, reason} */
-	   
-
-	DeclareTmpHeapNoproc(lhp,3);
-	Eterm sysname;
-	ErtsProcLocks rp_locks = ERTS_PROC_LOCKS_MSG_SEND|ERTS_PROC_LOCK_LINK;
-
-	if (tuple_arity != 5) {
-	    goto invalid_message;
-	}
-
-	/* watched = tuple[2]; */  /* remote proc which died */
-	/* watcher = tuple[3]; */
-	ref     = tuple[4];
-	reason  = tuple[5];
-
-	if(is_not_ref(ref)) {
-	    goto invalid_message;
-	}
-
-	erts_smp_de_links_lock(dep);
-	sysname = dep->sysname;
-	mon = erts_remove_monitor(&(dep->monitors), ref);
-	/*
-	 * If demonitor was performed at the same time as the
-	 * monitored process exits, monitoring side will have
-	 * removed info about monitor. In this case, do nothing
-	 * and everything will be as it should.
-	 */
-	erts_smp_de_links_unlock(dep);
-	if (mon == NULL) {
-	    break;
-	}
-	rp = erts_pid2proc(NULL, 0, mon->pid, rp_locks);
-	if (rp == NULL) {
-	    break;
-	}
-
-	erts_destroy_monitor(mon);
-
-	mon = erts_remove_monitor(&(rp->monitors),ref);
-
-	if (mon == NULL) {
-	    erts_smp_proc_unlock(rp, rp_locks);
-	    break;
-	}
-	UseTmpHeapNoproc(3);
-	
-	watched = (is_not_nil(mon->name)
-		   ? TUPLE2(&lhp[0], mon->name, sysname)
-		   : mon->pid);
-	
-	erts_queue_monitor_message(rp, &rp_locks,
-				   ref, am_process, watched, reason);
-	erts_smp_proc_unlock(rp, rp_locks);
-	erts_destroy_monitor(mon);
-	UnUseTmpHeapNoproc(3);
-	break;
-    }
-
-    case DOP_EXIT_TT:
-    case DOP_EXIT: {
-	ErtsDistLinkData dld;
-	ErtsProcLocks rp_locks = ERTS_PROC_LOCK_LINK|ERTS_PROC_LOCKS_XSIG_SEND;
-	/* 'from', which 'to' is linked to, died */
-	if (type == DOP_EXIT) {
-	    if (tuple_arity != 4) {
-		goto invalid_message;
-	    }
-	    
-	    from = tuple[2];
-	    to = tuple[3];
-	    reason = tuple[4];
-	    token = NIL;
-	} else {
-	    if (tuple_arity != 5) {
-		goto invalid_message;
-	    }
-	    from = tuple[2];
-	    to = tuple[3];
-	    token = tuple[4];
-	    reason = tuple[5];
-	}
-	if (is_not_pid(from) || is_not_internal_pid(to)) {
-	    goto invalid_message;
-	}
-
-	rp = erts_pid2proc(NULL, 0, to, rp_locks);
-	if (!rp)
-	    lnk = NULL;
-	else {
-	    lnk = erts_remove_link(&(rp->nlinks), from);
-
-	    /* If lnk == NULL, we have unlinked on this side, i.e.
-	     * ignore exit.
-	     */
-	    if (lnk) {
-		int xres;
+
+
+            DeclareTmpHeapNoproc(lhp,3);
+            Eterm sysname;
+            ErtsProcLocks rp_locks = ERTS_PROC_LOCKS_MSG_SEND|ERTS_PROC_LOCK_LINK;
+
+            if (tuple_arity != 5) {
+                goto invalid_message;
+            }
+
+            /* watched = tuple[2]; */  /* remote proc which died */
+            /* watcher = tuple[3]; */
+            ref     = tuple[4];
+            reason  = tuple[5];
+
+            if(is_not_ref(ref)) {
+                goto invalid_message;
+            }
+
+            erts_smp_de_links_lock(dep);
+            sysname = dep->sysname;
+            mon = erts_remove_monitor(&(dep->monitors), ref);
+            /*
+             * If demonitor was performed at the same time as the
+             * monitored process exits, monitoring side will have
+             * removed info about monitor. In this case, do nothing
+             * and everything will be as it should.
+             */
+            erts_smp_de_links_unlock(dep);
+            if (mon == NULL) {
+                break;
+            }
+            rp = erts_pid2proc(NULL, 0, mon->pid, rp_locks);
+            if (rp == NULL) {
+                break;
+            }
+
+            erts_destroy_monitor(mon);
+
+            mon = erts_remove_monitor(&(rp->monitors),ref);
+
+            if (mon == NULL) {
+                erts_smp_proc_unlock(rp, rp_locks);
+                break;
+            }
+            UseTmpHeapNoproc(3);
+
+            watched = (is_not_nil(mon->name)
+                    ? TUPLE2(&lhp[0], mon->name, sysname)
+                            : mon->pid);
+
+            erts_queue_monitor_message(rp, &rp_locks,
+                    ref, am_process, watched, reason);
+            erts_smp_proc_unlock(rp, rp_locks);
+            erts_destroy_monitor(mon);
+            UnUseTmpHeapNoproc(3);
+            break;
+        }
+
+        case DOP_EXIT_TT:
+        case DOP_EXIT: {
+            ErtsDistLinkData dld;
+            ErtsProcLocks rp_locks = ERTS_PROC_LOCK_LINK|ERTS_PROC_LOCKS_XSIG_SEND;
+            /* 'from', which 'to' is linked to, died */
+            if (type == DOP_EXIT) {
+                if (tuple_arity != 4) {
+                    goto invalid_message;
+                }
+
+                from = tuple[2];
+                to = tuple[3];
+                reason = tuple[4];
+                token = NIL;
+            } else {
+                if (tuple_arity != 5) {
+                    goto invalid_message;
+                }
+                from = tuple[2];
+                to = tuple[3];
+                token = tuple[4];
+                reason = tuple[5];
+            }
+            if (is_not_pid(from) || is_not_internal_pid(to)) {
+                goto invalid_message;
+            }
+
+            rp = erts_pid2proc(NULL, 0, to, rp_locks);
+            if (!rp)
+                lnk = NULL;
+            else {
+                lnk = erts_remove_link(&(rp->nlinks), from);
+
+                /* If lnk == NULL, we have unlinked on this side, i.e.
+                 * ignore exit.
+                 */
+                if (lnk) {
+                    int xres;
 #if 0
-		/* Arndt: Maybe it should never be 'kill', but it can be,
+                    /* Arndt: Maybe it should never be 'kill', but it can be,
 		   namely when a linked process does exit(kill). Until we know
 		   whether that is incorrect and what should happen instead,
 		   we leave the assertion out. */
-		ASSERT(reason != am_kill); /* should never be kill (killed) */
+                    ASSERT(reason != am_kill); /* should never be kill (killed) */
 #endif
-		xres = erts_send_exit_signal(NULL,
-					     from,
-					     rp,
-					     &rp_locks, 
-					     reason,
-					     token,
-					     NULL,
-					     ERTS_XSIG_FLG_IGN_KILL);
-		if (xres >= 0 && IS_TRACED_FL(rp, F_TRACE_PROCS)) {
-		    /* We didn't exit the process and it is traced */
-		    trace_proc(NULL, rp, am_getting_unlinked, from);
-		}
-	    }
-	    erts_smp_proc_unlock(rp, rp_locks);
-	}
-	erts_remove_dist_link(&dld, to, from, dep);
-	if (lnk)
-	    erts_destroy_link(lnk);
-	erts_destroy_dist_link(&dld);
-	break;
-    }
-    case DOP_EXIT2_TT:
-    case DOP_EXIT2: {
-	ErtsProcLocks rp_locks = ERTS_PROC_LOCKS_XSIG_SEND;
-	/* 'from' is send an exit signal to 'to' */
-	if (type == DOP_EXIT2) {
-	    if (tuple_arity != 4) {
-		goto invalid_message;
-	    }
-	    from = tuple[2];
-	    to = tuple[3];
-	    reason = tuple[4];
-	    token = NIL;
-	} else {
-	    if (tuple_arity != 5) {
-		goto invalid_message;
-	    }
-	    from = tuple[2];
-	    to = tuple[3];
-	    token = tuple[4];
-	    reason = tuple[5];
-	}
-	if (is_not_pid(from) || is_not_internal_pid(to)) {
-	    goto invalid_message;
-	}
-	rp = erts_pid2proc_opt(NULL, 0, to, rp_locks,
-			       ERTS_P2P_FLG_SMP_INC_REFC);
-	if (rp) {
-	    (void) erts_send_exit_signal(NULL,
-					 from,
-					 rp,
-					 &rp_locks,
-					 reason,
-					 token,
-					 NULL,
-					 0);
-	    erts_smp_proc_unlock(rp, rp_locks);
-	    erts_smp_proc_dec_refc(rp);
-	}
-	break;
-    }
-    case DOP_GROUP_LEADER:
-	if (tuple_arity != 3) {
-	    goto invalid_message;
-	}
-	from = tuple[2];   /* Group leader  */
-	to = tuple[3];     /* new member */
-	if (is_not_pid(from) || is_not_pid(to)) {
-	    goto invalid_message;
-	}
-
-	rp = erts_pid2proc(NULL, 0, to, ERTS_PROC_LOCK_MAIN);
-	if (!rp)
-	    break;
-	rp->group_leader = STORE_NC_IN_PROC(rp, from);
-	erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_MAIN);
-	break;
-
-    default: 
-	goto invalid_message;
+                    xres = erts_send_exit_signal(NULL,
+                            from,
+                            rp,
+                            &rp_locks, 
+                            reason,
+                            token,
+                            NULL,
+                            ERTS_XSIG_FLG_IGN_KILL);
+                    if (xres >= 0 && IS_TRACED_FL(rp, F_TRACE_PROCS)) {
+                        /* We didn't exit the process and it is traced */
+                        trace_proc(NULL, rp, am_getting_unlinked, from);
+                    }
+                }
+                erts_smp_proc_unlock(rp, rp_locks);
+            }
+            erts_remove_dist_link(&dld, to, from, dep);
+            if (lnk)
+                erts_destroy_link(lnk);
+            erts_destroy_dist_link(&dld);
+            break;
+        }
+        case DOP_EXIT2_TT:
+        case DOP_EXIT2: {
+            ErtsProcLocks rp_locks = ERTS_PROC_LOCKS_XSIG_SEND;
+            /* 'from' is send an exit signal to 'to' */
+            if (type == DOP_EXIT2) {
+                if (tuple_arity != 4) {
+                    goto invalid_message;
+                }
+                from = tuple[2];
+                to = tuple[3];
+                reason = tuple[4];
+                token = NIL;
+            } else {
+                if (tuple_arity != 5) {
+                    goto invalid_message;
+                }
+                from = tuple[2];
+                to = tuple[3];
+                token = tuple[4];
+                reason = tuple[5];
+            }
+            if (is_not_pid(from) || is_not_internal_pid(to)) {
+                goto invalid_message;
+            }
+            rp = erts_pid2proc_opt(NULL, 0, to, rp_locks,
+                    ERTS_P2P_FLG_SMP_INC_REFC);
+            if (rp) {
+                (void) erts_send_exit_signal(NULL,
+                        from,
+                        rp,
+                        &rp_locks,
+                        reason,
+                        token,
+                        NULL,
+                        0);
+                erts_smp_proc_unlock(rp, rp_locks);
+                erts_smp_proc_dec_refc(rp);
+            }
+            break;
+        }
+        case DOP_GROUP_LEADER:
+            if (tuple_arity != 3) {
+                goto invalid_message;
+            }
+            from = tuple[2];   /* Group leader  */
+            to = tuple[3];     /* new member */
+            if (is_not_pid(from) || is_not_pid(to)) {
+                goto invalid_message;
+            }
+
+            rp = erts_pid2proc(NULL, 0, to, ERTS_PROC_LOCK_MAIN);
+            if (!rp)
+                break;
+            rp->group_leader = STORE_NC_IN_PROC(rp, from);
+            erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_MAIN);
+            break;
+
+        default: 
+            goto invalid_message;
     }
 
     erts_cleanup_offheap(&off_heap);
 #ifndef HYBRID /* FIND ME! */
     if (ctl != ctl_default) {
-	erts_free(ERTS_ALC_T_DCTRL_BUF, (void *) ctl);
+        erts_free(ERTS_ALC_T_DCTRL_BUF, (void *) ctl);
     }
 #endif
     UnUseTmpHeapNoproc(DIST_CTL_DEFAULT_SIZE);
     ERTS_SMP_CHK_NO_PROC_LOCKS;
     return 0;
- invalid_message:
+    invalid_message:
     {
-	erts_dsprintf_buf_t *dsbufp = erts_create_logger_dsbuf();
-	erts_dsprintf(dsbufp, "Invalid distribution message: %.200T", arg);
-	erts_send_error_to_logger_nogl(dsbufp);
+        erts_dsprintf_buf_t *dsbufp = erts_create_logger_dsbuf();
+        erts_dsprintf(dsbufp, "Invalid distribution message: %.200T", arg);
+        erts_send_error_to_logger_nogl(dsbufp);
     }
- data_error:
+    data_error:
     PURIFY_MSG("data error");
     erts_cleanup_offheap(&off_heap);
 #ifndef HYBRID /* FIND ME! */
     if (ctl != ctl_default) {
-	erts_free(ERTS_ALC_T_DCTRL_BUF, (void *) ctl);
+        erts_free(ERTS_ALC_T_DCTRL_BUF, (void *) ctl);
     }
 #endif
     UnUseTmpHeapNoproc(DIST_CTL_DEFAULT_SIZE);
@@ -1526,35 +1528,35 @@ dsig_send(ErtsDSigData *dsdp, Eterm ctl, Eterm msg, int force_busy)
     Process *c_p = dsdp->proc;
 
     if (!c_p || dsdp->no_suspend)
-	force_busy = 1;
+        force_busy = 1;
 
     ERTS_SMP_LC_ASSERT(!c_p
-		       || (ERTS_PROC_LOCK_MAIN
-			   == erts_proc_lc_my_proc_locks(c_p)));
+            || (ERTS_PROC_LOCK_MAIN
+                    == erts_proc_lc_my_proc_locks(c_p)));
 
     if (!erts_is_alive)
-	return ERTS_DSIG_SEND_OK;
+        return ERTS_DSIG_SEND_OK;
 
     if (flags & DFLAG_DIST_HDR_ATOM_CACHE) {
-	acmp = erts_get_atom_cache_map(c_p);
-	pass_through_size = 0;
+        acmp = erts_get_atom_cache_map(c_p);
+        pass_through_size = 0;
     }
     else {
-	acmp = NULL;
-	pass_through_size = 1;
+        acmp = NULL;
+        pass_through_size = 1;
     }
 
 #ifdef ERTS_DIST_MSG_DBG
     erts_fprintf(stderr, ">>%s CTL: %T\n", pass_through_size ? "P" : " ", ctl);
     if (is_value(msg))
-	erts_fprintf(stderr, "    MSG: %T\n", msg);
+        erts_fprintf(stderr, "    MSG: %T\n", msg);
 #endif
 
     data_size = pass_through_size;
     erts_reset_atom_cache_map(acmp);
     data_size += erts_encode_dist_ext_size(ctl, flags, acmp);
     if (is_value(msg))
-	data_size += erts_encode_dist_ext_size(msg, flags, acmp);
+        data_size += erts_encode_dist_ext_size(msg, flags, acmp);
     erts_finalize_atom_cache_map(acmp);
 
     dhdr_ext_size = erts_encode_ext_dist_header_size(acmp);
@@ -1568,8 +1570,8 @@ dsig_send(ErtsDSigData *dsdp, Eterm ctl, Eterm msg, int force_busy)
     /* Encode control message */
     erts_encode_dist_ext(ctl, &obuf->ext_endp, flags, acmp);
     if (is_value(msg)) {
-	/* Encode message */
-	erts_encode_dist_ext(msg, &obuf->ext_endp, flags, acmp);
+        /* Encode message */
+        erts_encode_dist_ext(msg, &obuf->ext_endp, flags, acmp);
     }
 
     ASSERT(obuf->extp < obuf->ext_endp);
@@ -1586,91 +1588,91 @@ dsig_send(ErtsDSigData *dsdp, Eterm ctl, Eterm msg, int force_busy)
     erts_smp_de_rlock(dep);
     cid = dep->cid;
     if (cid != dsdp->cid
-	|| dep->connection_id != dsdp->connection_id
-	|| dep->status & ERTS_DE_SFLG_EXITING) {
-	/* Not the same connection as when we started; drop message... */
-	erts_smp_de_runlock(dep);
-	free_dist_obuf(obuf);
+            || dep->connection_id != dsdp->connection_id
+            || dep->status & ERTS_DE_SFLG_EXITING) {
+        /* Not the same connection as when we started; drop message... */
+        erts_smp_de_runlock(dep);
+        free_dist_obuf(obuf);
     }
     else {
-	ErtsProcList *plp = NULL;
-	erts_smp_mtx_lock(&dep->qlock);
-	dep->qsize += size_obuf(obuf);
-	if (dep->qsize >= erts_dist_buf_busy_limit)
-	    dep->qflgs |= ERTS_DE_QFLG_BUSY;
-	if (!force_busy && (dep->qflgs & ERTS_DE_QFLG_BUSY)) {
-	    erts_smp_mtx_unlock(&dep->qlock);
-
-	    plp = erts_proclist_create(c_p);
-	    plp->next = NULL;
-	    erts_suspend(c_p, ERTS_PROC_LOCK_MAIN, NULL);
-	    suspended = 1;
-	    erts_smp_mtx_lock(&dep->qlock);
-	}
-
-	/* Enqueue obuf on dist entry */
-	if (dep->out_queue.last)
-	    dep->out_queue.last->next = obuf;
-	else
-	    dep->out_queue.first = obuf;
-	dep->out_queue.last = obuf;
-
-	if (!force_busy) {
-	    if (!(dep->qflgs & ERTS_DE_QFLG_BUSY)) {
-		if (suspended)
-		    resume = 1; /* was busy when we started, but isn't now */
-	    }
-	    else {
-		/* Enqueue suspended process on dist entry */
-		ASSERT(plp);
-		if (dep->suspended.last)
-		    dep->suspended.last->next = plp;
-		else
-		    dep->suspended.first = plp;
-		dep->suspended.last = plp;
-	    }
-	}
-
-	erts_smp_mtx_unlock(&dep->qlock);
-	erts_schedule_dist_command(NULL, dep);
-	erts_smp_de_runlock(dep);
-	
-	if (resume) {
-	    erts_resume(c_p, ERTS_PROC_LOCK_MAIN);
-	    erts_proclist_destroy(plp);
-	    /*
-	     * Note that the calling process still have to yield as if it
-	     * suspended. If not, the calling process could later be
-	     * erroneously scheduled when it shouldn't be.
-	     */
-	}
+        ErtsProcList *plp = NULL;
+        erts_smp_mtx_lock(&dep->qlock);
+        dep->qsize += size_obuf(obuf);
+        if (dep->qsize >= erts_dist_buf_busy_limit)
+            dep->qflgs |= ERTS_DE_QFLG_BUSY;
+        if (!force_busy && (dep->qflgs & ERTS_DE_QFLG_BUSY)) {
+            erts_smp_mtx_unlock(&dep->qlock);
+
+            plp = erts_proclist_create(c_p);
+            plp->next = NULL;
+            erts_suspend(c_p, ERTS_PROC_LOCK_MAIN, NULL);
+            suspended = 1;
+            erts_smp_mtx_lock(&dep->qlock);
+        }
+
+        /* Enqueue obuf on dist entry */
+        if (dep->out_queue.last)
+            dep->out_queue.last->next = obuf;
+        else
+            dep->out_queue.first = obuf;
+        dep->out_queue.last = obuf;
+
+        if (!force_busy) {
+            if (!(dep->qflgs & ERTS_DE_QFLG_BUSY)) {
+                if (suspended)
+                    resume = 1; /* was busy when we started, but isn't now */
+            }
+            else {
+                /* Enqueue suspended process on dist entry */
+                ASSERT(plp);
+                if (dep->suspended.last)
+                    dep->suspended.last->next = plp;
+                else
+                    dep->suspended.first = plp;
+                dep->suspended.last = plp;
+            }
+        }
+
+        erts_smp_mtx_unlock(&dep->qlock);
+        erts_schedule_dist_command(NULL, dep);
+        erts_smp_de_runlock(dep);
+
+        if (resume) {
+            erts_resume(c_p, ERTS_PROC_LOCK_MAIN);
+            erts_proclist_destroy(plp);
+            /*
+             * Note that the calling process still have to yield as if it
+             * suspended. If not, the calling process could later be
+             * erroneously scheduled when it shouldn't be.
+             */
+        }
     }
 
     if (c_p) {
-	int reds;
-	/* 
-	 * Bump reductions on calling process.
-	 *
-	 * This is the reduction cost: Always a base cost of 8 reductions
-	 * plus 16 reductions per kilobyte generated external data.
-	 */
-
-	data_size >>= (10-4);
+        int reds;
+        /* 
+         * Bump reductions on calling process.
+         *
+         * This is the reduction cost: Always a base cost of 8 reductions
+         * plus 16 reductions per kilobyte generated external data.
+         */
+
+        data_size >>= (10-4);
 #if defined(ARCH_64) && !HALFWORD_HEAP
-	data_size &= 0x003fffffffffffff;
+        data_size &= 0x003fffffffffffff;
 #elif defined(ARCH_32) || HALFWORD_HEAP
-	data_size &= 0x003fffff;
+        data_size &= 0x003fffff;
 #else
 #       error "Ohh come on ... !?!"
 #endif
-	reds = 8 + ((int) data_size > 1000000 ? 1000000 : (int) data_size);
-	BUMP_REDS(c_p, reds);
+        reds = 8 + ((int) data_size > 1000000 ? 1000000 : (int) data_size);
+        BUMP_REDS(c_p, reds);
     }
 
     if (suspended) {
-	if (!resume && erts_system_monitor_flags.busy_dist_port)
-	    monitor_generic(c_p, am_busy_dist_port, cid);
-	return ERTS_DSIG_SEND_YIELD;
+        if (!resume && erts_system_monitor_flags.busy_dist_port)
+            monitor_generic(c_p, am_busy_dist_port, cid);
+        return ERTS_DSIG_SEND_YIELD;
     }
     return ERTS_DSIG_SEND_OK;
 }
@@ -1686,16 +1688,16 @@ dist_port_command(Port *prt, ErtsDistOutputBuf *obuf)
     ERTS_SMP_LC_ASSERT(erts_lc_is_port_locked(prt));
 
     if (size > (Uint) INT_MAX)
-	erl_exit(ERTS_ABORT_EXIT,
-		 "Absurdly large distribution output data buffer "
-		 "(%beu bytes) passed.\n",
-		 size);
+        erl_exit(ERTS_ABORT_EXIT,
+                "Absurdly large distribution output data buffer "
+                "(%beu bytes) passed.\n",
+                size);
 
     prt->caller = NIL;
     fpe_was_unmasked = erts_block_fpe();
     (*prt->drv_ptr->output)((ErlDrvData) prt->drv_data,
-			    (char*) obuf->extp,
-			    (int) size);
+            (char*) obuf->extp,
+            (int) size);
     erts_unblock_fpe(fpe_was_unmasked);
     return size;
 }
@@ -1713,10 +1715,10 @@ dist_port_commandv(Port *prt, ErtsDistOutputBuf *obuf)
     ERTS_SMP_LC_ASSERT(erts_lc_is_port_locked(prt));
 
     if (size > (Uint) INT_MAX)
-	erl_exit(ERTS_ABORT_EXIT,
-		 "Absurdly large distribution output data buffer "
-		 "(%beu bytes) passed.\n",
-		 size);
+        erl_exit(ERTS_ABORT_EXIT,
+                "Absurdly large distribution output data buffer "
+                "(%beu bytes) passed.\n",
+                size);
 
     iov[0].iov_base = NULL;
     iov[0].iov_len = 0;
@@ -1755,9 +1757,9 @@ dist_port_commandv(Port *prt, ErtsDistOutputBuf *obuf)
 #define ERTS_PORT_REDS_DIST_CMD_EXIT 200
 #define ERTS_PORT_REDS_DIST_CMD_RESUMED 5
 #define ERTS_PORT_REDS_DIST_CMD_DATA(SZ) \
-  ((SZ) < (1 << 10) \
-   ? ((Sint) 1) \
-   : ((((Sint) (SZ)) >> 10) & ((Sint) ERTS_PORT_REDS_MASK__)))
+        ((SZ) < (1 << 10) \
+                ? ((Sint) 1) \
+                        : ((((Sint) (SZ)) >> 10) & ((Sint) ERTS_PORT_REDS_MASK__)))
 
 int
 erts_dist_command(Port *prt, int reds_limit)
@@ -1785,9 +1787,9 @@ erts_dist_command(Port *prt, int reds_limit)
     erts_smp_de_runlock(dep);
 
     if (status & ERTS_DE_SFLG_EXITING) {
-	erts_do_exit_port(prt, prt->id, am_killed);
-	erts_deref_dist_entry(dep);
-	return reds + ERTS_PORT_REDS_DIST_CMD_EXIT;
+        erts_do_exit_port(prt, prt->id, am_killed);
+        erts_deref_dist_entry(dep);
+        return reds + ERTS_PORT_REDS_DIST_CMD_EXIT;
     }
 
     ASSERT(send);
@@ -1813,167 +1815,167 @@ erts_dist_command(Port *prt, int reds_limit)
     dep->finalized_out_queue.last = NULL;
 
     if (reds > reds_limit)
-	goto preempted;
+        goto preempted;
 
     prt_busy = (int) (prt->status & ERTS_PORT_SFLG_PORT_BUSY);
 
     if (!prt_busy && foq.first) {
-	int preempt = 0;
-	do {
-	    Uint size;
-	    ErtsDistOutputBuf *fob;
+        int preempt = 0;
+        do {
+            Uint size;
+            ErtsDistOutputBuf *fob;
 
-	    size = (*send)(prt, foq.first);
+            size = (*send)(prt, foq.first);
 #ifdef ERTS_RAW_DIST_MSG_DBG
-	    erts_fprintf(stderr, ">> ");
-	    bw(foq.first->extp, size);
+            erts_fprintf(stderr, ">> ");
+            bw(foq.first->extp, size);
 #endif
-	    reds += ERTS_PORT_REDS_DIST_CMD_DATA(size);
-	    fob = foq.first;
-	    obufsize += size_obuf(fob);
-	    foq.first = foq.first->next;
-	    free_dist_obuf(fob);
-	    preempt = reds > reds_limit || (prt->status & ERTS_PORT_SFLGS_DEAD);
-	    if (prt->status & ERTS_PORT_SFLG_PORT_BUSY) {
-		prt_busy = 1;
-		break;
-	    }
-	} while (foq.first && !preempt);
-	if (!foq.first)
-	    foq.last = NULL;
-	if (preempt)
-	    goto preempted;
+            reds += ERTS_PORT_REDS_DIST_CMD_DATA(size);
+            fob = foq.first;
+            obufsize += size_obuf(fob);
+            foq.first = foq.first->next;
+            free_dist_obuf(fob);
+            preempt = reds > reds_limit || (prt->status & ERTS_PORT_SFLGS_DEAD);
+            if (prt->status & ERTS_PORT_SFLG_PORT_BUSY) {
+                prt_busy = 1;
+                break;
+            }
+        } while (foq.first && !preempt);
+        if (!foq.first)
+            foq.last = NULL;
+        if (preempt)
+            goto preempted;
     }
 
     if (prt_busy) {
-	if (oq.first) {
-	    ErtsDistOutputBuf *ob;
-	    int preempt;
-	finalize_only:
-	    preempt = 0;
-	    ob = oq.first;
-	    ASSERT(ob);
-	    do {
-		ob->extp = erts_encode_ext_dist_header_finalize(ob->extp,
-								dep->cache);
-		if (!(flags & DFLAG_DIST_HDR_ATOM_CACHE))
-		    *--ob->extp = PASS_THROUGH; /* Old node; 'pass through'
+        if (oq.first) {
+            ErtsDistOutputBuf *ob;
+            int preempt;
+            finalize_only:
+            preempt = 0;
+            ob = oq.first;
+            ASSERT(ob);
+            do {
+                ob->extp = erts_encode_ext_dist_header_finalize(ob->extp,
+                        dep->cache);
+                if (!(flags & DFLAG_DIST_HDR_ATOM_CACHE))
+                    *--ob->extp = PASS_THROUGH; /* Old node; 'pass through'
 						   needed */
-		ASSERT(&ob->data[0] <= ob->extp && ob->extp < ob->ext_endp);
-		reds += ERTS_PORT_REDS_DIST_CMD_FINALIZE;
-		preempt = reds > reds_limit;
-		if (preempt)
-		    break;
-		ob = ob->next;
-	    } while (ob);
-	    /*
-	     * At least one buffer was finalized; if we got preempted,
-	     * ob points to the last buffer that we finalized.
-	     */
-	    if (foq.last)
-		foq.last->next = oq.first;
-	    else
-		foq.first = oq.first;
-	    if (!preempt) {
-		/* All buffers finalized */
-		foq.last = oq.last;
-		oq.first = oq.last = NULL;
-	    }
-	    else {
-		/* Not all buffers finalized; split oq. */
-		foq.last = ob;
-		oq.first = ob->next;
-		if (oq.first)
-		    ob->next = NULL;
-		else
-		    oq.last = NULL;
-	    }
-	    if (preempt)
-		goto preempted;
-	}
+                ASSERT(&ob->data[0] <= ob->extp && ob->extp < ob->ext_endp);
+                reds += ERTS_PORT_REDS_DIST_CMD_FINALIZE;
+                preempt = reds > reds_limit;
+                if (preempt)
+                    break;
+                ob = ob->next;
+            } while (ob);
+            /*
+             * At least one buffer was finalized; if we got preempted,
+             * ob points to the last buffer that we finalized.
+             */
+            if (foq.last)
+                foq.last->next = oq.first;
+            else
+                foq.first = oq.first;
+            if (!preempt) {
+                /* All buffers finalized */
+                foq.last = oq.last;
+                oq.first = oq.last = NULL;
+            }
+            else {
+                /* Not all buffers finalized; split oq. */
+                foq.last = ob;
+                oq.first = ob->next;
+                if (oq.first)
+                    ob->next = NULL;
+                else
+                    oq.last = NULL;
+            }
+            if (preempt)
+                goto preempted;
+        }
     }
     else {
-	int preempt = 0;
-	while (oq.first && !preempt) {
-	    ErtsDistOutputBuf *fob;
-	    Uint size;
-	    oq.first->extp
-		= erts_encode_ext_dist_header_finalize(oq.first->extp,
-						       dep->cache);
-	    reds += ERTS_PORT_REDS_DIST_CMD_FINALIZE;
-	    if (!(flags & DFLAG_DIST_HDR_ATOM_CACHE))
-		*--oq.first->extp = PASS_THROUGH; /* Old node; 'pass through'
+        int preempt = 0;
+        while (oq.first && !preempt) {
+            ErtsDistOutputBuf *fob;
+            Uint size;
+            oq.first->extp
+            = erts_encode_ext_dist_header_finalize(oq.first->extp,
+                    dep->cache);
+            reds += ERTS_PORT_REDS_DIST_CMD_FINALIZE;
+            if (!(flags & DFLAG_DIST_HDR_ATOM_CACHE))
+                *--oq.first->extp = PASS_THROUGH; /* Old node; 'pass through'
 						     needed */
-	    ASSERT(&oq.first->data[0] <= oq.first->extp
-		   && oq.first->extp < oq.first->ext_endp);
-	    size = (*send)(prt, oq.first);
+            ASSERT(&oq.first->data[0] <= oq.first->extp
+                    && oq.first->extp < oq.first->ext_endp);
+            size = (*send)(prt, oq.first);
 #ifdef ERTS_RAW_DIST_MSG_DBG
-	    erts_fprintf(stderr, ">> ");
-	    bw(oq.first->extp, size);
+            erts_fprintf(stderr, ">> ");
+            bw(oq.first->extp, size);
 #endif
-	    reds += ERTS_PORT_REDS_DIST_CMD_DATA(size);
-	    fob = oq.first;
-	    obufsize += size_obuf(fob);
-	    oq.first = oq.first->next;
-	    free_dist_obuf(fob);
-	    preempt = reds > reds_limit || (prt->status & ERTS_PORT_SFLGS_DEAD);
-	    if (prt->status & ERTS_PORT_SFLG_PORT_BUSY) {
-		prt_busy = 1;
-		if (oq.first && !preempt)
-		    goto finalize_only;
-	    }
-	}
-
-	ASSERT(!oq.first || preempt);
-
-	/*
-	 * Preempt if not all buffers have been handled.
-	 */
-	if (preempt && oq.first)
-	    goto preempted;
+            reds += ERTS_PORT_REDS_DIST_CMD_DATA(size);
+            fob = oq.first;
+            obufsize += size_obuf(fob);
+            oq.first = oq.first->next;
+            free_dist_obuf(fob);
+            preempt = reds > reds_limit || (prt->status & ERTS_PORT_SFLGS_DEAD);
+            if (prt->status & ERTS_PORT_SFLG_PORT_BUSY) {
+                prt_busy = 1;
+                if (oq.first && !preempt)
+                    goto finalize_only;
+            }
+        }
+
+        ASSERT(!oq.first || preempt);
+
+        /*
+         * Preempt if not all buffers have been handled.
+         */
+        if (preempt && oq.first)
+            goto preempted;
 
 #ifdef DEBUG
-	oq.last = NULL;
+        oq.last = NULL;
 #endif
-	ASSERT(!oq.first);
-	ASSERT(!foq.first && !foq.last);
-
-	/*
-	 * Everything that was buffered when we started have now been
-	 * written to the port. If port isn't busy but dist entry is
-	 * and we havn't got too muched queued on dist entry, set
-	 * dist entry in a non-busy state and resume suspended
-	 * processes.
-	 */
-	erts_smp_mtx_lock(&dep->qlock);
-	ASSERT(dep->qsize >= obufsize);
-	dep->qsize -= obufsize;
-	obufsize = 0;
-	if (!prt_busy
-	    && (dep->qflgs & ERTS_DE_QFLG_BUSY)
-	    && dep->qsize < erts_dist_buf_busy_limit) {
-	    ErtsProcList *suspendees;
-	    int resumed;
-	    suspendees = get_suspended_on_de(dep, ERTS_DE_QFLG_BUSY);
-	    erts_smp_mtx_unlock(&dep->qlock);
-
-	    resumed = erts_resume_processes(suspendees);
-	    reds += resumed*ERTS_PORT_REDS_DIST_CMD_RESUMED;
-	}
-	else
-	    erts_smp_mtx_unlock(&dep->qlock);
+        ASSERT(!oq.first);
+        ASSERT(!foq.first && !foq.last);
+
+        /*
+         * Everything that was buffered when we started have now been
+         * written to the port. If port isn't busy but dist entry is
+         * and we havn't got too muched queued on dist entry, set
+         * dist entry in a non-busy state and resume suspended
+         * processes.
+         */
+        erts_smp_mtx_lock(&dep->qlock);
+        ASSERT(dep->qsize >= obufsize);
+        dep->qsize -= obufsize;
+        obufsize = 0;
+        if (!prt_busy
+                && (dep->qflgs & ERTS_DE_QFLG_BUSY)
+                && dep->qsize < erts_dist_buf_busy_limit) {
+            ErtsProcList *suspendees;
+            int resumed;
+            suspendees = get_suspended_on_de(dep, ERTS_DE_QFLG_BUSY);
+            erts_smp_mtx_unlock(&dep->qlock);
+
+            resumed = erts_resume_processes(suspendees);
+            reds += resumed*ERTS_PORT_REDS_DIST_CMD_RESUMED;
+        }
+        else
+            erts_smp_mtx_unlock(&dep->qlock);
     }
 
     ASSERT(!oq.first && !oq.last);
 
- done:
+    done:
 
     if (obufsize != 0) {
-	ASSERT(obufsize > 0);
-	erts_smp_mtx_lock(&dep->qlock);
-	ASSERT(dep->qsize >= obufsize);
-	dep->qsize -= obufsize;
-	erts_smp_mtx_unlock(&dep->qlock);
+        ASSERT(obufsize > 0);
+        erts_smp_mtx_lock(&dep->qlock);
+        ASSERT(dep->qsize >= obufsize);
+        dep->qsize -= obufsize;
+        erts_smp_mtx_unlock(&dep->qlock);
     }
 
     ASSERT(foq.first || !foq.last);
@@ -1982,69 +1984,69 @@ erts_dist_command(Port *prt, int reds_limit)
     ASSERT(!dep->finalized_out_queue.last);
 
     if (foq.first) {
-	dep->finalized_out_queue.first = foq.first;
-	dep->finalized_out_queue.last = foq.last;
+        dep->finalized_out_queue.first = foq.first;
+        dep->finalized_out_queue.last = foq.last;
     }
 
-     /* Avoid wrapping reduction counter... */
+    /* Avoid wrapping reduction counter... */
     if (reds > INT_MAX/2)
-	reds = INT_MAX/2;
+        reds = INT_MAX/2;
 
     erts_deref_dist_entry(dep);
 
     return reds;
 
- preempted:
+    preempted:
 
     ASSERT(oq.first || !oq.last);
     ASSERT(!oq.first || oq.last);
 
     if (prt->status & ERTS_PORT_SFLGS_DEAD) {
-	/*
-	 * Port died during port command; clean up 'oq'
-	 * and 'foq'. Things buffered in dist entry after
-	 * we begun processing the queues have already been
-	 * cleaned up when port terminated.
-	 */
-
-	if (oq.first)
-	    oq.last->next = foq.first;
-	else
-	    oq.first = foq.first;
-
-	while (oq.first) {
-	    ErtsDistOutputBuf *fob = oq.first;
-	    oq.first = oq.first->next;
-	    obufsize += size_obuf(fob);
-	    free_dist_obuf(fob);
-	}
-
-	foq.first = NULL;
-	foq.last = NULL;
+        /*
+         * Port died during port command; clean up 'oq'
+         * and 'foq'. Things buffered in dist entry after
+         * we begun processing the queues have already been
+         * cleaned up when port terminated.
+         */
+
+        if (oq.first)
+            oq.last->next = foq.first;
+        else
+            oq.first = foq.first;
+
+        while (oq.first) {
+            ErtsDistOutputBuf *fob = oq.first;
+            oq.first = oq.first->next;
+            obufsize += size_obuf(fob);
+            free_dist_obuf(fob);
+        }
+
+        foq.first = NULL;
+        foq.last = NULL;
 
 #ifdef DEBUG
-	erts_smp_mtx_lock(&dep->qlock);
-	ASSERT(dep->qsize == obufsize);
-	erts_smp_mtx_unlock(&dep->qlock);
+        erts_smp_mtx_lock(&dep->qlock);
+        ASSERT(dep->qsize == obufsize);
+        erts_smp_mtx_unlock(&dep->qlock);
 #endif
     }
     else {
-	if (oq.first) {
-	    /*
-	     * Unhandle buffers need to be put back first
-	     * in out_queue.
-	     */
-	    erts_smp_mtx_lock(&dep->qlock);
-	    dep->qsize -= obufsize;
-	    obufsize = 0;
-	    oq.last->next = dep->out_queue.first;
-	    dep->out_queue.first = oq.first;
-	    if (!dep->out_queue.last)
-		dep->out_queue.last = oq.last;
-	    erts_smp_mtx_unlock(&dep->qlock);
-	}
-
-	erts_schedule_dist_command(prt, NULL);
+        if (oq.first) {
+            /*
+             * Unhandle buffers need to be put back first
+             * in out_queue.
+             */
+            erts_smp_mtx_lock(&dep->qlock);
+            dep->qsize -= obufsize;
+            obufsize = 0;
+            oq.last->next = dep->out_queue.first;
+            dep->out_queue.first = oq.first;
+            if (!dep->out_queue.last)
+                dep->out_queue.last = oq.last;
+            erts_smp_mtx_unlock(&dep->qlock);
+        }
+
+        erts_schedule_dist_command(prt, NULL);
     }
     goto done;
 }
@@ -2060,24 +2062,24 @@ erts_kill_dist_connection(DistEntry *dep, Uint32 connection_id)
 {
     erts_smp_de_rwlock(dep);
     if (is_internal_port(dep->cid)
-	&& connection_id == dep->connection_id
-	&& !(dep->status & ERTS_DE_SFLG_EXITING)) {
+            && connection_id == dep->connection_id
+            && !(dep->status & ERTS_DE_SFLG_EXITING)) {
 
-	dep->status |= ERTS_DE_SFLG_EXITING;
+        dep->status |= ERTS_DE_SFLG_EXITING;
 
-	erts_smp_mtx_lock(&dep->qlock);
-	ASSERT(!(dep->qflgs & ERTS_DE_QFLG_EXIT));
-	dep->qflgs |= ERTS_DE_QFLG_EXIT;
-	erts_smp_mtx_unlock(&dep->qlock);
+        erts_smp_mtx_lock(&dep->qlock);
+        ASSERT(!(dep->qflgs & ERTS_DE_QFLG_EXIT));
+        dep->qflgs |= ERTS_DE_QFLG_EXIT;
+        erts_smp_mtx_unlock(&dep->qlock);
 
-	erts_schedule_dist_command(NULL, dep);
+        erts_schedule_dist_command(NULL, dep);
     }
     erts_smp_de_rwunlock(dep);
 }
 
 struct print_to_data {
-    int to;
-    void *arg;
+        int to;
+        void *arg;
 };
 
 static void doit_print_monitor_info(ErtsMonitor *mon, void *vptdp)
@@ -2088,19 +2090,19 @@ static void doit_print_monitor_info(ErtsMonitor *mon, void *vptdp)
     ErtsMonitor *rmon;
     rp = erts_pid2proc_unlocked(mon->pid);
     if (!rp || (rmon = erts_lookup_monitor(rp->monitors, mon->ref)) == NULL) {
-	erts_print(to, arg, "Warning, stray monitor for: %T\n", mon->pid);
+        erts_print(to, arg, "Warning, stray monitor for: %T\n", mon->pid);
     } else if (mon->type == MON_ORIGIN) {
-	/* Local pid is being monitored */
-	erts_print(to, arg, "Remotely monitored by: %T %T\n",
-		   mon->pid, rmon->pid);
+        /* Local pid is being monitored */
+        erts_print(to, arg, "Remotely monitored by: %T %T\n",
+                mon->pid, rmon->pid);
     } else {
-	erts_print(to, arg, "Remote monitoring: %T ", mon->pid);
-	if (is_not_atom(rmon->pid))
-	    erts_print(to, arg, "%T\n", rmon->pid);
-	else
-	    erts_print(to, arg, "{%T, %T}\n",
-		       rmon->name,
-		       rmon->pid); /* which in this case is the 
+        erts_print(to, arg, "Remote monitoring: %T ", mon->pid);
+        if (is_not_atom(rmon->pid))
+            erts_print(to, arg, "%T\n", rmon->pid);
+        else
+            erts_print(to, arg, "{%T, %T}\n",
+                    rmon->name,
+                    rmon->pid); /* which in this case is the 
 				      remote system name... */
     }
 }    
@@ -2112,22 +2114,22 @@ static void print_monitor_info(int to, void *arg, ErtsMonitor *mon)
 }
 
 typedef struct {
-    struct print_to_data *ptdp;
-    Eterm from;
+        struct print_to_data *ptdp;
+        Eterm from;
 } PrintLinkContext;
 
 static void doit_print_link_info2(ErtsLink *lnk, void *vpplc)
 {
     PrintLinkContext *pplc = (PrintLinkContext *) vpplc;
     erts_print(pplc->ptdp->to, pplc->ptdp->arg, "Remote link: %T %T\n",
-	       pplc->from, lnk->pid);
+            pplc->from, lnk->pid);
 }
 
 static void doit_print_link_info(ErtsLink *lnk, void *vptdp)
 {
     if (is_internal_pid(lnk->pid) && erts_pid2proc_unlocked(lnk->pid)) {
-	PrintLinkContext plc = {(struct print_to_data *) vptdp, lnk->pid};
-	erts_doforall_links(ERTS_LINK_ROOT(lnk), &doit_print_link_info2, &plc);
+        PrintLinkContext plc = {(struct print_to_data *) vptdp, lnk->pid};
+        erts_doforall_links(ERTS_LINK_ROOT(lnk), &doit_print_link_info2, &plc);
     } 
 }
 
@@ -2138,18 +2140,18 @@ static void print_link_info(int to, void *arg, ErtsLink *lnk)
 }
 
 typedef struct {
-    struct print_to_data ptd;
-    Eterm sysname;
+        struct print_to_data ptd;
+        Eterm sysname;
 } PrintNodeLinkContext;
-    
+
 
 static void doit_print_nodelink_info(ErtsLink *lnk, void *vpcontext)
 {
     PrintNodeLinkContext *pcontext = vpcontext;
 
     if (is_internal_pid(lnk->pid) && erts_pid2proc_unlocked(lnk->pid))
-	erts_print(pcontext->ptd.to, pcontext->ptd.arg,
-		   "Remote monitoring: %T %T\n", lnk->pid, pcontext->sysname);
+        erts_print(pcontext->ptd.to, pcontext->ptd.arg,
+                "Remote monitoring: %T %T\n", lnk->pid, pcontext->sysname);
 }
 
 static void print_nodelink_info(int to, void *arg, ErtsLink *lnk, Eterm sysname)
@@ -2163,78 +2165,78 @@ static int
 info_dist_entry(int to, void *arg, DistEntry *dep, int visible, int connected)
 {
 
-  if (visible && connected) {
-      erts_print(to, arg, "=visible_node:");
-  } else if (connected) {
-      erts_print(to, arg, "=hidden_node:");
-  } else {
-      erts_print(to, arg, "=not_connected:");
-  }
-  erts_print(to, arg, "%d\n", dist_entry_channel_no(dep));
+    if (visible && connected) {
+        erts_print(to, arg, "=visible_node:");
+    } else if (connected) {
+        erts_print(to, arg, "=hidden_node:");
+    } else {
+        erts_print(to, arg, "=not_connected:");
+    }
+    erts_print(to, arg, "%d\n", dist_entry_channel_no(dep));
 
-  if(connected && is_nil(dep->cid)) {
-    erts_print(to, arg,
-	       "Error: Not connected node still registered as connected:%T\n",
-	       dep->sysname);
-    return 0;
-  }
+    if(connected && is_nil(dep->cid)) {
+        erts_print(to, arg,
+                "Error: Not connected node still registered as connected:%T\n",
+                dep->sysname);
+        return 0;
+    }
 
-  if(!connected && is_not_nil(dep->cid)) {
-    erts_print(to, arg,
-	       "Error: Connected node not registered as connected:%T\n",
-	       dep->sysname);
-    return 0;
-  }
+    if(!connected && is_not_nil(dep->cid)) {
+        erts_print(to, arg,
+                "Error: Connected node not registered as connected:%T\n",
+                dep->sysname);
+        return 0;
+    }
 
-  erts_print(to, arg, "Name: %T", dep->sysname);
+    erts_print(to, arg, "Name: %T", dep->sysname);
 #ifdef DEBUG
-  erts_print(to, arg, " (refc=%d)", erts_refc_read(&dep->refc, 1));
+    erts_print(to, arg, " (refc=%d)", erts_refc_read(&dep->refc, 1));
 #endif
-  erts_print(to, arg, "\n");
-  if (!connected && is_nil(dep->cid)) {
-    if (dep->nlinks) {
-      erts_print(to, arg, "Error: Got links to not connected node:%T\n",
-		 dep->sysname);
+    erts_print(to, arg, "\n");
+    if (!connected && is_nil(dep->cid)) {
+        if (dep->nlinks) {
+            erts_print(to, arg, "Error: Got links to not connected node:%T\n",
+                    dep->sysname);
+        }
+        return 0;
     }
-    return 0;
-  }
 
-  erts_print(to, arg, "Controller: %T\n", dep->cid, to);
+    erts_print(to, arg, "Controller: %T\n", dep->cid, to);
+
+    erts_print_node_info(to, arg, dep->sysname, NULL, NULL);
+    print_monitor_info(to, arg, dep->monitors);
+    print_link_info(to, arg, dep->nlinks);
+    print_nodelink_info(to, arg, dep->node_links, dep->sysname);
 
-  erts_print_node_info(to, arg, dep->sysname, NULL, NULL);
-  print_monitor_info(to, arg, dep->monitors);
-  print_link_info(to, arg, dep->nlinks);
-  print_nodelink_info(to, arg, dep->node_links, dep->sysname);
+    return 0;
 
-  return 0;
-    
 }
 int distribution_info(int to, void *arg)	/* Called by break handler */
 {
     DistEntry *dep;
 
     erts_print(to, arg, "=node:%T\n", erts_this_dist_entry->sysname);
- 
+
     if (erts_this_node->sysname == am_Noname) {
-	erts_print(to, arg, "=no_distribution\n");
-	return(0);
+        erts_print(to, arg, "=no_distribution\n");
+        return(0);
     }
 
 #if 0
     if (!erts_visible_dist_entries && !erts_hidden_dist_entries) 
-      erts_print(to, arg, "Alive but not holding any connections \n");
+        erts_print(to, arg, "Alive but not holding any connections \n");
 #endif
 
     for(dep = erts_visible_dist_entries; dep; dep = dep->next) {
-      info_dist_entry(to, arg, dep, 1, 1);
+        info_dist_entry(to, arg, dep, 1, 1);
     }
 
     for(dep = erts_hidden_dist_entries; dep; dep = dep->next) {
-      info_dist_entry(to, arg, dep, 0, 1);
+        info_dist_entry(to, arg, dep, 0, 1);
     }
 
     for (dep = erts_not_connected_dist_entries; dep; dep = dep->next) {
-	info_dist_entry(to, arg, dep, 0, 0);
+        info_dist_entry(to, arg, dep, 0, 0);
     }
 
     return(0);
@@ -2256,7 +2258,7 @@ int distribution_info(int to, void *arg)	/* Called by break handler */
             dist_exit/3       -- send exit signals from remote to local process
             dist_link/2       -- link a remote process to a local
             dist_unlink/2     -- unlink a remote from a local
-****************************************************************************/
+ ****************************************************************************/
 
 
 
@@ -2281,48 +2283,48 @@ BIF_RETTYPE setnode_2(BIF_ALIST_2)
 
     /* valid creation ? */
     if(!term_to_Uint(BIF_ARG_2, &creation))
-	goto error;
+        goto error;
     if(creation > 3)
-	goto error;
+        goto error;
 
     /* valid node name ? */
     if (!is_node_name_atom(BIF_ARG_1))
-	goto error;
+        goto error;
 
     if (BIF_ARG_1 == am_Noname) /* cant use this name !! */
-	goto error;
+        goto error;
     if (erts_is_alive)     /* must not be alive! */
-	goto error;
+        goto error;
 
     /* Check that all trap functions are defined !! */
     if (dsend2_trap->address == NULL ||
-	dsend3_trap->address == NULL ||
-	/*	dsend_nosuspend_trap->address == NULL ||*/
-	dlink_trap->address == NULL ||
-	dunlink_trap->address == NULL ||
-	dmonitor_node_trap->address == NULL ||
-	dgroup_leader_trap->address == NULL ||
-	dmonitor_p_trap->address == NULL ||
-	dexit_trap->address == NULL) {
-	goto error;
+            dsend3_trap->address == NULL ||
+            /*	dsend_nosuspend_trap->address == NULL ||*/
+            dlink_trap->address == NULL ||
+            dunlink_trap->address == NULL ||
+            dmonitor_node_trap->address == NULL ||
+            dgroup_leader_trap->address == NULL ||
+            dmonitor_p_trap->address == NULL ||
+            dexit_trap->address == NULL) {
+        goto error;
     }
 
     net_kernel = erts_whereis_process(BIF_P, ERTS_PROC_LOCK_MAIN,
-				      am_net_kernel, ERTS_PROC_LOCK_MAIN, 0);
+            am_net_kernel, ERTS_PROC_LOCK_MAIN, 0);
     if (!net_kernel)
-	goto error;
+        goto error;
 
     /* By setting dist_entry==erts_this_dist_entry and DISTRIBUTION on
        net_kernel do_net_exist will be called when net_kernel
        is terminated !! */
     (void *) ERTS_PROC_SET_DIST_ENTRY(net_kernel,
-				      ERTS_PROC_LOCK_MAIN,
-				      erts_this_dist_entry);
+            ERTS_PROC_LOCK_MAIN,
+            erts_this_dist_entry);
     erts_refc_inc(&erts_this_dist_entry->refc, 2);
     net_kernel->flags |= F_DISTRIBUTION;
 
     if (net_kernel != BIF_P)
-	erts_smp_proc_unlock(net_kernel, ERTS_PROC_LOCK_MAIN);
+        erts_smp_proc_unlock(net_kernel, ERTS_PROC_LOCK_MAIN);
 
 #ifdef DEBUG
     erts_smp_rwmtx_rwlock(&erts_dist_table_rwmtx);
@@ -2340,7 +2342,7 @@ BIF_RETTYPE setnode_2(BIF_ALIST_2)
 
     BIF_RET(am_true);
 
- error:
+    error:
     BIF_ERROR(BIF_P, BADARG);
 }
 
@@ -2377,38 +2379,38 @@ BIF_RETTYPE setnode_3(BIF_ALIST_3)
      */
 
     if (!is_node_name_atom(BIF_ARG_1) ||
-	is_not_internal_port(BIF_ARG_2) ||
-	(erts_this_node->sysname == am_Noname)) {
-	goto badarg;
+            is_not_internal_port(BIF_ARG_2) ||
+            (erts_this_node->sysname == am_Noname)) {
+        goto badarg;
     }
 
     if (!is_tuple(BIF_ARG_3))
-	goto badarg;
+        goto badarg;
     tp = tuple_val(BIF_ARG_3);
     if (*tp++ != make_arityval(4))
-	goto badarg;
+        goto badarg;
     if (!is_small(*tp))
-	goto badarg;
+        goto badarg;
     flags = unsigned_val(*tp++);
     if (!is_small(*tp) || (version = unsigned_val(*tp)) == 0)
-	goto badarg;
+        goto badarg;
     ic = *(++tp);
     oc = *(++tp);
     if (!is_atom(ic) || !is_atom(oc))
-	goto badarg;
+        goto badarg;
 
     /* DFLAG_EXTENDED_REFERENCES is compulsory from R9 and forward */
     if (!(DFLAG_EXTENDED_REFERENCES & flags)) {
-	erts_dsprintf_buf_t *dsbufp = erts_create_logger_dsbuf();
-	erts_dsprintf(dsbufp, "%T", BIF_P->id);
-	if (BIF_P->reg)
-	    erts_dsprintf(dsbufp, " (%T)", BIF_P->reg->name);
-	erts_dsprintf(dsbufp,
-		      " attempted to enable connection to node %T "
-		      "which is not able to handle extended references.\n",
-		      BIF_ARG_1);
-	erts_send_error_to_logger(BIF_P->group_leader, dsbufp);
-	goto badarg;
+        erts_dsprintf_buf_t *dsbufp = erts_create_logger_dsbuf();
+        erts_dsprintf(dsbufp, "%T", BIF_P->id);
+        if (BIF_P->reg)
+            erts_dsprintf(dsbufp, " (%T)", BIF_P->reg->name);
+        erts_dsprintf(dsbufp,
+                " attempted to enable connection to node %T "
+                "which is not able to handle extended references.\n",
+                BIF_ARG_1);
+        erts_send_error_to_logger(BIF_P->group_leader, dsbufp);
+        goto badarg;
     }
 
     /*
@@ -2418,41 +2420,41 @@ BIF_RETTYPE setnode_3(BIF_ALIST_3)
     /* get dist_entry */
     dep = erts_find_or_insert_dist_entry(BIF_ARG_1);
     if (dep == erts_this_dist_entry)
-	goto badarg;
+        goto badarg;
     else if (!dep)
-	goto system_limit; /* Should never happen!!! */
+        goto system_limit; /* Should never happen!!! */
 
     pp = erts_id2port(BIF_ARG_2, BIF_P, ERTS_PROC_LOCK_MAIN);
     erts_smp_de_rwlock(dep);
 
     if (!pp || (pp->status & ERTS_PORT_SFLG_EXITING))
-	goto badarg;
+        goto badarg;
 
     if ((pp->drv_ptr->flags & ERL_DRV_FLAG_SOFT_BUSY) == 0)
-	goto badarg;
+        goto badarg;
 
     if (dep->cid == BIF_ARG_2 && pp->dist_entry == dep)
-	goto done; /* Already set */
+        goto done; /* Already set */
 
     if (dep->status & ERTS_DE_SFLG_EXITING) {
-	/* Suspend on dist entry waiting for the exit to finish */
-	ErtsProcList *plp = erts_proclist_create(BIF_P);
-	plp->next = NULL;
-	erts_suspend(BIF_P, ERTS_PROC_LOCK_MAIN, NULL);
-	erts_smp_mtx_lock(&dep->qlock);
-	if (dep->suspended.last)
-	    dep->suspended.last->next = plp;
-	else
-	    dep->suspended.first = plp;
-	dep->suspended.last = plp;
-	erts_smp_mtx_unlock(&dep->qlock);
-	goto yield;
+        /* Suspend on dist entry waiting for the exit to finish */
+        ErtsProcList *plp = erts_proclist_create(BIF_P);
+        plp->next = NULL;
+        erts_suspend(BIF_P, ERTS_PROC_LOCK_MAIN, NULL);
+        erts_smp_mtx_lock(&dep->qlock);
+        if (dep->suspended.last)
+            dep->suspended.last->next = plp;
+        else
+            dep->suspended.first = plp;
+        dep->suspended.last = plp;
+        erts_smp_mtx_unlock(&dep->qlock);
+        goto yield;
     }
 
     ASSERT(!(dep->status & ERTS_DE_SFLG_EXITING));
 
     if (pp->dist_entry || is_not_nil(dep->cid))
-	goto badarg;
+        goto badarg;
 
     erts_port_status_bor_set(pp, ERTS_PORT_SFLG_DISTRIBUTION);
 
@@ -2465,8 +2467,8 @@ BIF_RETTYPE setnode_3(BIF_ALIST_3)
 
 #if 1
     dep->send = (pp->drv_ptr->outputv
-		 ? dist_port_commandv
-		 : dist_port_command);
+            ? dist_port_commandv
+                    : dist_port_command);
 #else
     dep->send = dist_port_command;
 #endif
@@ -2481,38 +2483,38 @@ BIF_RETTYPE setnode_3(BIF_ALIST_3)
     erts_set_dist_entry_connected(dep, BIF_ARG_2, flags);
 
     if (flags & DFLAG_DIST_HDR_ATOM_CACHE)
-	create_cache(dep);
+        create_cache(dep);
 
     erts_smp_de_rwunlock(dep);
     dep = NULL; /* inc of refc transferred to port (dist_entry field) */
 
     send_nodes_mon_msgs(BIF_P,
-			am_nodeup,
-			BIF_ARG_1,
-			flags & DFLAG_PUBLISHED ? am_visible : am_hidden,
-			NIL);
- done:
+            am_nodeup,
+            BIF_ARG_1,
+            flags & DFLAG_PUBLISHED ? am_visible : am_hidden,
+                    NIL);
+    done:
 
     if (dep && dep != erts_this_dist_entry) {
-	erts_smp_de_rwunlock(dep);
-	erts_deref_dist_entry(dep);
+        erts_smp_de_rwunlock(dep);
+        erts_deref_dist_entry(dep);
     }
 
     if (pp)
-	erts_smp_port_unlock(pp);
+        erts_smp_port_unlock(pp);
 
     return ret;
 
- yield:
+    yield:
     ERTS_BIF_PREP_YIELD3(ret, bif_export[BIF_setnode_3], BIF_P,
-			 BIF_ARG_1, BIF_ARG_2, BIF_ARG_3);
+            BIF_ARG_1, BIF_ARG_2, BIF_ARG_3);
     goto done;
 
- badarg:
+    badarg:
     ERTS_BIF_PREP_ERROR(ret, BIF_P, BADARG);
     goto done;
 
- system_limit:
+    system_limit:
     ERTS_BIF_PREP_ERROR(ret, BIF_P, SYSTEM_LIMIT);
     goto done;
 }
@@ -2532,64 +2534,64 @@ BIF_RETTYPE dist_exit_3(BIF_ALIST_3)
 
     /* Check that remote is a remote process */
     if (is_not_external_pid(remote))
-	goto error;
+        goto error;
 
     rdep = external_dist_entry(remote);
-    
+
     if(rdep == erts_this_dist_entry)
-	goto error;
+        goto error;
 
     /* Check that local is local */
     if (is_internal_pid(local)) {
-	Process *lp;
-	ErtsProcLocks lp_locks;
-	if (BIF_P->id == local) {
-	    lp_locks = ERTS_PROC_LOCKS_ALL;
-	    lp = BIF_P;
-	    erts_smp_proc_lock(BIF_P, ERTS_PROC_LOCKS_ALL_MINOR);
-	}
-	else {
-	    lp_locks = ERTS_PROC_LOCKS_XSIG_SEND;
-	    lp = erts_pid2proc_opt(BIF_P, ERTS_PROC_LOCK_MAIN,
-				   local, lp_locks,
-				   ERTS_P2P_FLG_SMP_INC_REFC);
-	    if (!lp) {
-		BIF_RET(am_true); /* ignore */
-	    }
-	}
-	
-	(void) erts_send_exit_signal(BIF_P,
-				     remote,
-				     lp,
-				     &lp_locks,
-				     BIF_ARG_2,
-				     NIL,
-				     NULL,
-				     0);
+        Process *lp;
+        ErtsProcLocks lp_locks;
+        if (BIF_P->id == local) {
+            lp_locks = ERTS_PROC_LOCKS_ALL;
+            lp = BIF_P;
+            erts_smp_proc_lock(BIF_P, ERTS_PROC_LOCKS_ALL_MINOR);
+        }
+        else {
+            lp_locks = ERTS_PROC_LOCKS_XSIG_SEND;
+            lp = erts_pid2proc_opt(BIF_P, ERTS_PROC_LOCK_MAIN,
+                    local, lp_locks,
+                    ERTS_P2P_FLG_SMP_INC_REFC);
+            if (!lp) {
+                BIF_RET(am_true); /* ignore */
+            }
+        }
+
+        (void) erts_send_exit_signal(BIF_P,
+                remote,
+                lp,
+                &lp_locks,
+                BIF_ARG_2,
+                NIL,
+                NULL,
+                0);
 #ifdef ERTS_SMP
-	if (lp == BIF_P)
-	    lp_locks &= ~ERTS_PROC_LOCK_MAIN;
+        if (lp == BIF_P)
+            lp_locks &= ~ERTS_PROC_LOCK_MAIN;
 #endif
-	erts_smp_proc_unlock(lp, lp_locks);
-	if (lp != BIF_P)
-	    erts_smp_proc_dec_refc(lp);
-	else {
-	    /*
-	     * We may have exited current process and may have to take action.
-	     */
-	    ERTS_BIF_CHK_EXITED(BIF_P);
-	    ERTS_SMP_BIF_CHK_PENDING_EXIT(BIF_P, ERTS_PROC_LOCK_MAIN);
-	}
+        erts_smp_proc_unlock(lp, lp_locks);
+        if (lp != BIF_P)
+            erts_smp_proc_dec_refc(lp);
+        else {
+            /*
+             * We may have exited current process and may have to take action.
+             */
+            ERTS_BIF_CHK_EXITED(BIF_P);
+            ERTS_SMP_BIF_CHK_PENDING_EXIT(BIF_P, ERTS_PROC_LOCK_MAIN);
+        }
     }
     else if (is_external_pid(local)
-	     && external_dist_entry(local) == erts_this_dist_entry) {
-	BIF_RET(am_true); /* ignore */
+            && external_dist_entry(local) == erts_this_dist_entry) {
+        BIF_RET(am_true); /* ignore */
     }
     else
-	goto error;
+        goto error;
     BIF_RET(am_true);
 
- error:
+    error:
     BIF_ERROR(BIF_P, BADARG);
 }
 
@@ -2599,7 +2601,7 @@ BIF_RETTYPE dist_exit_3(BIF_ALIST_3)
 BIF_RETTYPE node_1(BIF_ALIST_1)
 { 
     if (is_not_node_container(BIF_ARG_1))
-      BIF_ERROR(BIF_P, BADARG);
+        BIF_ERROR(BIF_P, BADARG);
     BIF_RET(node_container_node_name(BIF_ARG_1));
 }
 
@@ -2618,7 +2620,7 @@ BIF_RETTYPE node_0(BIF_ALIST_0)
 #if 0 /* Done in erlang.erl instead. */
 BIF_RETTYPE nodes_0(BIF_ALIST_0)
 {
-  return nodes_1(BIF_P, am_visible);
+    return nodes_1(BIF_P, am_visible);
 }
 #endif
 
@@ -2642,22 +2644,22 @@ BIF_RETTYPE nodes_1(BIF_ALIST_1)
     UseTmpHeap(2,BIF_P);
 
     if (is_atom(BIF_ARG_1))
-      arg_list = CONS(buf, BIF_ARG_1, NIL);
+        arg_list = CONS(buf, BIF_ARG_1, NIL);
 
     while (is_list(arg_list)) {
-      switch(CAR(list_val(arg_list))) {
-      case am_visible:   visible = 1;                                 break;
-      case am_hidden:    hidden = 1;                                  break;
-      case am_known:     visible = hidden = not_connected = this = 1; break;
-      case am_this:      this = 1;                                    break;
-      case am_connected: visible = hidden = 1;                        break;
-      default:           goto error;                                  break;
-      }
-      arg_list = CDR(list_val(arg_list));
+        switch(CAR(list_val(arg_list))) {
+            case am_visible:   visible = 1;                                 break;
+            case am_hidden:    hidden = 1;                                  break;
+            case am_known:     visible = hidden = not_connected = this = 1; break;
+            case am_this:      this = 1;                                    break;
+            case am_connected: visible = hidden = 1;                        break;
+            default:           goto error;                                  break;
+        }
+        arg_list = CDR(list_val(arg_list));
     }
 
     if (is_not_nil(arg_list)) {
-	goto error;
+        goto error;
     }
 
     length = 0;
@@ -2668,19 +2670,19 @@ BIF_RETTYPE nodes_1(BIF_ALIST_1)
     ASSERT(erts_no_of_hidden_dist_entries >= 0);
     ASSERT(erts_no_of_visible_dist_entries >= 0);
     if(not_connected)
-      length += erts_no_of_not_connected_dist_entries;
+        length += erts_no_of_not_connected_dist_entries;
     if(hidden)
-      length += erts_no_of_hidden_dist_entries;
+        length += erts_no_of_hidden_dist_entries;
     if(visible)
-      length += erts_no_of_visible_dist_entries;
+        length += erts_no_of_visible_dist_entries;
     if(this)
-      length++;
+        length++;
 
     result = NIL;
 
     if (length == 0) {
-	erts_smp_rwmtx_rwunlock(&erts_dist_table_rwmtx);
-	goto done;
+        erts_smp_rwmtx_rwunlock(&erts_dist_table_rwmtx);
+        goto done;
     }
 
     hp = HAlloc(BIF_P, 2*length);
@@ -2689,32 +2691,32 @@ BIF_RETTYPE nodes_1(BIF_ALIST_1)
     endp = hp + length*2;
 #endif
     if(not_connected)
-      for(dep = erts_not_connected_dist_entries; dep; dep = dep->next) {
-	result = CONS(hp, dep->sysname, result);
-	hp += 2;
-      }
+        for(dep = erts_not_connected_dist_entries; dep; dep = dep->next) {
+            result = CONS(hp, dep->sysname, result);
+            hp += 2;
+        }
     if(hidden)
-      for(dep = erts_hidden_dist_entries; dep; dep = dep->next) {
-	result = CONS(hp, dep->sysname, result);
-	hp += 2;
-      }
+        for(dep = erts_hidden_dist_entries; dep; dep = dep->next) {
+            result = CONS(hp, dep->sysname, result);
+            hp += 2;
+        }
     if(visible)
-      for(dep = erts_visible_dist_entries; dep; dep = dep->next) {
-	result = CONS(hp, dep->sysname, result);
-	hp += 2;
-      }
+        for(dep = erts_visible_dist_entries; dep; dep = dep->next) {
+            result = CONS(hp, dep->sysname, result);
+            hp += 2;
+        }
     if(this) {
-	result = CONS(hp, erts_this_dist_entry->sysname, result);
-	hp += 2;
+        result = CONS(hp, erts_this_dist_entry->sysname, result);
+        hp += 2;
     }
     ASSERT(endp == hp);
     erts_smp_rwmtx_rwunlock(&erts_dist_table_rwmtx);
 
-done:
+    done:
     UnUseTmpHeap(2,BIF_P);
     BIF_RET(result);
 
-error:
+    error:
     UnUseTmpHeap(2,BIF_P);
     BIF_ERROR(BIF_P,BADARG);
 }
@@ -2739,69 +2741,69 @@ monitor_node(Process* p, Eterm Node, Eterm Bool, Eterm Options)
     Eterm l;
 
     for (l = Options; l != NIL && is_list(l); l = CDR(list_val(l))) {
-	Eterm t = CAR(list_val(l));
-	/* allow_passive_connect the only available option right now */
-	if (t != am_allow_passive_connect) {
-	    BIF_ERROR(p, BADARG);
-	}
+        Eterm t = CAR(list_val(l));
+        /* allow_passive_connect the only available option right now */
+        if (t != am_allow_passive_connect) {
+            BIF_ERROR(p, BADARG);
+        }
     }
     if (l != NIL) {
-	BIF_ERROR(p, BADARG);
+        BIF_ERROR(p, BADARG);
     }
 
     if (is_not_atom(Node) ||
-	((Bool != am_true) && (Bool != am_false)) ||
-	((erts_this_node->sysname == am_Noname)
-	 && (Node != erts_this_node->sysname))) {
-	BIF_ERROR(p, BADARG);
+            ((Bool != am_true) && (Bool != am_false)) ||
+            ((erts_this_node->sysname == am_Noname)
+                    && (Node != erts_this_node->sysname))) {
+        BIF_ERROR(p, BADARG);
     }
     dep = erts_sysname_to_connected_dist_entry(Node);
     if (!dep) {
-    do_trap:
-	BIF_TRAP3(dmonitor_node_trap, p, Node, Bool, Options);
+        do_trap:
+        BIF_TRAP3(dmonitor_node_trap, p, Node, Bool, Options);
     }
     if (dep == erts_this_dist_entry)
-	goto done;
+        goto done;
 
     erts_smp_proc_lock(p, ERTS_PROC_LOCK_LINK);
     erts_smp_de_rlock(dep);
     if (ERTS_DE_IS_NOT_CONNECTED(dep)) {
-	erts_smp_proc_unlock(p, ERTS_PROC_LOCK_LINK);
-	erts_smp_de_runlock(dep);
-	goto do_trap;
+        erts_smp_proc_unlock(p, ERTS_PROC_LOCK_LINK);
+        erts_smp_de_runlock(dep);
+        goto do_trap;
     }
     erts_smp_de_links_lock(dep);
     erts_smp_de_runlock(dep);
 
     if (Bool == am_true) {
-	ASSERT(dep->cid != NIL);
-	lnk = erts_add_or_lookup_link(&(dep->node_links), LINK_NODE, 
-				      p->id);
-	++ERTS_LINK_REFC(lnk);
-	lnk = erts_add_or_lookup_link(&(p->nlinks), LINK_NODE, Node);
-	++ERTS_LINK_REFC(lnk);
+        ASSERT(dep->cid != NIL);
+        lnk = erts_add_or_lookup_link(&(dep->node_links), LINK_NODE, 
+                p->id);
+        ++ERTS_LINK_REFC(lnk);
+        lnk = erts_add_or_lookup_link(&(p->nlinks), LINK_NODE, Node);
+        ++ERTS_LINK_REFC(lnk);
     }
     else  {
-	lnk = erts_lookup_link(dep->node_links, p->id);
-	if (lnk != NULL) {
-	    if ((--ERTS_LINK_REFC(lnk)) == 0) {
-		erts_destroy_link(erts_remove_link(&(dep->node_links), 
-						   p->id));
-	    }
-	}
-	lnk = erts_lookup_link(p->nlinks, Node);
-	if (lnk != NULL) {
-	    if ((--ERTS_LINK_REFC(lnk)) == 0) {
-		erts_destroy_link(erts_remove_link(&(p->nlinks),
-						   Node));
-	    }
-	}
+        lnk = erts_lookup_link(dep->node_links, p->id);
+        if (lnk != NULL) {
+            if ((--ERTS_LINK_REFC(lnk)) == 0) {
+                erts_destroy_link(erts_remove_link(&(dep->node_links), 
+                        p->id));
+            }
+        }
+        lnk = erts_lookup_link(p->nlinks, Node);
+        if (lnk != NULL) {
+            if ((--ERTS_LINK_REFC(lnk)) == 0) {
+                erts_destroy_link(erts_remove_link(&(p->nlinks),
+                        Node));
+            }
+        }
     }
 
     erts_smp_de_links_unlock(dep);
     erts_smp_proc_unlock(p, ERTS_PROC_LOCK_LINK);
 
- done:
+    done:
     erts_deref_dist_entry(dep);
     BIF_RET(am_true);
 }
@@ -2824,19 +2826,19 @@ BIF_RETTYPE net_kernel_dflag_unicode_io_1(BIF_ALIST_1)
     DistEntry *de;
     Uint32 f;
     if (is_not_pid(BIF_ARG_1)) {
-	BIF_ERROR(BIF_P,BADARG);
+        BIF_ERROR(BIF_P,BADARG);
     }
     de = pid_dist_entry(BIF_ARG_1);
     ASSERT(de != NULL);
     if (de == erts_this_dist_entry) {
-	BIF_RET(am_true);
+        BIF_RET(am_true);
     }
     erts_smp_de_rlock(de);
     f = de->flags;
     erts_smp_de_runlock(de);
     BIF_RET(((f & DFLAG_UNICODE_IO) ? am_true : am_false));
 }
-    
+
 /*
  * The major part of the implementation of net_kernel:monitor_nodes/[1,2]
  * follows.
@@ -2852,15 +2854,15 @@ BIF_RETTYPE net_kernel_dflag_unicode_io_1(BIF_ALIST_1)
 #define ERTS_NODES_MON_OPT_DOWN_REASON		(((Uint16) 1) << 2)
 
 #define ERTS_NODES_MON_OPT_TYPES \
-  (ERTS_NODES_MON_OPT_TYPE_VISIBLE|ERTS_NODES_MON_OPT_TYPE_HIDDEN)
+        (ERTS_NODES_MON_OPT_TYPE_VISIBLE|ERTS_NODES_MON_OPT_TYPE_HIDDEN)
 
 typedef struct ErtsNodesMonitor_ ErtsNodesMonitor;
 struct ErtsNodesMonitor_ {
-    ErtsNodesMonitor *prev;
-    ErtsNodesMonitor *next;
-    Process *proc;
-    Uint16 opts;
-    Uint16 no;
+        ErtsNodesMonitor *prev;
+        ErtsNodesMonitor *next;
+        Process *proc;
+        Uint16 opts;
+        Uint16 no;
 };
 
 static erts_smp_mtx_t nodes_monitors_mtx;
@@ -2891,35 +2893,35 @@ nodes_mon_msg_sz(ErtsNodesMonitor *nmp, Eterm what, Eterm reason)
 {
     Uint sz;
     if (!nmp->opts) {
-	sz = 3;
+        sz = 3;
     }
     else {
-	sz = 0;
+        sz = 0;
 
-	if (nmp->opts & ERTS_NODES_MON_OPT_TYPES)
-	    sz += 2 + 3;
+        if (nmp->opts & ERTS_NODES_MON_OPT_TYPES)
+            sz += 2 + 3;
 
-	if (what == am_nodedown
-	    && (nmp->opts & ERTS_NODES_MON_OPT_DOWN_REASON)) {
-	    if (is_not_immed(reason))
-		sz += size_object(reason);
-	    sz += 2 + 3;
-	}
+        if (what == am_nodedown
+                && (nmp->opts & ERTS_NODES_MON_OPT_DOWN_REASON)) {
+            if (is_not_immed(reason))
+                sz += size_object(reason);
+            sz += 2 + 3;
+        }
 
-	sz += 4;
+        sz += 4;
     }
     return sz;
 }
 
 static ERTS_INLINE void
 send_nodes_mon_msg(Process *rp,
-		   ErtsProcLocks *rp_locksp,
-		   ErtsNodesMonitor *nmp,
-		   Eterm node,
-		   Eterm what,
-		   Eterm type,
-		   Eterm reason,
-		   Uint sz)
+        ErtsProcLocks *rp_locksp,
+        ErtsNodesMonitor *nmp,
+        Eterm node,
+        Eterm what,
+        Eterm type,
+        Eterm reason,
+        Uint sz)
 {
     Eterm msg;
     ErlHeapFragment* bp;
@@ -2930,44 +2932,44 @@ send_nodes_mon_msg(Process *rp,
 #endif
 
     if (!nmp->opts) {
-	msg = TUPLE2(hp, what, node);
+        msg = TUPLE2(hp, what, node);
 #ifdef DEBUG
-	hp += 3;
+        hp += 3;
 #endif
     }
     else {
-	Eterm tup;
-	Eterm info = NIL;
-
-	if (nmp->opts & (ERTS_NODES_MON_OPT_TYPE_VISIBLE
-			 | ERTS_NODES_MON_OPT_TYPE_HIDDEN)) {
-
-	    tup = TUPLE2(hp, am_node_type, type);
-	    hp += 3;
-	    info = CONS(hp, tup, info);
-	    hp += 2;
-	}
-
-	if (what == am_nodedown
-	    && (nmp->opts & ERTS_NODES_MON_OPT_DOWN_REASON)) {
-	    Eterm rsn_cpy;
-	    
-	    if (is_immed(reason))
-		rsn_cpy = reason;
-	    else {
-		Eterm rsn_sz = size_object(reason);
-		rsn_cpy = copy_struct(reason, rsn_sz, &hp, ohp);
-	    }
-
-	    tup = TUPLE2(hp, am_nodedown_reason, rsn_cpy);
-	    hp += 3;
-	    info = CONS(hp, tup, info);
-	    hp += 2;
-	}
-
-	msg = TUPLE3(hp, what, node, info);
+        Eterm tup;
+        Eterm info = NIL;
+
+        if (nmp->opts & (ERTS_NODES_MON_OPT_TYPE_VISIBLE
+                | ERTS_NODES_MON_OPT_TYPE_HIDDEN)) {
+
+            tup = TUPLE2(hp, am_node_type, type);
+            hp += 3;
+            info = CONS(hp, tup, info);
+            hp += 2;
+        }
+
+        if (what == am_nodedown
+                && (nmp->opts & ERTS_NODES_MON_OPT_DOWN_REASON)) {
+            Eterm rsn_cpy;
+
+            if (is_immed(reason))
+                rsn_cpy = reason;
+            else {
+                Eterm rsn_sz = size_object(reason);
+                rsn_cpy = copy_struct(reason, rsn_sz, &hp, ohp);
+            }
+
+            tup = TUPLE2(hp, am_nodedown_reason, rsn_cpy);
+            hp += 3;
+            info = CONS(hp, tup, info);
+            hp += 2;
+        }
+
+        msg = TUPLE3(hp, what, node, info);
 #ifdef DEBUG
-	hp += 4;
+        hp += 4;
 #endif
     }
 
@@ -2987,69 +2989,69 @@ send_nodes_mon_msgs(Process *c_p, Eterm what, Eterm node, Eterm type, Eterm reas
     ASSERT(is_immed(type));
 
     ERTS_SMP_LC_ASSERT(!c_p
-		       || (erts_proc_lc_my_proc_locks(c_p)
-			   == ERTS_PROC_LOCK_MAIN));
+            || (erts_proc_lc_my_proc_locks(c_p)
+                    == ERTS_PROC_LOCK_MAIN));
     erts_smp_mtx_lock(&nodes_monitors_mtx);
 
     for (nmp = nodes_monitors; nmp; nmp = nmp->next) {
-	int i;
-	Uint16 no;
-	Uint sz;
-
-	ASSERT(nmp->proc != NULL);
-
-	if (!nmp->opts) {
-	    if (type != am_visible)
-		continue;
-	}
-	else {
-	    switch (type) {
-	    case am_hidden:
-		if (!(nmp->opts & ERTS_NODES_MON_OPT_TYPE_HIDDEN))
-		    continue;
-		break;
-	    case am_visible:
-		if ((nmp->opts & ERTS_NODES_MON_OPT_TYPES)
-		    && !(nmp->opts & ERTS_NODES_MON_OPT_TYPE_VISIBLE))
-		    continue;
-		break;
-	    default:
-		erl_exit(ERTS_ABORT_EXIT, "Bad node type found\n");
-	    }
-	}
-
-	if (rp != nmp->proc) {
-	    if (rp) {
-		if (rp == c_p)
-		    rp_locks &= ~ERTS_PROC_LOCK_MAIN;
-		erts_smp_proc_unlock(rp, rp_locks);
-	    }
-
-	    rp = nmp->proc;
-	    rp_locks = 0;
-	    if (rp == c_p)
-		rp_locks |= ERTS_PROC_LOCK_MAIN;
-	}
-
-	ASSERT(rp);
-
-	sz = nodes_mon_msg_sz(nmp, what, reason);
-
-	for (i = 0, no = nmp->no; i < no; i++)
-	    send_nodes_mon_msg(rp,
-			       &rp_locks,
-			       nmp,
-			       node,
-			       what,
-			       type,
-			       reason,
-			       sz);
+        int i;
+        Uint16 no;
+        Uint sz;
+
+        ASSERT(nmp->proc != NULL);
+
+        if (!nmp->opts) {
+            if (type != am_visible)
+                continue;
+        }
+        else {
+            switch (type) {
+                case am_hidden:
+                    if (!(nmp->opts & ERTS_NODES_MON_OPT_TYPE_HIDDEN))
+                        continue;
+                    break;
+                case am_visible:
+                    if ((nmp->opts & ERTS_NODES_MON_OPT_TYPES)
+                            && !(nmp->opts & ERTS_NODES_MON_OPT_TYPE_VISIBLE))
+                        continue;
+                    break;
+                default:
+                    erl_exit(ERTS_ABORT_EXIT, "Bad node type found\n");
+            }
+        }
+
+        if (rp != nmp->proc) {
+            if (rp) {
+                if (rp == c_p)
+                    rp_locks &= ~ERTS_PROC_LOCK_MAIN;
+                erts_smp_proc_unlock(rp, rp_locks);
+            }
+
+            rp = nmp->proc;
+            rp_locks = 0;
+            if (rp == c_p)
+                rp_locks |= ERTS_PROC_LOCK_MAIN;
+        }
+
+        ASSERT(rp);
+
+        sz = nodes_mon_msg_sz(nmp, what, reason);
+
+        for (i = 0, no = nmp->no; i < no; i++)
+            send_nodes_mon_msg(rp,
+                    &rp_locks,
+                    nmp,
+                    node,
+                    what,
+                    type,
+                    reason,
+                    sz);
     }
 
     if (rp) {
-	if (rp == c_p)
-	    rp_locks &= ~ERTS_PROC_LOCK_MAIN;
-	erts_smp_proc_unlock(rp, rp_locks);
+        if (rp == c_p)
+            rp_locks &= ~ERTS_PROC_LOCK_MAIN;
+        erts_smp_proc_unlock(rp, rp_locks);
     }
 
     erts_smp_mtx_unlock(&nodes_monitors_mtx);
@@ -3067,76 +3069,76 @@ insert_nodes_monitor(Process *c_p, Uint32 opts)
 
     xnmp = c_p->nodes_monitors;
     if (xnmp) {
-	ASSERT(!xnmp->prev || xnmp->prev->proc != c_p);
-
-	while (1) {
-	    ASSERT(xnmp->proc == c_p);
-	    if (xnmp->opts == opts)
-		break;
-	    if (!xnmp->next || xnmp->next->proc != c_p)
-		break;
-	    xnmp = xnmp->next;
-	}
-	ASSERT(xnmp);
-	ASSERT(xnmp->proc == c_p);
-	ASSERT(xnmp->opts == opts
-	       || !xnmp->next
-	       || xnmp->next->proc != c_p);
-
-	if (xnmp->opts != opts)
-	    goto alloc_new;
-	else {
-	    res = am_true;
-	    no = xnmp->no++;
-	    if (!xnmp->no) {
-		/*
-		 * 'no' wrapped; transfer all prevous monitors to new
-		 * element (which will be the next element in the list)
-		 * and set this to one...
-		 */
-		xnmp->no = 1;
-		goto alloc_new;
-	    }
-	}
+        ASSERT(!xnmp->prev || xnmp->prev->proc != c_p);
+
+        while (1) {
+            ASSERT(xnmp->proc == c_p);
+            if (xnmp->opts == opts)
+                break;
+            if (!xnmp->next || xnmp->next->proc != c_p)
+                break;
+            xnmp = xnmp->next;
+        }
+        ASSERT(xnmp);
+        ASSERT(xnmp->proc == c_p);
+        ASSERT(xnmp->opts == opts
+                || !xnmp->next
+                || xnmp->next->proc != c_p);
+
+        if (xnmp->opts != opts)
+            goto alloc_new;
+        else {
+            res = am_true;
+            no = xnmp->no++;
+            if (!xnmp->no) {
+                /*
+                 * 'no' wrapped; transfer all prevous monitors to new
+                 * element (which will be the next element in the list)
+                 * and set this to one...
+                 */
+                xnmp->no = 1;
+                goto alloc_new;
+            }
+        }
     }
     else {
-    alloc_new:
-	nmp = erts_alloc(ERTS_ALC_T_NODES_MON, sizeof(ErtsNodesMonitor));
-	nmp->proc = c_p;
-	nmp->opts = opts;
-	nmp->no = no;
-
-	if (xnmp) {
-	    ASSERT(nodes_monitors);
-	    ASSERT(c_p->nodes_monitors);
-	    nmp->next = xnmp->next;
-	    nmp->prev = xnmp;
-	    xnmp->next = nmp;
-	    if (nmp->next) {
-		ASSERT(nodes_monitors_end != xnmp);
-		ASSERT(nmp->next->prev == xnmp);
-		nmp->next->prev = nmp;
-	    }
-	    else {
-		ASSERT(nodes_monitors_end == xnmp);
-		nodes_monitors_end = nmp;
-	    }
-	}
-	else {
-	    ASSERT(!c_p->nodes_monitors);
-	    c_p->nodes_monitors = nmp;
-	    nmp->next = NULL;
-	    nmp->prev = nodes_monitors_end;
-	    if (nodes_monitors_end) {
-		ASSERT(nodes_monitors);
-		nodes_monitors_end->next = nmp;
-	    }
-	    else {
-		ASSERT(!nodes_monitors);
-		nodes_monitors = nmp;
-	    }
-	    nodes_monitors_end = nmp;
-	}
+        alloc_new:
+        nmp = erts_alloc(ERTS_ALC_T_NODES_MON, sizeof(ErtsNodesMonitor));
+        nmp->proc = c_p;
+        nmp->opts = opts;
+        nmp->no = no;
+
+        if (xnmp) {
+            ASSERT(nodes_monitors);
+            ASSERT(c_p->nodes_monitors);
+            nmp->next = xnmp->next;
+            nmp->prev = xnmp;
+            xnmp->next = nmp;
+            if (nmp->next) {
+                ASSERT(nodes_monitors_end != xnmp);
+                ASSERT(nmp->next->prev == xnmp);
+                nmp->next->prev = nmp;
+            }
+            else {
+                ASSERT(nodes_monitors_end == xnmp);
+                nodes_monitors_end = nmp;
+            }
+        }
+        else {
+            ASSERT(!c_p->nodes_monitors);
+            c_p->nodes_monitors = nmp;
+            nmp->next = NULL;
+            nmp->prev = nodes_monitors_end;
+            if (nodes_monitors_end) {
+                ASSERT(nodes_monitors);
+                nodes_monitors_end->next = nmp;
+            }
+            else {
+                ASSERT(!nodes_monitors);
+                nodes_monitors = nmp;
+            }
+            nodes_monitors_end = nmp;
+        }
     }
     return res;
 }
@@ -3154,35 +3156,35 @@ remove_nodes_monitors(Process *c_p, Uint32 opts, int all)
     ASSERT(!nmp || !nmp->prev || nmp->prev->proc != c_p);
 
     while (nmp && nmp->proc == c_p) {
-	if (!all && nmp->opts != opts)
-	    nmp = nmp->next;
-	else { /* if (all || nmp->opts == opts) */
-	    ErtsNodesMonitor *free_nmp;
-	    res = am_true;
-	    if (nmp->prev) {
-		ASSERT(nodes_monitors != nmp);
-		nmp->prev->next = nmp->next;
-	    }
-	    else {
-		ASSERT(nodes_monitors == nmp);
-		nodes_monitors = nmp->next;
-	    }
-	    if (nmp->next) {
-		ASSERT(nodes_monitors_end != nmp);
-		nmp->next->prev = nmp->prev;
-	    }
-	    else {
-		ASSERT(nodes_monitors_end == nmp);
-		nodes_monitors_end = nmp->prev;
-	    }
-	    free_nmp = nmp;
-	    nmp = nmp->next;
-	    if (c_p->nodes_monitors == free_nmp)
-		c_p->nodes_monitors = nmp && nmp->proc == c_p ? nmp : NULL;
-	    erts_free(ERTS_ALC_T_NODES_MON, free_nmp);
-	}
-    }
-    
+        if (!all && nmp->opts != opts)
+            nmp = nmp->next;
+        else { /* if (all || nmp->opts == opts) */
+            ErtsNodesMonitor *free_nmp;
+            res = am_true;
+            if (nmp->prev) {
+                ASSERT(nodes_monitors != nmp);
+                nmp->prev->next = nmp->next;
+            }
+            else {
+                ASSERT(nodes_monitors == nmp);
+                nodes_monitors = nmp->next;
+            }
+            if (nmp->next) {
+                ASSERT(nodes_monitors_end != nmp);
+                nmp->next->prev = nmp->prev;
+            }
+            else {
+                ASSERT(nodes_monitors_end == nmp);
+                nodes_monitors_end = nmp->prev;
+            }
+            free_nmp = nmp;
+            nmp = nmp->next;
+            if (c_p->nodes_monitors == free_nmp)
+                c_p->nodes_monitors = nmp && nmp->proc == c_p ? nmp : NULL;
+            erts_free(ERTS_ALC_T_NODES_MON, free_nmp);
+        }
+    }
+
     ASSERT(!all || !c_p->nodes_monitors);
     return res;
 }
@@ -3192,18 +3194,18 @@ erts_delete_nodes_monitors(Process *c_p, ErtsProcLocks locks)
 {
 #if defined(ERTS_ENABLE_LOCK_CHECK) && defined(ERTS_SMP)
     if (c_p) {
-	ErtsProcLocks might_unlock = locks & ~ERTS_PROC_LOCK_MAIN;
-	if (might_unlock)
-	    erts_proc_lc_might_unlock(c_p, might_unlock);
+        ErtsProcLocks might_unlock = locks & ~ERTS_PROC_LOCK_MAIN;
+        if (might_unlock)
+            erts_proc_lc_might_unlock(c_p, might_unlock);
     }
 #endif
     if (erts_smp_mtx_trylock(&nodes_monitors_mtx) == EBUSY) {
-	ErtsProcLocks unlock_locks = locks & ~ERTS_PROC_LOCK_MAIN;
-	if (c_p && unlock_locks)
-	    erts_smp_proc_unlock(c_p, unlock_locks);
-	erts_smp_mtx_lock(&nodes_monitors_mtx);
-	if (c_p && unlock_locks)
-	    erts_smp_proc_lock(c_p, unlock_locks);
+        ErtsProcLocks unlock_locks = locks & ~ERTS_PROC_LOCK_MAIN;
+        if (c_p && unlock_locks)
+            erts_smp_proc_unlock(c_p, unlock_locks);
+        erts_smp_mtx_lock(&nodes_monitors_mtx);
+        if (c_p && unlock_locks)
+            erts_smp_proc_lock(c_p, unlock_locks);
     }
     remove_nodes_monitors(c_p, 0, 1);
     erts_smp_mtx_unlock(&nodes_monitors_mtx);
@@ -3220,65 +3222,65 @@ erts_monitor_nodes(Process *c_p, Eterm on, Eterm olist)
     ERTS_SMP_LC_ASSERT(erts_proc_lc_my_proc_locks(c_p) == ERTS_PROC_LOCK_MAIN);
 
     if (on != am_true && on != am_false)
-	return THE_NON_VALUE;
+        return THE_NON_VALUE;
 
     if (is_not_nil(opts_list)) {
-	int all = 0, visible = 0, hidden = 0;
-
-	while (is_list(opts_list)) {
-	    Eterm *cp = list_val(opts_list);
-	    Eterm opt = CAR(cp);
-	    opts_list = CDR(cp);
-	    if (opt == am_nodedown_reason)
-		opts |= ERTS_NODES_MON_OPT_DOWN_REASON;
-	    else if (is_tuple(opt)) {
-		Eterm* tp = tuple_val(opt);
-		if (arityval(tp[0]) != 2)
-		    return THE_NON_VALUE;
-		switch (tp[1]) {
-		case am_node_type:
-		    switch (tp[2]) {
-		    case am_visible:
-			if (hidden || all)
-			    return THE_NON_VALUE;
-			opts |= ERTS_NODES_MON_OPT_TYPE_VISIBLE;
-			visible = 1;
-			break;
-		    case am_hidden:
-			if (visible || all)
-			    return THE_NON_VALUE;
-			opts |= ERTS_NODES_MON_OPT_TYPE_HIDDEN;
-			hidden = 1;
-			break;
-		    case am_all:
-			if (visible || hidden)
-			    return THE_NON_VALUE;
-			opts |= ERTS_NODES_MON_OPT_TYPES;
-			all = 1;
-			break;
-		    default:
-			return THE_NON_VALUE;
-		    }
-		    break;
-		default:
-		    return THE_NON_VALUE;
-		}
-	    }
-	    else {
-		return THE_NON_VALUE;
-	    }
-	}
-
-	if (is_not_nil(opts_list))
-	    return THE_NON_VALUE;
+        int all = 0, visible = 0, hidden = 0;
+
+        while (is_list(opts_list)) {
+            Eterm *cp = list_val(opts_list);
+            Eterm opt = CAR(cp);
+            opts_list = CDR(cp);
+            if (opt == am_nodedown_reason)
+                opts |= ERTS_NODES_MON_OPT_DOWN_REASON;
+            else if (is_tuple(opt)) {
+                Eterm* tp = tuple_val(opt);
+                if (arityval(tp[0]) != 2)
+                    return THE_NON_VALUE;
+                switch (tp[1]) {
+                    case am_node_type:
+                        switch (tp[2]) {
+                            case am_visible:
+                                if (hidden || all)
+                                    return THE_NON_VALUE;
+                                opts |= ERTS_NODES_MON_OPT_TYPE_VISIBLE;
+                                visible = 1;
+                                break;
+                            case am_hidden:
+                                if (visible || all)
+                                    return THE_NON_VALUE;
+                                opts |= ERTS_NODES_MON_OPT_TYPE_HIDDEN;
+                                hidden = 1;
+                                break;
+                            case am_all:
+                                if (visible || hidden)
+                                    return THE_NON_VALUE;
+                                opts |= ERTS_NODES_MON_OPT_TYPES;
+                                all = 1;
+                                break;
+                            default:
+                                return THE_NON_VALUE;
+                        }
+                        break;
+                            default:
+                                return THE_NON_VALUE;
+                }
+            }
+            else {
+                return THE_NON_VALUE;
+            }
+        }
+
+        if (is_not_nil(opts_list))
+            return THE_NON_VALUE;
     }
 
     erts_smp_mtx_lock(&nodes_monitors_mtx);
 
     if (on == am_true)
-	res = insert_nodes_monitor(c_p, opts);
+        res = insert_nodes_monitor(c_p, opts);
     else
-	res = remove_nodes_monitors(c_p, opts, 0);
+        res = remove_nodes_monitors(c_p, opts, 0);
 
     erts_smp_mtx_unlock(&nodes_monitors_mtx);
 
@@ -3310,45 +3312,45 @@ erts_processes_monitoring_nodes(Process *c_p)
     szp = &sz;
     hpp = NULL;
 
- bld_result:
+    bld_result:
     res = NIL;
 
     for (nmp = nodes_monitors_end; nmp; nmp = nmp->prev) {
-	Uint16 i;
-	for (i = 0; i < nmp->no; i++) {
-	    Eterm olist = NIL;
-	    if (nmp->opts & ERTS_NODES_MON_OPT_TYPES) {
-		Eterm type;
-		switch (nmp->opts & ERTS_NODES_MON_OPT_TYPES) {
-		case ERTS_NODES_MON_OPT_TYPES:        type = am_all;     break;
-		case ERTS_NODES_MON_OPT_TYPE_VISIBLE: type = am_visible; break;
-		case ERTS_NODES_MON_OPT_TYPE_HIDDEN:  type = am_hidden;  break;
-		default: erl_exit(ERTS_ABORT_EXIT, "Bad node type found\n");
-		}
-		olist = erts_bld_cons(hpp, szp, 
-				      erts_bld_tuple(hpp, szp, 2,
-						     am_node_type,
-						     type),
-				      olist);
-	    }
-	    if (nmp->opts & ERTS_NODES_MON_OPT_DOWN_REASON)
-		olist = erts_bld_cons(hpp, szp, am_nodedown_reason, olist);
-	    res = erts_bld_cons(hpp, szp,
-				erts_bld_tuple(hpp, szp, 2,
-					       nmp->proc->id,
-					       olist),
-				res);
-	}
+        Uint16 i;
+        for (i = 0; i < nmp->no; i++) {
+            Eterm olist = NIL;
+            if (nmp->opts & ERTS_NODES_MON_OPT_TYPES) {
+                Eterm type;
+                switch (nmp->opts & ERTS_NODES_MON_OPT_TYPES) {
+                    case ERTS_NODES_MON_OPT_TYPES:        type = am_all;     break;
+                    case ERTS_NODES_MON_OPT_TYPE_VISIBLE: type = am_visible; break;
+                    case ERTS_NODES_MON_OPT_TYPE_HIDDEN:  type = am_hidden;  break;
+                    default: erl_exit(ERTS_ABORT_EXIT, "Bad node type found\n");
+                }
+                olist = erts_bld_cons(hpp, szp, 
+                        erts_bld_tuple(hpp, szp, 2,
+                                am_node_type,
+                                type),
+                                olist);
+            }
+            if (nmp->opts & ERTS_NODES_MON_OPT_DOWN_REASON)
+                olist = erts_bld_cons(hpp, szp, am_nodedown_reason, olist);
+            res = erts_bld_cons(hpp, szp,
+                    erts_bld_tuple(hpp, szp, 2,
+                            nmp->proc->id,
+                            olist),
+                            res);
+        }
     }
 
     if (!hpp) {
-	hp = HAlloc(c_p, sz);
+        hp = HAlloc(c_p, sz);
 #ifdef DEBUG
-	hend = hp + sz;
+        hend = hp + sz;
 #endif
-	hpp = &hp;
-	szp = NULL;
-	goto bld_result;
+        hpp = &hp;
+        szp = NULL;
+        goto bld_result;
     }
 
     ASSERT(hp == hend);
diff --git a/erts/emulator/beam/pexport.c b/erts/emulator/beam/pexport.c
new file mode 100644
index 0000000..4df5735
--- /dev/null
+++ b/erts/emulator/beam/pexport.c
@@ -0,0 +1,643 @@
+/*
+ * %CopyrightBegin%
+ *
+ * Copyright Ericsson AB 1996-2010. All Rights Reserved.
+ *
+ * The contents of this file are subject to the Erlang Public License,
+ * Version 1.1, (the "License"); you may not use this file except in
+ * compliance with the License. You should have received a copy of the
+ * Erlang Public License along with this software. If not, it can be
+ * retrieved online at http://www.erlang.org/.
+ *
+ * Software distributed under the License is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
+ * the License for the specific language governing rights and limitations
+ * under the License.
+ *
+ * %CopyrightEnd%
+ */
+
+/*
+ * Manage registered processes.
+ */
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#include "sys.h"
+#include "erl_vm.h"
+#include "global.h"
+#include "hash.h"
+#include "atom.h"
+#include "register.h"
+
+static Hash process_exp;
+
+#define PEXP_HASH_SIZE 10
+
+#define EXP_HASH(term) ((HashValue) atom_val(term))
+
+static erts_smp_rwmtx_t exptab_rwmtx;
+
+#define exp_try_read_lock()		erts_smp_rwmtx_tryrlock(&exptab_rwmtx)
+#define exp_try_write_lock()		erts_smp_rwmtx_tryrwlock(&exptab_rwmtx)
+#define exp_read_lock()			erts_smp_rwmtx_rlock(&exptab_rwmtx)
+#define exp_write_lock()		erts_smp_rwmtx_rwlock(&exptab_rwmtx)
+#define exp_read_unlock()		erts_smp_rwmtx_runlock(&exptab_rwmtx)
+#define exp_write_unlock()		erts_smp_rwmtx_rwunlock(&exptab_rwmtx)
+
+#ifdef ERTS_SMP
+static ERTS_INLINE void
+exp_safe_read_lock(Process *c_p, ErtsProcLocks *c_p_locks)
+{
+    if (*c_p_locks) {
+	ASSERT(c_p);
+	ASSERT(c_p_locks);
+	ASSERT(*c_p_locks);
+
+	if (exp_try_read_lock() != EBUSY) {
+#ifdef ERTS_ENABLE_LOCK_CHECK
+	    erts_proc_lc_might_unlock(c_p, *c_p_locks);
+#endif
+	    return;
+	}
+
+	/* Release process locks in order to avoid deadlock */
+	erts_smp_proc_unlock(c_p, *c_p_locks);
+	*c_p_locks = 0;
+    }
+
+    exp_read_lock();
+}
+
+static ERTS_INLINE void
+exp_safe_write_lock(Process *c_p, ErtsProcLocks *c_p_locks)
+{
+    if (*c_p_locks) {
+	ASSERT(c_p);
+	ASSERT(c_p_locks);
+	ASSERT(*c_p_locks);
+
+	if (exp_try_write_lock() != EBUSY) {
+#ifdef ERTS_ENABLE_LOCK_CHECK
+	    erts_proc_lc_might_unlock(c_p, *c_p_locks);
+#endif
+	    return;
+	}
+
+	/* Release process locks in order to avoid deadlock */
+	erts_smp_proc_unlock(c_p, *c_p_locks);
+	*c_p_locks = 0;
+    }
+
+    exp_write_lock();
+}
+
+static ERTS_INLINE int
+is_proc_alive(Process *p)
+{
+    int res;
+    erts_pix_lock_t *pixlck = ERTS_PID2PIXLOCK(p->id);
+    erts_pix_lock(pixlck);
+    res = !p->is_exiting;
+    erts_pix_unlock(pixlck);
+    return res;
+}
+
+#endif
+
+static HashValue exp_hash(ExpProc* obj)
+{
+    if (obj->p == NULL) EXP_HASH(obj->name);
+    else EXP_HASH(obj->p);
+}
+
+static int exp_cmp(ExpProc *tmpl, ExpProc *obj) {
+    return tmpl->name != obj->name;
+}
+
+static ExpProc* exp_alloc(ExpProc *tmpl)
+{
+    ExpProc* obj = (ExpProc*) erts_alloc(ERTS_ALC_T_REG_PROC, sizeof(ExpProc));
+    if (!obj) {
+	erl_exit(1, "Can't allocate %d bytes of memory\n", sizeof(ExpProc));
+    }
+    obj->name = tmpl->name;
+    obj->p = tmpl->p;
+    return obj;
+}
+
+static void exp_free(ExpProc *obj)
+{
+    erts_free(ERTS_ALC_T_REG_PROC, (void*) obj);
+}
+
+void init_register_table(void)
+{
+    HashFunctions f;
+    erts_smp_rwmtx_opt_t rwmtx_opt = ERTS_SMP_RWMTX_OPT_DEFAULT_INITER;
+    rwmtx_opt.type = ERTS_SMP_RWMTX_TYPE_FREQUENT_READ;
+    rwmtx_opt.lived = ERTS_SMP_RWMTX_LONG_LIVED;
+
+    erts_smp_rwmtx_init_opt(&exptab_rwmtx, &rwmtx_opt, "exp_tab");
+
+    f.hash = (H_FUN) exp_hash;
+    f.cmp  = (HCMP_FUN) exp_cmp;
+    f.alloc = (HALLOC_FUN) exp_alloc;
+    f.free = (HFREE_FUN) exp_free;
+
+    hash_init(ERTS_ALC_T_REG_TABLE, &process_exp, "process_exp",
+	      PREG_HASH_SIZE, f);
+}
+
+int erts_export_name(Process *c_p, Eterm name, Eterm id)
+{
+    int res = 0;
+    Process *proc = NULL;
+    ExpProc r, *rp;
+    ERTS_SMP_CHK_HAVE_ONLY_MAIN_PROC_LOCK(c_p);
+
+    if ((is_not_atom(name) || name == am_undefined) && is_not_internal_pid(id))
+	return res;
+
+    if (c_p->id == id) /* A very common case I think... */
+	proc = c_p;
+    else {
+	erts_smp_proc_unlock(c_p, ERTS_PROC_LOCK_MAIN);
+    }
+
+#ifdef ERTS_SMP
+    {
+	ErtsProcLocks proc_locks = proc ? ERTS_PROC_LOCK_MAIN : 0;
+	exp_safe_write_lock(proc, &proc_locks);
+
+	if (proc && !proc_locks)
+	    erts_smp_proc_lock(c_p, ERTS_PROC_LOCK_MAIN);
+    }
+#endif
+
+    if (is_internal_pid(id)) {
+	if (!proc)
+	    proc = erts_pid2proc(NULL, 0, id, ERTS_PROC_LOCK_MAIN);
+	r.p = proc;
+	if (!proc)
+	    goto done;
+	if (proc->exp)
+	    goto done;
+	r.pt = NULL;
+    }
+    else {
+	ASSERT(!INVALID_PORT(port, id));
+	ERTS_SMP_LC_ASSERT(erts_lc_is_port_locked(port));
+	r.pt = port;
+	if (r.pt->exp)
+	    goto done;
+	r.p = NULL;
+    }
+
+    r.name = name;
+    
+    rp = (ExpProc*) hash_put(&process_exp, (void*) &r);
+    if (proc && rp->p == proc) {
+	if (IS_TRACED_FL(proc, F_TRACE_PROCS)) {
+	    trace_proc(c_p, proc, am_register, name);
+	}
+	proc->exp = rp;
+    }
+    else if (port && rp->pt == port) {
+    	if (IS_TRACED_FL(port, F_TRACE_PORTS)) {
+		trace_port(port, am_register, name);
+	}
+	port->exp = rp;
+    }
+
+    if ((rp->p && rp->p->id == id) || (rp->pt && rp->pt->id == id)) {
+	res = 1;
+    }
+
+ done:
+    exp_write_unlock();
+    if (port)
+	erts_smp_port_unlock(port);
+    if (c_p != proc) {
+	if (proc)
+	    erts_smp_proc_unlock(proc, ERTS_PROC_LOCK_MAIN);
+	erts_smp_proc_lock(c_p, ERTS_PROC_LOCK_MAIN);
+    }
+    return res;
+}
+
+/*
+ *
+ * When smp support is enabled:
+ *   * Assumes that main lock is locked (and only main lock)
+ *     on c_p.
+ *
+ *   * am_undefined is returned if c_p became exiting.
+ */
+
+Eterm
+erts_whereis_name_to_id(Process *c_p, Eterm name)
+{
+    Eterm res = am_undefined;
+    HashValue hval;
+    int ix;
+    HashBucket* b;
+#ifdef ERTS_SMP
+    ErtsProcLocks c_p_locks = c_p ? ERTS_PROC_LOCK_MAIN : 0;
+
+    ERTS_SMP_CHK_HAVE_ONLY_MAIN_PROC_LOCK(c_p);
+    exp_safe_read_lock(c_p, &c_p_locks);
+    if (c_p && !c_p_locks)
+        erts_smp_proc_lock(c_p, ERTS_PROC_LOCK_MAIN);
+#endif
+
+    hval = REG_HASH(name);
+    ix = hval % process_exp.size;
+    b = process_exp.bucket[ix];
+
+    /*
+     * Note: We have inlined the code from hash.c for speed.
+     */
+	
+    while (b) {
+	ExpProc* rp = (ExpProc *) b;
+	if (rp->name == name) {
+	    /*
+	     * SMP NOTE: No need to lock registered entity since it cannot
+	     * be removed without acquiring write reg lock and id on entity
+	     * is read only.
+	     */
+	    if (rp->p)
+		res = rp->p->id;
+	    else if (rp->pt)
+		res = rp->pt->id;
+	    break;
+	}
+	b = b->next;
+    }
+
+    exp_read_unlock();
+
+    ASSERT(is_internal_pid(res) || is_internal_port(res) || res==am_undefined);
+
+    return res;
+}
+
+
+void
+erts_whereis_name(Process *c_p,
+		  ErtsProcLocks c_p_locks,
+		  Eterm name,
+		  Process** proc,
+		  ErtsProcLocks need_locks,
+		  int flags,
+		  Port** port)
+{
+    ExpProc* rp = NULL;
+    HashValue hval;
+    int ix;
+    HashBucket* b;
+#ifdef ERTS_SMP
+    ErtsProcLocks current_c_p_locks;
+    Port *pending_port = NULL;
+
+    if (!c_p)
+	c_p_locks = 0;
+    current_c_p_locks = c_p_locks;
+
+ restart:
+
+    exp_safe_read_lock(c_p, &current_c_p_locks);
+
+    /* Locked locks:
+     * - port lock on pending_port if pending_port != NULL
+     * - read reg lock
+     * - current_c_p_locks (either c_p_locks or 0) on c_p
+     */
+#endif
+
+    hval = REG_HASH(name);
+    ix = hval % process_exp.size;
+    b = process_exp.bucket[ix];
+
+    /*
+     * Note: We have inlined the code from hash.c for speed.
+     */
+
+    while (b) {
+	if (((ExpProc *) b)->name == name) {
+	    rp = (ExpProc *) b;
+	    break;
+	}
+	b = b->next;
+    }
+
+    if (proc) {
+	if (!rp)
+	    *proc = NULL;
+	else {
+#ifdef ERTS_SMP
+	    if (!rp->p)
+		*proc = NULL;
+	    else {
+		if (need_locks) {
+		    erts_proc_safelock(c_p,
+				       current_c_p_locks,
+				       c_p_locks,
+				       rp->p,
+				       0,
+				       need_locks);
+		    current_c_p_locks = c_p_locks;
+		}
+		if ((flags & ERTS_P2P_FLG_ALLOW_OTHER_X) || is_proc_alive(rp->p))
+		    *proc = rp->p;
+		else {
+		    if (need_locks)
+			erts_smp_proc_unlock(rp->p, need_locks);
+		    *proc = NULL;
+		}
+		if (*proc && (flags & ERTS_P2P_FLG_SMP_INC_REFC))
+		    erts_smp_proc_inc_refc(rp->p);
+	    }
+#else
+	    if (rp->p
+		&& ((flags & ERTS_P2P_FLG_ALLOW_OTHER_X)
+		    || rp->p->status != P_EXITING))
+		*proc = rp->p;
+	    else
+		*proc = NULL;
+#endif
+	}
+    }
+
+    if (port) {
+	if (!rp || !rp->pt)
+	    *port = NULL;
+	else {
+#ifdef ERTS_SMP
+	    if (pending_port == rp->pt)
+		pending_port = NULL;
+	    else {
+		if (pending_port) {
+		    /* Ahh! Registered port changed while reg lock
+		       was unlocked... */
+		    erts_smp_port_unlock(pending_port);
+		    pending_port = NULL;
+		}
+		    
+		if (erts_smp_port_trylock(rp->pt) == EBUSY) {
+		    Eterm id = rp->pt->id; /* id read only... */
+		    /* Unlock all locks, acquire port lock, and restart... */
+		    if (current_c_p_locks) {
+			erts_smp_proc_unlock(c_p, current_c_p_locks);
+			current_c_p_locks = 0;
+		    }
+		    exp_read_unlock();
+		    pending_port = erts_id2port(id, NULL, 0);
+		    goto restart;
+		}
+	    }
+#endif
+	    *port = rp->pt;
+	    ERTS_SMP_LC_ASSERT(erts_lc_is_port_locked(*port));
+	}
+    }
+
+#ifdef ERTS_SMP
+    if (c_p && !current_c_p_locks)
+	erts_smp_proc_lock(c_p, c_p_locks);
+    if (pending_port)
+	erts_smp_port_unlock(pending_port);
+#endif
+
+    exp_read_unlock();
+}
+
+Process *
+erts_whereis_process(Process *c_p,
+		     ErtsProcLocks c_p_locks,
+		     Eterm name,
+		     ErtsProcLocks need_locks,
+		     int flags)
+{
+    Process *proc;
+    erts_whereis_name(c_p, c_p_locks, name, &proc, need_locks, flags, NULL);
+    return proc;
+}
+
+
+/*
+ * Unregister a name
+ * Return 0 if not registered
+ * Otherwise returns 1
+ *
+ */
+int erts_unregister_name(Process *c_p,
+			 ErtsProcLocks c_p_locks,
+			 Port *c_prt,
+			 Eterm name)
+{
+    int res = 0;
+    ExpProc r, *rp;
+    Port *port = c_prt;
+#ifdef ERTS_SMP
+    ErtsProcLocks current_c_p_locks;
+
+    /*
+     * SMP note: If 'c_prt != NULL' and 'c_prt->reg->name == name',
+     *           we are *not* allowed to temporarily release the lock
+     *           on c_prt.
+     */
+
+    if (!c_p) {
+	c_p_locks = 0;
+    }
+    current_c_p_locks = c_p_locks;
+
+ restart:
+
+    exp_safe_write_lock(c_p, &current_c_p_locks);
+#endif
+
+    r.name = name;
+    if (is_non_value(name)) {
+	/* Unregister current process name */
+	ASSERT(c_p);
+#ifdef ERTS_SMP
+	if (current_c_p_locks != c_p_locks) {
+	    erts_smp_proc_lock(c_p, c_p_locks);
+	    current_c_p_locks = c_p_locks;
+	}
+#endif
+	if (c_p->exp) {
+	    r.name = c_p->exp->name;
+	} else {
+	    /* Name got unregistered while main lock was released */
+	    res = 0;
+	    goto done;
+	}
+    }
+
+    if ((rp = (ExpProc*) hash_get(&process_exp, (void*) &r)) != NULL) {
+	if (rp->pt) {
+	    if (port != rp->pt) {
+#ifdef ERTS_SMP
+		if (port) {
+		    ERTS_SMP_LC_ASSERT(port != c_prt);
+		    erts_smp_port_unlock(port);
+		    port = NULL;
+		}
+
+		if (erts_smp_port_trylock(rp->pt) == EBUSY) {
+		    Eterm id = rp->pt->id; /* id read only... */
+		    /* Unlock all locks, acquire port lock, and restart... */
+		    if (current_c_p_locks) {
+			erts_smp_proc_unlock(c_p, current_c_p_locks);
+			current_c_p_locks = 0;
+		    }
+		    exp_write_unlock();
+		    port = erts_id2port(id, NULL, 0);
+		    goto restart;
+		}
+#endif
+		port = rp->pt;
+	    }
+
+	    ASSERT(rp->pt == port);
+	    ERTS_SMP_LC_ASSERT(erts_lc_is_port_locked(port));
+
+	    rp->pt->exp = NULL;
+	    
+	    if (IS_TRACED_FL(port, F_TRACE_PORTS)) {
+		trace_port(port, am_unregister, r.name);
+	    }
+
+	} else if (rp->p) {
+
+#ifdef ERTS_SMP
+	    erts_proc_safelock(c_p,
+			       current_c_p_locks,
+			       c_p_locks,
+			       rp->p,
+			       (c_p == rp->p) ?  current_c_p_locks : 0,
+			       ERTS_PROC_LOCK_MAIN);
+	    current_c_p_locks = c_p_locks;
+#endif
+	    rp->p->exp = NULL;
+	    if (IS_TRACED_FL(rp->p, F_TRACE_PROCS)) {
+		trace_proc(c_p, rp->p, am_unregister, r.name);
+	    }
+#ifdef ERTS_SMP
+	    if (rp->p != c_p) {
+		erts_smp_proc_unlock(rp->p, ERTS_PROC_LOCK_MAIN);
+	    }
+#endif
+	}
+	hash_erase(&process_exp, (void*) &r);
+	res = 1;
+    }
+
+ done:
+
+    exp_write_unlock();
+    if (c_prt != port) {
+	if (port) {
+	    erts_smp_port_unlock(port);
+	}
+	if (c_prt) {
+	    erts_smp_port_lock(c_prt);
+	}
+    }
+#ifdef ERTS_SMP
+    if (c_p && !current_c_p_locks) {
+	erts_smp_proc_lock(c_p, c_p_locks);
+    }
+#endif
+    return res;
+}
+
+int process_exp_size(void)
+{
+    int size;
+    int lock = !ERTS_IS_CRASH_DUMPING;
+    if (lock)
+	exp_read_lock();
+    size = process_exp.size;
+    if (lock)
+	exp_read_unlock();
+    return size;
+}
+
+int process_exp_sz(void)
+{
+    int sz;
+    int lock = !ERTS_IS_CRASH_DUMPING;
+    if (lock)
+	exp_read_lock();
+    sz = hash_table_sz(&process_exp);
+    if (lock)
+	exp_read_unlock();
+    return sz;
+}
+
+/**********************************************************************/
+
+#include "bif.h"
+
+/* return a list of the registered processes */
+
+BIF_RETTYPE registered_0(BIF_ALIST_0)
+{
+    int i;
+    Eterm res;
+    Uint need;
+    Eterm* hp;
+    HashBucket **bucket;
+#ifdef ERTS_SMP
+    ErtsProcLocks proc_locks = ERTS_PROC_LOCK_MAIN;
+
+    ERTS_SMP_CHK_HAVE_ONLY_MAIN_PROC_LOCK(BIF_P);
+    exp_safe_read_lock(BIF_P, &proc_locks);
+    if (!proc_locks)
+	erts_smp_proc_lock(BIF_P, ERTS_PROC_LOCK_MAIN);
+#endif
+
+    bucket = process_exp.bucket;
+
+    /* work out how much heap we need & maybe garb, by scanning through
+       the registered process table */
+    need = 0;
+    for (i = 0; i < process_exp.size; i++) {
+	HashBucket *b = bucket[i];
+	while (b != NULL) {
+	    need += 2;
+	    b = b->next;
+	}
+    }
+
+    if (need == 0) {
+	exp_read_unlock();
+	BIF_RET(NIL);
+    }
+
+    hp = HAlloc(BIF_P, need);
+     
+     /* scan through again and make the list */ 
+    res = NIL;
+
+    for (i = 0; i < process_exp.size; i++) {
+	HashBucket *b = bucket[i];
+	while (b != NULL) {
+	    ExpProc *exp = (ExpProc *) b;
+
+	    res = CONS(hp, exp->name, res);
+	    hp += 2;
+	    b = b->next;
+	}
+    }
+
+    exp_read_unlock();
+
+    BIF_RET(res);
+}
diff --git a/erts/emulator/beam/pexport.h b/erts/emulator/beam/pexport.h
new file mode 100644
index 0000000..817c064
--- /dev/null
+++ b/erts/emulator/beam/pexport.h
@@ -0,0 +1,52 @@
+/*
+ * %CopyrightBegin%
+ * 
+ * Copyright Ericsson AB 1996-2009. All Rights Reserved.
+ * 
+ * The contents of this file are subject to the Erlang Public License,
+ * Version 1.1, (the "License"); you may not use this file except in
+ * compliance with the License. You should have received a copy of the
+ * Erlang Public License along with this software. If not, it can be
+ * retrieved online at http://www.erlang.org/.
+ * 
+ * Software distributed under the License is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
+ * the License for the specific language governing rights and limitations
+ * under the License.
+ * 
+ * %CopyrightEnd%
+ */
+
+/*
+** Exported processes
+*/
+
+#ifndef __PEXPORT_H__
+#define __PEXPORT_H__
+
+#ifndef __SYS_H__
+#include "sys.h"
+#endif
+
+#ifndef __HASH_H__
+#include "hash.h"
+#endif
+
+#ifndef __PROCESS_H__
+#include "erl_process.h"
+#endif
+
+typedef struct exp_proc
+{
+    HashBucket bucket;  /* MUST BE LOCATED AT TOP OF STRUCT!!! */
+    Process *p;         /* The process registerd (only one of this and  'pt' is non-NULL */
+    Eterm name;         /* Atom name */
+} ExpProc;
+
+int process_exp_size(void);
+void init_export_table(void);
+int erts_export_process(Process *, Eterm, Eterm);
+int erts_unexport_process(Process *, Eterm);
+int erts_is_exported(Process *, Eterm);
+
+#endif
-- 
1.7.7.5 (Apple Git-26)


From bc3d95fd077a1cb309428905497b7438c6f5c0c9 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Sun, 6 May 2012 18:39:55 +0200
Subject: [PATCH 06/12] First draft of export module done.

---
 erts/emulator/beam/bif.c         |   12 +-
 erts/emulator/beam/erl_process.h |    1 +
 erts/emulator/beam/pexport.c     |  457 ++++++++++++++------------------------
 erts/emulator/beam/pexport.h     |   11 +-
 4 files changed, 171 insertions(+), 310 deletions(-)

diff --git a/erts/emulator/beam/bif.c b/erts/emulator/beam/bif.c
index 9f1aec9..a862f12 100644
--- a/erts/emulator/beam/bif.c
+++ b/erts/emulator/beam/bif.c
@@ -36,6 +36,7 @@
 #include "beam_bp.h"
 #include "erl_db_util.h"
 #include "register.h"
+#include "pexport.h"
 #include "erl_thr_progress.h"
 
 static Export* flush_monitor_message_trap = NULL;
@@ -4592,14 +4593,3 @@ BIF_RETTYPE unexport_1(BIF_ALIST_1)
 }
 
 /**********************************************************************/
-
-/* list all exported processes */
-
-BIF_RETTYPE exported_0(BIF_ALIST_0)
-{
-    Eterm* hp = HAlloc(BIF_P, 2);
-    erts_printf("DEBUG: Listing exported processes\n");
-    BIF_RET(CONS(hp, NIL, NIL));
-}
-
-/**********************************************************************/
diff --git a/erts/emulator/beam/erl_process.h b/erts/emulator/beam/erl_process.h
index a51b380..7e4ae31 100644
--- a/erts/emulator/beam/erl_process.h
+++ b/erts/emulator/beam/erl_process.h
@@ -650,6 +650,7 @@ struct process {
     Process *prev;		/* Pointer to prev process in run queue */
 
     struct reg_proc *reg;	/* NULL iff not registered */
+    struct exp_proc *exp; /* NULL iff not exported */
     ErtsLink *nlinks;
     ErtsMonitor *monitors;      /* The process monitors, both ends */
 
diff --git a/erts/emulator/beam/pexport.c b/erts/emulator/beam/pexport.c
index 4df5735..1cf59aa 100644
--- a/erts/emulator/beam/pexport.c
+++ b/erts/emulator/beam/pexport.c
@@ -108,12 +108,12 @@ is_proc_alive(Process *p)
 
 static HashValue exp_hash(ExpProc* obj)
 {
-    if (obj->p == NULL) EXP_HASH(obj->name);
-    else EXP_HASH(obj->p);
+    if (obj->pid == am_undefined) return EXP_HASH(obj->name);
+    else return EXP_HASH(obj->pid);
 }
 
 static int exp_cmp(ExpProc *tmpl, ExpProc *obj) {
-    return tmpl->name != obj->name;
+    return tmpl->name != obj->name && tmpl->pid != obj->pid;
 }
 
 static ExpProc* exp_alloc(ExpProc *tmpl)
@@ -123,7 +123,7 @@ static ExpProc* exp_alloc(ExpProc *tmpl)
 	erl_exit(1, "Can't allocate %d bytes of memory\n", sizeof(ExpProc));
     }
     obj->name = tmpl->name;
-    obj->p = tmpl->p;
+    obj->pid = tmpl->pid;
     return obj;
 }
 
@@ -150,21 +150,17 @@ void init_register_table(void)
 	      PREG_HASH_SIZE, f);
 }
 
-int erts_export_name(Process *c_p, Eterm name, Eterm id)
+int erts_export_process_by_name(Process *c_p, Eterm name)
 {
     int res = 0;
     Process *proc = NULL;
     ExpProc r, *rp;
     ERTS_SMP_CHK_HAVE_ONLY_MAIN_PROC_LOCK(c_p);
 
-    if ((is_not_atom(name) || name == am_undefined) && is_not_internal_pid(id))
+    if ((is_not_atom(name) || name == am_undefined))
 	return res;
-
-    if (c_p->id == id) /* A very common case I think... */
-	proc = c_p;
-    else {
+    
 	erts_smp_proc_unlock(c_p, ERTS_PROC_LOCK_MAIN);
-    }
 
 #ifdef ERTS_SMP
     {
@@ -176,267 +172,94 @@ int erts_export_name(Process *c_p, Eterm name, Eterm id)
     }
 #endif
 
-    if (is_internal_pid(id)) {
-	if (!proc)
-	    proc = erts_pid2proc(NULL, 0, id, ERTS_PROC_LOCK_MAIN);
-	r.p = proc;
-	if (!proc)
-	    goto done;
-	if (proc->exp)
-	    goto done;
-	r.pt = NULL;
-    }
-    else {
-	ASSERT(!INVALID_PORT(port, id));
-	ERTS_SMP_LC_ASSERT(erts_lc_is_port_locked(port));
-	r.pt = port;
-	if (r.pt->exp)
-	    goto done;
-	r.p = NULL;
-    }
-
     r.name = name;
+    r.pid = am_undefined;
+    if (!proc)
+        goto done;
+    if (proc->exp)
+        goto done;
+    }
     
     rp = (ExpProc*) hash_put(&process_exp, (void*) &r);
     if (proc && rp->p == proc) {
-	if (IS_TRACED_FL(proc, F_TRACE_PROCS)) {
-	    trace_proc(c_p, proc, am_register, name);
-	}
-	proc->exp = rp;
-    }
-    else if (port && rp->pt == port) {
-    	if (IS_TRACED_FL(port, F_TRACE_PORTS)) {
-		trace_port(port, am_register, name);
-	}
-	port->exp = rp;
+    proc->exp = rp;
     }
 
-    if ((rp->p && rp->p->id == id) || (rp->pt && rp->pt->id == id)) {
-	res = 1;
+    if ((rp->p && rp->p->id == id)) {
+    res = 1;
     }
 
- done:
-    exp_write_unlock();
-    if (port)
-	erts_smp_port_unlock(port);
-    if (c_p != proc) {
-	if (proc)
-	    erts_smp_proc_unlock(proc, ERTS_PROC_LOCK_MAIN);
-	erts_smp_proc_lock(c_p, ERTS_PROC_LOCK_MAIN);
-    }
-    return res;
+    done:
+       exp_write_unlock();
+       if (c_p != proc) {
+       if (proc)
+           erts_smp_proc_unlock(proc, ERTS_PROC_LOCK_MAIN);
+       erts_smp_proc_lock(c_p, ERTS_PROC_LOCK_MAIN);
+       }
+       return res;
 }
 
-/*
- *
- * When smp support is enabled:
- *   * Assumes that main lock is locked (and only main lock)
- *     on c_p.
- *
- *   * am_undefined is returned if c_p became exiting.
- */
-
-Eterm
-erts_whereis_name_to_id(Process *c_p, Eterm name)
+int erts_export_process_by_pid(Process *c_p, Eterm id)
 {
-    Eterm res = am_undefined;
-    HashValue hval;
-    int ix;
-    HashBucket* b;
-#ifdef ERTS_SMP
-    ErtsProcLocks c_p_locks = c_p ? ERTS_PROC_LOCK_MAIN : 0;
-
+    int res = 0;
+    Process *proc = NULL;
+    ExpProc r, *rp;
     ERTS_SMP_CHK_HAVE_ONLY_MAIN_PROC_LOCK(c_p);
-    exp_safe_read_lock(c_p, &c_p_locks);
-    if (c_p && !c_p_locks)
-        erts_smp_proc_lock(c_p, ERTS_PROC_LOCK_MAIN);
-#endif
-
-    hval = REG_HASH(name);
-    ix = hval % process_exp.size;
-    b = process_exp.bucket[ix];
-
-    /*
-     * Note: We have inlined the code from hash.c for speed.
-     */
-	
-    while (b) {
-	ExpProc* rp = (ExpProc *) b;
-	if (rp->name == name) {
-	    /*
-	     * SMP NOTE: No need to lock registered entity since it cannot
-	     * be removed without acquiring write reg lock and id on entity
-	     * is read only.
-	     */
-	    if (rp->p)
-		res = rp->p->id;
-	    else if (rp->pt)
-		res = rp->pt->id;
-	    break;
-	}
-	b = b->next;
-    }
-
-    exp_read_unlock();
-
-    ASSERT(is_internal_pid(res) || is_internal_port(res) || res==am_undefined);
 
+    if (id == am_undefined)
     return res;
-}
 
+    if (c_p->id == id) /* A very common case I think... */
+    proc = c_p;
+    else {
+    erts_smp_proc_unlock(c_p, ERTS_PROC_LOCK_MAIN);
+    }
 
-void
-erts_whereis_name(Process *c_p,
-		  ErtsProcLocks c_p_locks,
-		  Eterm name,
-		  Process** proc,
-		  ErtsProcLocks need_locks,
-		  int flags,
-		  Port** port)
-{
-    ExpProc* rp = NULL;
-    HashValue hval;
-    int ix;
-    HashBucket* b;
 #ifdef ERTS_SMP
-    ErtsProcLocks current_c_p_locks;
-    Port *pending_port = NULL;
-
-    if (!c_p)
-	c_p_locks = 0;
-    current_c_p_locks = c_p_locks;
-
- restart:
-
-    exp_safe_read_lock(c_p, &current_c_p_locks);
+    {
+    ErtsProcLocks proc_locks = proc ? ERTS_PROC_LOCK_MAIN : 0;
+    exp_safe_write_lock(proc, &proc_locks);
 
-    /* Locked locks:
-     * - port lock on pending_port if pending_port != NULL
-     * - read reg lock
-     * - current_c_p_locks (either c_p_locks or 0) on c_p
-     */
+    if (proc && !proc_locks)
+        erts_smp_proc_lock(c_p, ERTS_PROC_LOCK_MAIN);
+    }
 #endif
 
-    hval = REG_HASH(name);
-    ix = hval % process_exp.size;
-    b = process_exp.bucket[ix];
-
-    /*
-     * Note: We have inlined the code from hash.c for speed.
-     */
-
-    while (b) {
-	if (((ExpProc *) b)->name == name) {
-	    rp = (ExpProc *) b;
-	    break;
-	}
-	b = b->next;
+    if (is_internal_pid(id)) {
+    if (!proc)
+        proc = erts_pid2proc(NULL, 0, id, ERTS_PROC_LOCK_MAIN);
+    r.pid = proc;
+    if (!proc)
+        goto done;
+    if (proc->exp)
+        goto done;
     }
 
-    if (proc) {
-	if (!rp)
-	    *proc = NULL;
-	else {
-#ifdef ERTS_SMP
-	    if (!rp->p)
-		*proc = NULL;
-	    else {
-		if (need_locks) {
-		    erts_proc_safelock(c_p,
-				       current_c_p_locks,
-				       c_p_locks,
-				       rp->p,
-				       0,
-				       need_locks);
-		    current_c_p_locks = c_p_locks;
-		}
-		if ((flags & ERTS_P2P_FLG_ALLOW_OTHER_X) || is_proc_alive(rp->p))
-		    *proc = rp->p;
-		else {
-		    if (need_locks)
-			erts_smp_proc_unlock(rp->p, need_locks);
-		    *proc = NULL;
-		}
-		if (*proc && (flags & ERTS_P2P_FLG_SMP_INC_REFC))
-		    erts_smp_proc_inc_refc(rp->p);
-	    }
-#else
-	    if (rp->p
-		&& ((flags & ERTS_P2P_FLG_ALLOW_OTHER_X)
-		    || rp->p->status != P_EXITING))
-		*proc = rp->p;
-	    else
-		*proc = NULL;
-#endif
-	}
+    r.pid = id;
+    
+    rp = (ExpProc*) hash_put(&process_exp, (void*) &r);
+    if (proc && rp->p == proc) {
+    proc->exp = rp;
     }
 
-    if (port) {
-	if (!rp || !rp->pt)
-	    *port = NULL;
-	else {
-#ifdef ERTS_SMP
-	    if (pending_port == rp->pt)
-		pending_port = NULL;
-	    else {
-		if (pending_port) {
-		    /* Ahh! Registered port changed while reg lock
-		       was unlocked... */
-		    erts_smp_port_unlock(pending_port);
-		    pending_port = NULL;
-		}
-		    
-		if (erts_smp_port_trylock(rp->pt) == EBUSY) {
-		    Eterm id = rp->pt->id; /* id read only... */
-		    /* Unlock all locks, acquire port lock, and restart... */
-		    if (current_c_p_locks) {
-			erts_smp_proc_unlock(c_p, current_c_p_locks);
-			current_c_p_locks = 0;
-		    }
-		    exp_read_unlock();
-		    pending_port = erts_id2port(id, NULL, 0);
-		    goto restart;
-		}
-	    }
-#endif
-	    *port = rp->pt;
-	    ERTS_SMP_LC_ASSERT(erts_lc_is_port_locked(*port));
-	}
+    if ((rp->p && rp->p->id == id)) {
+    res = 1;
     }
 
-#ifdef ERTS_SMP
-    if (c_p && !current_c_p_locks)
-	erts_smp_proc_lock(c_p, c_p_locks);
-    if (pending_port)
-	erts_smp_port_unlock(pending_port);
-#endif
-
-    exp_read_unlock();
-}
-
-Process *
-erts_whereis_process(Process *c_p,
-		     ErtsProcLocks c_p_locks,
-		     Eterm name,
-		     ErtsProcLocks need_locks,
-		     int flags)
-{
-    Process *proc;
-    erts_whereis_name(c_p, c_p_locks, name, &proc, need_locks, flags, NULL);
-    return proc;
+ done:
+    exp_write_unlock();
+    if (c_p != proc) {
+    if (proc)
+        erts_smp_proc_unlock(proc, ERTS_PROC_LOCK_MAIN);
+    erts_smp_proc_lock(c_p, ERTS_PROC_LOCK_MAIN);
+    }
+    return res;
 }
 
-
-/*
- * Unregister a name
- * Return 0 if not registered
- * Otherwise returns 1
- *
- */
-int erts_unregister_name(Process *c_p,
+int erts_unregister_process_by_pid(Process *c_p,
 			 ErtsProcLocks c_p_locks,
 			 Port *c_prt,
-			 Eterm name)
+			 Eterm id)
 {
     int res = 0;
     ExpProc r, *rp;
@@ -460,8 +283,8 @@ int erts_unregister_name(Process *c_p,
     exp_safe_write_lock(c_p, &current_c_p_locks);
 #endif
 
-    r.name = name;
-    if (is_non_value(name)) {
+    r.id = id;
+    if (is_non_value(id)) {
 	/* Unregister current process name */
 	ASSERT(c_p);
 #ifdef ERTS_SMP
@@ -471,7 +294,7 @@ int erts_unregister_name(Process *c_p,
 	}
 #endif
 	if (c_p->exp) {
-	    r.name = c_p->exp->name;
+	    r.id = c_p->exp->id;
 	} else {
 	    /* Name got unregistered while main lock was released */
 	    res = 0;
@@ -480,40 +303,7 @@ int erts_unregister_name(Process *c_p,
     }
 
     if ((rp = (ExpProc*) hash_get(&process_exp, (void*) &r)) != NULL) {
-	if (rp->pt) {
-	    if (port != rp->pt) {
-#ifdef ERTS_SMP
-		if (port) {
-		    ERTS_SMP_LC_ASSERT(port != c_prt);
-		    erts_smp_port_unlock(port);
-		    port = NULL;
-		}
-
-		if (erts_smp_port_trylock(rp->pt) == EBUSY) {
-		    Eterm id = rp->pt->id; /* id read only... */
-		    /* Unlock all locks, acquire port lock, and restart... */
-		    if (current_c_p_locks) {
-			erts_smp_proc_unlock(c_p, current_c_p_locks);
-			current_c_p_locks = 0;
-		    }
-		    exp_write_unlock();
-		    port = erts_id2port(id, NULL, 0);
-		    goto restart;
-		}
-#endif
-		port = rp->pt;
-	    }
-
-	    ASSERT(rp->pt == port);
-	    ERTS_SMP_LC_ASSERT(erts_lc_is_port_locked(port));
-
-	    rp->pt->exp = NULL;
-	    
-	    if (IS_TRACED_FL(port, F_TRACE_PORTS)) {
-		trace_port(port, am_unregister, r.name);
-	    }
-
-	} else if (rp->p) {
+    if (rp->p) {
 
 #ifdef ERTS_SMP
 	    erts_proc_safelock(c_p,
@@ -526,7 +316,7 @@ int erts_unregister_name(Process *c_p,
 #endif
 	    rp->p->exp = NULL;
 	    if (IS_TRACED_FL(rp->p, F_TRACE_PROCS)) {
-		trace_proc(c_p, rp->p, am_unregister, r.name);
+		trace_proc(c_p, rp->p, am_unregister, r.pid);
 	    }
 #ifdef ERTS_SMP
 	    if (rp->p != c_p) {
@@ -557,6 +347,97 @@ int erts_unregister_name(Process *c_p,
     return res;
 }
 
+int erts_unregister_process_by_name(Process *c_p,
+             ErtsProcLocks c_p_locks,
+             Port *c_prt,
+             Eterm name)
+{
+    int res = 0;
+    ExpProc r, *rp;
+    Port *port = c_prt;
+#ifdef ERTS_SMP
+    ErtsProcLocks current_c_p_locks;
+
+    /*
+     * SMP note: If 'c_prt != NULL' and 'c_prt->reg->name == name',
+     *           we are *not* allowed to temporarily release the lock
+     *           on c_prt.
+     */
+
+    if (!c_p) {
+    c_p_locks = 0;
+    }
+    current_c_p_locks = c_p_locks;
+
+ restart:
+
+    exp_safe_write_lock(c_p, &current_c_p_locks);
+#endif
+
+    r.name = name;
+    if (is_non_value(name)) {
+    /* Unregister current process name */
+    ASSERT(c_p);
+#ifdef ERTS_SMP
+    if (current_c_p_locks != c_p_locks) {
+        erts_smp_proc_lock(c_p, c_p_locks);
+        current_c_p_locks = c_p_locks;
+    }
+#endif
+    if (c_p->exp) {
+        r.name = c_p->exp->name;
+    } else {
+        /* Name got unregistered while main lock was released */
+        res = 0;
+        goto done;
+    }
+    }
+
+    if ((rp = (ExpProc*) hash_get(&process_exp, (void*) &r)) != NULL) {
+    if (rp->p) {
+
+#ifdef ERTS_SMP
+        erts_proc_safelock(c_p,
+                   current_c_p_locks,
+                   c_p_locks,
+                   rp->p,
+                   (c_p == rp->p) ?  current_c_p_locks : 0,
+                   ERTS_PROC_LOCK_MAIN);
+        current_c_p_locks = c_p_locks;
+#endif
+        rp->p->exp = NULL;
+        if (IS_TRACED_FL(rp->p, F_TRACE_PROCS)) {
+        trace_proc(c_p, rp->p, am_unregister, r.name);
+        }
+#ifdef ERTS_SMP
+        if (rp->p != c_p) {
+        erts_smp_proc_unlock(rp->p, ERTS_PROC_LOCK_MAIN);
+        }
+#endif
+    }
+    hash_erase(&process_exp, (void*) &r);
+    res = 1;
+    }
+
+ done:
+
+    exp_write_unlock();
+    if (c_prt != port) {
+    if (port) {
+        erts_smp_port_unlock(port);
+    }
+    if (c_prt) {
+        erts_smp_port_lock(c_prt);
+    }
+    }
+#ifdef ERTS_SMP
+    if (c_p && !current_c_p_locks) {
+    erts_smp_proc_lock(c_p, c_p_locks);
+    }
+#endif
+    return res;
+}
+
 int process_exp_size(void)
 {
     int size;
@@ -569,25 +450,11 @@ int process_exp_size(void)
     return size;
 }
 
-int process_exp_sz(void)
-{
-    int sz;
-    int lock = !ERTS_IS_CRASH_DUMPING;
-    if (lock)
-	exp_read_lock();
-    sz = hash_table_sz(&process_exp);
-    if (lock)
-	exp_read_unlock();
-    return sz;
-}
-
 /**********************************************************************/
 
 #include "bif.h"
 
-/* return a list of the registered processes */
-
-BIF_RETTYPE registered_0(BIF_ALIST_0)
+BIF_RETTYPE exported_0(BIF_ALIST_0)
 {
     int i;
     Eterm res;
diff --git a/erts/emulator/beam/pexport.h b/erts/emulator/beam/pexport.h
index 817c064..e90c9de 100644
--- a/erts/emulator/beam/pexport.h
+++ b/erts/emulator/beam/pexport.h
@@ -39,14 +39,17 @@
 typedef struct exp_proc
 {
     HashBucket bucket;  /* MUST BE LOCATED AT TOP OF STRUCT!!! */
-    Process *p;         /* The process registerd (only one of this and  'pt' is non-NULL */
-    Eterm name;         /* Atom name */
+    Eterm pid;
+    Eterm name;
+    Process* p;
 } ExpProc;
 
 int process_exp_size(void);
 void init_export_table(void);
-int erts_export_process(Process *, Eterm, Eterm);
-int erts_unexport_process(Process *, Eterm);
+int erts_export_process_by_name(Process *, Eterm);
+int erts_export_process_by_pid(Process *, Eterm);
+int erts_unexport_process_by_name(Process *, ErtsProcLocks, struct port *, Eterm);
+int erts_unexport_process_by_pid(Process *, ErtsProcLocks, struct port *, Eterm);
 int erts_is_exported(Process *, Eterm);
 
 #endif
-- 
1.7.7.5 (Apple Git-26)


From 2e53ad7eacd4a01af9585a2bb03f85e46eb4cbdf Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Sun, 6 May 2012 18:49:58 +0200
Subject: [PATCH 07/12] First draft of export module done/2.

---
 erts/emulator/beam/bif.c |   23 ++++++++++++++++++++++-
 1 files changed, 22 insertions(+), 1 deletions(-)

diff --git a/erts/emulator/beam/bif.c b/erts/emulator/beam/bif.c
index a862f12..62f664e 100644
--- a/erts/emulator/beam/bif.c
+++ b/erts/emulator/beam/bif.c
@@ -4577,8 +4577,18 @@ BIF_RETTYPE get_module_info_2(BIF_ALIST_2)
 
 BIF_RETTYPE export_1(BIF_ALIST_1)   /* (Atom|Pid)   */
 {
+    int res;
+    
     erts_printf("DEBUG: Exporting %T\n", BIF_ARG_1);
-    BIF_RET(am_true);
+    if (is_atom(BIF_ARG_1))
+        res = erts_export_process_by_name(BIF_P, BIF_ARG_1);
+    else
+        res = erts_export_process_by_pid(BIF_P, BIF_ARG_1);
+    if (res)
+        BIF_RET(am_true);
+    else {
+        BIF_ERROR(BIF_P, BADARG);
+    }
 }
 
 
@@ -4588,7 +4598,18 @@ BIF_RETTYPE export_1(BIF_ALIST_1)   /* (Atom|Pid)   */
 
 BIF_RETTYPE unexport_1(BIF_ALIST_1)
 {
+    int res;
+    
     erts_printf("DEBUG: Unexporting %T\n", BIF_ARG_1);
+    if (is_atom(BIF_ARG_1)) {
+        res = erts_unexport_process_by_name(BIF_P, ERTS_PROC_LOCK_MAIN, NULL, BIF_ARG_1);
+    }
+    else {
+        res = erts_unexport_process_by_pid(BIF_P, ERTS_PROC_LOCK_MAIN, NULL, BIF_ARG_1);
+    }
+    if (res == 0) {
+        BIF_ERROR(BIF_P, BADARG);
+    }
     BIF_RET(am_true);
 }
 
-- 
1.7.7.5 (Apple Git-26)


From 625332450fe3a8d67d655c78406824a1a70d0034 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Mon, 7 May 2012 17:59:52 +0200
Subject: [PATCH 08/12] Simplified version of export now working.

---
 erts/emulator/Makefile.in     |    3 +-
 erts/emulator/beam/bif.c      |    7 +-
 erts/emulator/beam/erl_init.c |    1 +
 erts/emulator/beam/pexport.c  |  297 +++++++----------------------------------
 erts/emulator/beam/pexport.h  |    3 +-
 5 files changed, 60 insertions(+), 251 deletions(-)

diff --git a/erts/emulator/Makefile.in b/erts/emulator/Makefile.in
index a5d8217..7afc45d 100644
--- a/erts/emulator/Makefile.in
+++ b/erts/emulator/Makefile.in
@@ -742,7 +742,8 @@ RUN_OBJS = \
 	$(OBJDIR)/packet_parser.o	$(OBJDIR)/safe_hash.o \
 	$(OBJDIR)/erl_zlib.o		$(OBJDIR)/erl_nif.o \
 	$(OBJDIR)/erl_bif_binary.o      $(OBJDIR)/erl_ao_firstfit_alloc.o \
-	$(OBJDIR)/erl_thr_queue.o	$(OBJDIR)/erl_sched_spec_pre_alloc.o
+	$(OBJDIR)/erl_thr_queue.o	$(OBJDIR)/erl_sched_spec_pre_alloc.o \
+	$(OBJDIR)/pexport.o
 
 ifeq ($(TARGET),win32)
 DRV_OBJS = \
diff --git a/erts/emulator/beam/bif.c b/erts/emulator/beam/bif.c
index 62f664e..3d0c6d5 100644
--- a/erts/emulator/beam/bif.c
+++ b/erts/emulator/beam/bif.c
@@ -4579,11 +4579,16 @@ BIF_RETTYPE export_1(BIF_ALIST_1)   /* (Atom|Pid)   */
 {
     int res;
     
-    erts_printf("DEBUG: Exporting %T\n", BIF_ARG_1);
     if (is_atom(BIF_ARG_1))
+    {
+        erts_printf("DEBUG: Exporting atom %T\n", BIF_ARG_1);
         res = erts_export_process_by_name(BIF_P, BIF_ARG_1);
+    }
     else
+    {
+        erts_printf("DEBUG: Exporting pid %T\n", BIF_ARG_1);
         res = erts_export_process_by_pid(BIF_P, BIF_ARG_1);
+    }
     if (res)
         BIF_RET(am_true);
     else {
diff --git a/erts/emulator/beam/erl_init.c b/erts/emulator/beam/erl_init.c
index 717315d..f70b87e 100644
--- a/erts/emulator/beam/erl_init.c
+++ b/erts/emulator/beam/erl_init.c
@@ -269,6 +269,7 @@ erl_init(int ncpu)
     init_export_table();
     init_module_table();
     init_register_table();
+    init_pexport_table();
     init_message();
     erts_bif_info_init();
     erts_ddll_init();
diff --git a/erts/emulator/beam/pexport.c b/erts/emulator/beam/pexport.c
index 1cf59aa..3085652 100644
--- a/erts/emulator/beam/pexport.c
+++ b/erts/emulator/beam/pexport.c
@@ -29,6 +29,7 @@
 #include "global.h"
 #include "hash.h"
 #include "atom.h"
+#include "pexport.h"
 #include "register.h"
 
 static Hash process_exp;
@@ -108,8 +109,8 @@ is_proc_alive(Process *p)
 
 static HashValue exp_hash(ExpProc* obj)
 {
-    if (obj->pid == am_undefined) return EXP_HASH(obj->name);
-    else return EXP_HASH(obj->pid);
+    if (obj->name == am_undefined) return EXP_HASH(obj->pid);
+    else return EXP_HASH(obj->name);
 }
 
 static int exp_cmp(ExpProc *tmpl, ExpProc *obj) {
@@ -132,7 +133,7 @@ static void exp_free(ExpProc *obj)
     erts_free(ERTS_ALC_T_REG_PROC, (void*) obj);
 }
 
-void init_register_table(void)
+void init_pexport_table(void)
 {
     HashFunctions f;
     erts_smp_rwmtx_opt_t rwmtx_opt = ERTS_SMP_RWMTX_OPT_DEFAULT_INITER;
@@ -147,294 +148,94 @@ void init_register_table(void)
     f.free = (HFREE_FUN) exp_free;
 
     hash_init(ERTS_ALC_T_REG_TABLE, &process_exp, "process_exp",
-	      PREG_HASH_SIZE, f);
+	      PEXP_HASH_SIZE, f);
 }
 
 int erts_export_process_by_name(Process *c_p, Eterm name)
 {
-    int res = 0;
-    Process *proc = NULL;
-    ExpProc r, *rp;
+    ExpProc r;
     ERTS_SMP_CHK_HAVE_ONLY_MAIN_PROC_LOCK(c_p);
 
-    if ((is_not_atom(name) || name == am_undefined))
-	return res;
-    
-	erts_smp_proc_unlock(c_p, ERTS_PROC_LOCK_MAIN);
-
-#ifdef ERTS_SMP
-    {
-	ErtsProcLocks proc_locks = proc ? ERTS_PROC_LOCK_MAIN : 0;
-	exp_safe_write_lock(proc, &proc_locks);
-
-	if (proc && !proc_locks)
-	    erts_smp_proc_lock(c_p, ERTS_PROC_LOCK_MAIN);
+    if ((is_not_atom(name) || name == am_undefined)) {
+        return 0;
     }
-#endif
-
+    
     r.name = name;
     r.pid = am_undefined;
-    if (!proc)
-        goto done;
-    if (proc->exp)
-        goto done;
-    }
     
-    rp = (ExpProc*) hash_put(&process_exp, (void*) &r);
-    if (proc && rp->p == proc) {
-    proc->exp = rp;
-    }
-
-    if ((rp->p && rp->p->id == id)) {
-    res = 1;
-    }
-
-    done:
-       exp_write_unlock();
-       if (c_p != proc) {
-       if (proc)
-           erts_smp_proc_unlock(proc, ERTS_PROC_LOCK_MAIN);
-       erts_smp_proc_lock(c_p, ERTS_PROC_LOCK_MAIN);
-       }
-       return res;
+    exp_write_lock();
+    hash_put(&process_exp, (void*) &r);
+    exp_write_unlock();
+    
+    return 1;
 }
 
 int erts_export_process_by_pid(Process *c_p, Eterm id)
 {
-    int res = 0;
-    Process *proc = NULL;
-    ExpProc r, *rp;
+    ExpProc r;
     ERTS_SMP_CHK_HAVE_ONLY_MAIN_PROC_LOCK(c_p);
 
-    if (id == am_undefined)
-    return res;
-
-    if (c_p->id == id) /* A very common case I think... */
-    proc = c_p;
-    else {
-    erts_smp_proc_unlock(c_p, ERTS_PROC_LOCK_MAIN);
-    }
-
-#ifdef ERTS_SMP
-    {
-    ErtsProcLocks proc_locks = proc ? ERTS_PROC_LOCK_MAIN : 0;
-    exp_safe_write_lock(proc, &proc_locks);
-
-    if (proc && !proc_locks)
-        erts_smp_proc_lock(c_p, ERTS_PROC_LOCK_MAIN);
-    }
-#endif
-
-    if (is_internal_pid(id)) {
-    if (!proc)
-        proc = erts_pid2proc(NULL, 0, id, ERTS_PROC_LOCK_MAIN);
-    r.pid = proc;
-    if (!proc)
-        goto done;
-    if (proc->exp)
-        goto done;
+    if (id == am_undefined) {
+        return 0;
     }
-
-    r.pid = id;
     
-    rp = (ExpProc*) hash_put(&process_exp, (void*) &r);
-    if (proc && rp->p == proc) {
-    proc->exp = rp;
-    }
-
-    if ((rp->p && rp->p->id == id)) {
-    res = 1;
-    }
+    r.pid = id;
+    r.name = am_undefined;
 
- done:
+    exp_write_lock();
+    hash_put(&process_exp, (void*) &r);
     exp_write_unlock();
-    if (c_p != proc) {
-    if (proc)
-        erts_smp_proc_unlock(proc, ERTS_PROC_LOCK_MAIN);
-    erts_smp_proc_lock(c_p, ERTS_PROC_LOCK_MAIN);
-    }
-    return res;
+    
+    return 1;
 }
 
-int erts_unregister_process_by_pid(Process *c_p,
+int erts_unexport_process_by_pid(Process *c_p,
 			 ErtsProcLocks c_p_locks,
 			 Port *c_prt,
 			 Eterm id)
 {
     int res = 0;
-    ExpProc r, *rp;
-    Port *port = c_prt;
-#ifdef ERTS_SMP
-    ErtsProcLocks current_c_p_locks;
+    ExpProc r;
 
-    /*
-     * SMP note: If 'c_prt != NULL' and 'c_prt->reg->name == name',
-     *           we are *not* allowed to temporarily release the lock
-     *           on c_prt.
-     */
-
-    if (!c_p) {
-	c_p_locks = 0;
-    }
-    current_c_p_locks = c_p_locks;
-
- restart:
-
-    exp_safe_write_lock(c_p, &current_c_p_locks);
-#endif
+    r.pid = id;
+    r.name = am_undefined;
 
-    r.id = id;
-    if (is_non_value(id)) {
-	/* Unregister current process name */
-	ASSERT(c_p);
-#ifdef ERTS_SMP
-	if (current_c_p_locks != c_p_locks) {
-	    erts_smp_proc_lock(c_p, c_p_locks);
-	    current_c_p_locks = c_p_locks;
-	}
-#endif
-	if (c_p->exp) {
-	    r.id = c_p->exp->id;
-	} else {
-	    /* Name got unregistered while main lock was released */
-	    res = 0;
-	    goto done;
-	}
+    exp_write_lock();
+    if (hash_get(&process_exp, (void*) &r) != NULL) {
+        
+        hash_erase(&process_exp, (void*) &r);
+        res = 1;
     }
-
-    if ((rp = (ExpProc*) hash_get(&process_exp, (void*) &r)) != NULL) {
-    if (rp->p) {
-
-#ifdef ERTS_SMP
-	    erts_proc_safelock(c_p,
-			       current_c_p_locks,
-			       c_p_locks,
-			       rp->p,
-			       (c_p == rp->p) ?  current_c_p_locks : 0,
-			       ERTS_PROC_LOCK_MAIN);
-	    current_c_p_locks = c_p_locks;
-#endif
-	    rp->p->exp = NULL;
-	    if (IS_TRACED_FL(rp->p, F_TRACE_PROCS)) {
-		trace_proc(c_p, rp->p, am_unregister, r.pid);
-	    }
-#ifdef ERTS_SMP
-	    if (rp->p != c_p) {
-		erts_smp_proc_unlock(rp->p, ERTS_PROC_LOCK_MAIN);
-	    }
-#endif
-	}
-	hash_erase(&process_exp, (void*) &r);
-	res = 1;
+    else {
+        res = 0;
     }
-
- done:
-
     exp_write_unlock();
-    if (c_prt != port) {
-	if (port) {
-	    erts_smp_port_unlock(port);
-	}
-	if (c_prt) {
-	    erts_smp_port_lock(c_prt);
-	}
-    }
-#ifdef ERTS_SMP
-    if (c_p && !current_c_p_locks) {
-	erts_smp_proc_lock(c_p, c_p_locks);
-    }
-#endif
+
     return res;
 }
 
-int erts_unregister_process_by_name(Process *c_p,
+int erts_unexport_process_by_name(Process *c_p,
              ErtsProcLocks c_p_locks,
              Port *c_prt,
              Eterm name)
 {
     int res = 0;
-    ExpProc r, *rp;
-    Port *port = c_prt;
-#ifdef ERTS_SMP
-    ErtsProcLocks current_c_p_locks;
-
-    /*
-     * SMP note: If 'c_prt != NULL' and 'c_prt->reg->name == name',
-     *           we are *not* allowed to temporarily release the lock
-     *           on c_prt.
-     */
-
-    if (!c_p) {
-    c_p_locks = 0;
-    }
-    current_c_p_locks = c_p_locks;
-
- restart:
-
-    exp_safe_write_lock(c_p, &current_c_p_locks);
-#endif
+    ExpProc r;
 
+    r.pid = am_undefined;
     r.name = name;
-    if (is_non_value(name)) {
-    /* Unregister current process name */
-    ASSERT(c_p);
-#ifdef ERTS_SMP
-    if (current_c_p_locks != c_p_locks) {
-        erts_smp_proc_lock(c_p, c_p_locks);
-        current_c_p_locks = c_p_locks;
-    }
-#endif
-    if (c_p->exp) {
-        r.name = c_p->exp->name;
-    } else {
-        /* Name got unregistered while main lock was released */
-        res = 0;
-        goto done;
-    }
-    }
 
-    if ((rp = (ExpProc*) hash_get(&process_exp, (void*) &r)) != NULL) {
-    if (rp->p) {
-
-#ifdef ERTS_SMP
-        erts_proc_safelock(c_p,
-                   current_c_p_locks,
-                   c_p_locks,
-                   rp->p,
-                   (c_p == rp->p) ?  current_c_p_locks : 0,
-                   ERTS_PROC_LOCK_MAIN);
-        current_c_p_locks = c_p_locks;
-#endif
-        rp->p->exp = NULL;
-        if (IS_TRACED_FL(rp->p, F_TRACE_PROCS)) {
-        trace_proc(c_p, rp->p, am_unregister, r.name);
-        }
-#ifdef ERTS_SMP
-        if (rp->p != c_p) {
-        erts_smp_proc_unlock(rp->p, ERTS_PROC_LOCK_MAIN);
-        }
-#endif
+    exp_write_lock();
+    if (hash_get(&process_exp, (void*) &r) != NULL) {
+        
+        hash_erase(&process_exp, (void*) &r);
+        res = 1;
     }
-    hash_erase(&process_exp, (void*) &r);
-    res = 1;
+    else {
+        res = 0;
     }
-
- done:
-
     exp_write_unlock();
-    if (c_prt != port) {
-    if (port) {
-        erts_smp_port_unlock(port);
-    }
-    if (c_prt) {
-        erts_smp_port_lock(c_prt);
-    }
-    }
-#ifdef ERTS_SMP
-    if (c_p && !current_c_p_locks) {
-    erts_smp_proc_lock(c_p, c_p_locks);
-    }
-#endif
+
     return res;
 }
 
@@ -497,8 +298,10 @@ BIF_RETTYPE exported_0(BIF_ALIST_0)
 	HashBucket *b = bucket[i];
 	while (b != NULL) {
 	    ExpProc *exp = (ExpProc *) b;
-
-	    res = CONS(hp, exp->name, res);
+	    if (exp->name == am_undefined)
+	        res = CONS(hp, exp->pid, res);
+	    else
+	        res = CONS(hp, exp->name, res);
 	    hp += 2;
 	    b = b->next;
 	}
diff --git a/erts/emulator/beam/pexport.h b/erts/emulator/beam/pexport.h
index e90c9de..087595c 100644
--- a/erts/emulator/beam/pexport.h
+++ b/erts/emulator/beam/pexport.h
@@ -41,11 +41,10 @@ typedef struct exp_proc
     HashBucket bucket;  /* MUST BE LOCATED AT TOP OF STRUCT!!! */
     Eterm pid;
     Eterm name;
-    Process* p;
 } ExpProc;
 
 int process_exp_size(void);
-void init_export_table(void);
+void init_pexport_table(void);
 int erts_export_process_by_name(Process *, Eterm);
 int erts_export_process_by_pid(Process *, Eterm);
 int erts_unexport_process_by_name(Process *, ErtsProcLocks, struct port *, Eterm);
-- 
1.7.7.5 (Apple Git-26)


From 220f287bb35bf98905bc285fb3905ed264e466ec Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Mon, 7 May 2012 18:30:10 +0200
Subject: [PATCH 09/12] Erlang export functions integrated in kernel global
 module.

---
 erts/emulator/beam/dist.c    |  115 +++++++++++++++++++++++-------------------
 erts/emulator/beam/pexport.c |   42 +++++++++++++++-
 erts/emulator/beam/pexport.h |    3 +-
 lib/kernel/src/global.erl    |   16 ++++--
 4 files changed, 117 insertions(+), 59 deletions(-)

diff --git a/erts/emulator/beam/dist.c b/erts/emulator/beam/dist.c
index 15754a7..d0ecb88 100644
--- a/erts/emulator/beam/dist.c
+++ b/erts/emulator/beam/dist.c
@@ -42,6 +42,7 @@
 #include "external.h"
 #include "erl_binary.h"
 #include "erl_thr_progress.h"
+#include "pexport.h"
 
 /* Turn this on to get printouts of all distribution messages
  * which go on the line
@@ -1213,34 +1214,39 @@ int erts_net_message(Port *prt,
             if (is_not_pid(from) || is_not_atom(to)){
                 goto invalid_message;
             }
-            erts_printf("DEBUG: Message received from %T, to %T\n", from, to);
-            rp = erts_whereis_process(NULL, 0, to, 0, ERTS_P2P_FLG_SMP_INC_REFC);
-            if (rp) {
-                Uint xsize = (type == DOP_REG_SEND
-                        ? 0
-                                : ERTS_HEAP_FRAG_SIZE(token_size));
-                ErtsProcLocks locks = 0;
-                ErtsDistExternal *ede_copy;
-
-                ede_copy = erts_make_dist_ext_copy(&ede, xsize);
-                if (type == DOP_REG_SEND) {
-                    token = NIL;
-                } else {
-                    ErlHeapFragment *heap_frag;
-                    ErlOffHeap *ohp;
-                    ASSERT(xsize);
-                    heap_frag = erts_dist_ext_trailer(ede_copy);
-                    ERTS_INIT_HEAP_FRAG(heap_frag, token_size);
-                    hp = heap_frag->mem;
-                    ohp = &heap_frag->off_heap;
-                    token = tuple[5];
-                    token = copy_struct(token, token_size, &hp, ohp);
+            if (erts_is_exported_by_name(NULL, to)) {
+                erts_printf("DEBUG: Message received from %T, to exported process %T\n", from, to);
+                rp = erts_whereis_process(NULL, 0, to, 0, ERTS_P2P_FLG_SMP_INC_REFC);
+                if (rp) {
+                    Uint xsize = (type == DOP_REG_SEND
+                            ? 0
+                                    : ERTS_HEAP_FRAG_SIZE(token_size));
+                    ErtsProcLocks locks = 0;
+                    ErtsDistExternal *ede_copy;
+    
+                    ede_copy = erts_make_dist_ext_copy(&ede, xsize);
+                    if (type == DOP_REG_SEND) {
+                        token = NIL;
+                    } else {
+                        ErlHeapFragment *heap_frag;
+                        ErlOffHeap *ohp;
+                        ASSERT(xsize);
+                        heap_frag = erts_dist_ext_trailer(ede_copy);
+                        ERTS_INIT_HEAP_FRAG(heap_frag, token_size);
+                        hp = heap_frag->mem;
+                        ohp = &heap_frag->off_heap;
+                        token = tuple[5];
+                        token = copy_struct(token, token_size, &hp, ohp);
+                    }
+    
+                    erts_queue_dist_message(rp, &locks, ede_copy, token);
+                    if (locks)
+                        erts_smp_proc_unlock(rp, locks);
+                    erts_smp_proc_dec_refc(rp);
                 }
-
-                erts_queue_dist_message(rp, &locks, ede_copy, token);
-                if (locks)
-                    erts_smp_proc_unlock(rp, locks);
-                erts_smp_proc_dec_refc(rp);
+            }
+            else {
+                erts_printf("DEBUG: Message received from %T, to unexported process %T\n", from, to);
             }
             break;
 
@@ -1266,32 +1272,37 @@ int erts_net_message(Port *prt,
             if (is_not_pid(to)) {
                 goto invalid_message;
             }
-            erts_printf("DEBUG: Message received for %T\n", to);
-            rp = erts_pid2proc_opt(NULL, 0, to, 0, ERTS_P2P_FLG_SMP_INC_REFC);
-            if (rp) {
-                Uint xsize = type == DOP_SEND ? 0 : ERTS_HEAP_FRAG_SIZE(token_size);
-                ErtsProcLocks locks = 0;
-                ErtsDistExternal *ede_copy;
-
-                ede_copy = erts_make_dist_ext_copy(&ede, xsize);
-                if (type == DOP_SEND) {
-                    token = NIL;
-                } else {
-                    ErlHeapFragment *heap_frag;
-                    ErlOffHeap *ohp;
-                    ASSERT(xsize);
-                    heap_frag = erts_dist_ext_trailer(ede_copy);
-                    ERTS_INIT_HEAP_FRAG(heap_frag, token_size);
-                    hp = heap_frag->mem;
-                    ohp = &heap_frag->off_heap;
-                    token = tuple[4];
-                    token = copy_struct(token, token_size, &hp, ohp);
+            if (erts_is_exported_by_pid(NULL, to)) {
+                erts_printf("DEBUG: Message received for exported process %T\n", to);
+                rp = erts_pid2proc_opt(NULL, 0, to, 0, ERTS_P2P_FLG_SMP_INC_REFC);
+                if (rp) {
+                    Uint xsize = type == DOP_SEND ? 0 : ERTS_HEAP_FRAG_SIZE(token_size);
+                    ErtsProcLocks locks = 0;
+                    ErtsDistExternal *ede_copy;
+    
+                    ede_copy = erts_make_dist_ext_copy(&ede, xsize);
+                    if (type == DOP_SEND) {
+                        token = NIL;
+                    } else {
+                        ErlHeapFragment *heap_frag;
+                        ErlOffHeap *ohp;
+                        ASSERT(xsize);
+                        heap_frag = erts_dist_ext_trailer(ede_copy);
+                        ERTS_INIT_HEAP_FRAG(heap_frag, token_size);
+                        hp = heap_frag->mem;
+                        ohp = &heap_frag->off_heap;
+                        token = tuple[4];
+                        token = copy_struct(token, token_size, &hp, ohp);
+                    }
+    
+                    erts_queue_dist_message(rp, &locks, ede_copy, token);
+                    if (locks)
+                        erts_smp_proc_unlock(rp, locks);
+                    erts_smp_proc_dec_refc(rp);
                 }
-
-                erts_queue_dist_message(rp, &locks, ede_copy, token);
-                if (locks)
-                    erts_smp_proc_unlock(rp, locks);
-                erts_smp_proc_dec_refc(rp);
+            }
+            else {
+                erts_printf("DEBUG: Message received for unexported process %T\n", to);
             }
             break;
 
diff --git a/erts/emulator/beam/pexport.c b/erts/emulator/beam/pexport.c
index 3085652..134d1f4 100644
--- a/erts/emulator/beam/pexport.c
+++ b/erts/emulator/beam/pexport.c
@@ -202,7 +202,6 @@ int erts_unexport_process_by_pid(Process *c_p,
 
     exp_write_lock();
     if (hash_get(&process_exp, (void*) &r) != NULL) {
-        
         hash_erase(&process_exp, (void*) &r);
         res = 1;
     }
@@ -227,7 +226,6 @@ int erts_unexport_process_by_name(Process *c_p,
 
     exp_write_lock();
     if (hash_get(&process_exp, (void*) &r) != NULL) {
-        
         hash_erase(&process_exp, (void*) &r);
         res = 1;
     }
@@ -251,6 +249,46 @@ int process_exp_size(void)
     return size;
 }
 
+int erts_is_exported_by_name(Process *c_p, Eterm name)
+{
+    int res = 0;
+    ExpProc r;
+
+    r.pid = am_undefined;
+    r.name = name;
+
+    exp_read_lock();
+    if (hash_get(&process_exp, (void*) &r) != NULL) {
+        res = 1;
+    }
+    else {
+        res = 0;
+    }
+    exp_read_unlock();
+
+    return res;
+}
+
+int erts_is_exported_by_pid(Process *c_p, Eterm id)
+{
+    int res = 0;
+    ExpProc r;
+
+    r.pid = id;
+    r.name = am_undefined;
+
+    exp_read_lock();
+    if (hash_get(&process_exp, (void*) &r) != NULL) {
+        res = 1;
+    }
+    else {
+        res = 0;
+    }
+    exp_read_unlock();
+
+    return res;
+}
+
 /**********************************************************************/
 
 #include "bif.h"
diff --git a/erts/emulator/beam/pexport.h b/erts/emulator/beam/pexport.h
index 087595c..e372d69 100644
--- a/erts/emulator/beam/pexport.h
+++ b/erts/emulator/beam/pexport.h
@@ -49,6 +49,7 @@ int erts_export_process_by_name(Process *, Eterm);
 int erts_export_process_by_pid(Process *, Eterm);
 int erts_unexport_process_by_name(Process *, ErtsProcLocks, struct port *, Eterm);
 int erts_unexport_process_by_pid(Process *, ErtsProcLocks, struct port *, Eterm);
-int erts_is_exported(Process *, Eterm);
+int erts_is_exported_by_name(Process *, Eterm);
+int erts_is_exported_by_pid(Process *, Eterm);
 
 #endif
diff --git a/lib/kernel/src/global.erl b/lib/kernel/src/global.erl
index fa97614..ae71802 100644
--- a/lib/kernel/src/global.erl
+++ b/lib/kernel/src/global.erl
@@ -158,10 +158,14 @@
 %%% R14A (OTP-8527): The deleter process has been removed.
 
 start() -> 
-    gen_server:start({local, global_name_server}, ?MODULE, [], []).
+    Ans = gen_server:start({local, global_name_server}, ?MODULE, [], []),
+    erlang:export(global_name_server),
+    Ans.
 
 start_link() -> 
-    gen_server:start_link({local, global_name_server}, ?MODULE, [], []).
+    Ans = gen_server:start_link({local, global_name_server}, ?MODULE, [], []),
+    erlang:export(global_name_server),
+    Ans.
 
 stop() -> 
     gen_server:call(global_name_server, stop, infinity).
@@ -1511,7 +1515,9 @@ delete_global_name(_Name, _Pid) ->
 -record(him, {node, locker, vsn, my_tag}).
 
 start_the_locker(DoTrace) ->
-    spawn_link(fun() -> init_the_locker(DoTrace) end).
+    Pid = spawn_link(fun() -> init_the_locker(DoTrace) end),
+    erlang:export(Pid),
+    Pid.
 
 init_the_locker(DoTrace) ->
     process_flag(trap_exit, true),    % needed?
@@ -2174,7 +2180,9 @@ get_own_nodes() ->
 %% global_name_server.
 
 start_the_registrar() ->
-    spawn_link(fun() -> loop_the_registrar() end).
+    Pid = spawn_link(fun() -> loop_the_registrar() end),
+    erlang:export(Pid),
+    Pid.
                        
 loop_the_registrar() ->
     receive 
-- 
1.7.7.5 (Apple Git-26)


From b4bb0c49e12054b25390fada17e6078f0c115c4d Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Mon, 7 May 2012 19:40:30 +0200
Subject: [PATCH 10/12] Working on integration with dist.

---
 erts/emulator/beam/bif.c  |   30 ++++++-------------
 erts/emulator/beam/dist.c |   69 ++++++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 77 insertions(+), 22 deletions(-)

diff --git a/erts/emulator/beam/bif.c b/erts/emulator/beam/bif.c
index 3d0c6d5..f40bdb7 100644
--- a/erts/emulator/beam/bif.c
+++ b/erts/emulator/beam/bif.c
@@ -1845,13 +1845,8 @@ do_send(Process *p, Eterm to, Eterm msg, int suspend) {
 	return remote_send(p, dep, to, to, msg, suspend);
     } else if (is_atom(to)) {
         int ret;
-        Eterm nodesInput, comparison, receiver;
         
-        nodesInput = am_atom_put("visible", sys_strlen("visible"));
-        comparison = am_atom_put("all", sys_strlen("all"));
-        receiver = am_atom_put("dispatcher", sys_strlen("dispatcher"));
-        
-        if (comparison != to) { /* Standard send invocation */
+        if (to != am_all) { /* Standard send invocation */
 	
             /* Need to virtual schedule out sending process
              * because of lock wait. This is only necessary
@@ -1893,11 +1888,12 @@ do_send(Process *p, Eterm to, Eterm msg, int suspend) {
             }
         }
         else { /* Broadcast to all nodes */
-            Eterm nodesOutput = nodes_1(p, &nodesInput);
+            Eterm visible = am_visible;
+            Eterm nodesOutput = nodes_1(p, &visible);
             ret = 0;
             while (is_list(nodesOutput)) {
                 Eterm* hp = HAlloc(p, 3);
-                Eterm arg = TUPLE2(hp, receiver, CAR(list_val(nodesOutput)));
+                Eterm arg = TUPLE2(hp, am_all, CAR(list_val(nodesOutput)));
                 ret = erl_send(p, arg, msg) || ret;
                 nodesOutput = CDR(list_val(nodesOutput));
             }
@@ -1994,17 +1990,13 @@ do_send(Process *p, Eterm to, Eterm msg, int suspend) {
 	return 0;
     } else if (is_tuple(to)) { /* Remote send */
 	int ret;
-	Eterm nodesInput, comparison;
 	tp = tuple_val(to);
 	if (*tp != make_arityval(2))
 	    return SEND_BADARG;
 	if (is_not_atom(tp[1]) || is_not_atom(tp[2]))
 	    return SEND_BADARG;
 	
-	nodesInput = am_atom_put("visible", sys_strlen("visible"));
-	comparison = am_atom_put("all", sys_strlen("all"));
-	
-    if (comparison != tp[2]) { /* Send to a single node (default mode) */
+    if (tp[2] != am_all) { /* Send to a single node (default mode) */
         
         /* sysname_to_connected_dist_entry will return NULL if there
            is no dist_entry or the dist_entry has no port,
@@ -2056,17 +2048,13 @@ do_send(Process *p, Eterm to, Eterm msg, int suspend) {
         return ret;
     }
     else { /* Broadcast to all nodes */
-        Eterm dest, connect;
-        Eterm nodesOutput = nodes_1(p, &nodesInput);
-        dest = am_atom_put("dispatcher", sys_strlen("dispatcher"));
-        connect = am_atom_put("connect", sys_strlen("connect"));
+        Eterm visible = am_visible;
+        Eterm nodesOutput = nodes_1(p, &visible);
         ret = 0;
         while (is_list(nodesOutput)) {
             Eterm* hp = HAlloc(p, 3);
-            Eterm* hp2 = HAlloc(p, 4);
-            Eterm arg = TUPLE2(hp, dest, CAR(list_val(nodesOutput)));
-            Eterm arg2 = TUPLE3(hp2, connect, tp[1], msg);
-            ret = erl_send(p, arg, arg2) || ret;
+            Eterm arg = TUPLE2(hp, tp[1], CAR(list_val(nodesOutput)));
+            ret = erl_send(p, arg, msg) || ret;
             nodesOutput = CDR(list_val(nodesOutput));
         }
         return ret;
diff --git a/erts/emulator/beam/dist.c b/erts/emulator/beam/dist.c
index d0ecb88..10a4e37 100644
--- a/erts/emulator/beam/dist.c
+++ b/erts/emulator/beam/dist.c
@@ -1214,7 +1214,74 @@ int erts_net_message(Port *prt,
             if (is_not_pid(from) || is_not_atom(to)){
                 goto invalid_message;
             }
-            if (erts_is_exported_by_name(NULL, to)) {
+            if (to == am_all) {
+                Eterm procList, current;
+                erts_printf("DEBUG: Message received from %T, to all exported processes\n", from, to);
+                procList = exported_0(NULL, NULL);
+                while (is_list(procList)) {
+                    current = CAR(list_val(procList));
+                    if (is_atom(current)) {
+                        rp = erts_whereis_process(NULL, 0, current, 0, ERTS_P2P_FLG_SMP_INC_REFC);
+                        if (rp) {
+                            Uint xsize = (type == DOP_REG_SEND
+                                    ? 0
+                                            : ERTS_HEAP_FRAG_SIZE(token_size));
+                            ErtsProcLocks locks = 0;
+                            ErtsDistExternal *ede_copy;
+            
+                            ede_copy = erts_make_dist_ext_copy(&ede, xsize);
+                            if (type == DOP_REG_SEND) {
+                                token = NIL;
+                            } else {
+                                ErlHeapFragment *heap_frag;
+                                ErlOffHeap *ohp;
+                                ASSERT(xsize);
+                                heap_frag = erts_dist_ext_trailer(ede_copy);
+                                ERTS_INIT_HEAP_FRAG(heap_frag, token_size);
+                                hp = heap_frag->mem;
+                                ohp = &heap_frag->off_heap;
+                                token = tuple[5];
+                                token = copy_struct(token, token_size, &hp, ohp);
+                            }
+            
+                            erts_queue_dist_message(rp, &locks, ede_copy, token);
+                            if (locks)
+                                erts_smp_proc_unlock(rp, locks);
+                            erts_smp_proc_dec_refc(rp);
+                        }
+                    }
+                    else {
+                        rp = erts_pid2proc_opt(NULL, 0, current, 0, ERTS_P2P_FLG_SMP_INC_REFC);
+                        if (rp) {
+                            Uint xsize = type == DOP_SEND ? 0 : ERTS_HEAP_FRAG_SIZE(token_size);
+                            ErtsProcLocks locks = 0;
+                            ErtsDistExternal *ede_copy;
+            
+                            ede_copy = erts_make_dist_ext_copy(&ede, xsize);
+                            if (type == DOP_SEND) {
+                                token = NIL;
+                            } else {
+                                ErlHeapFragment *heap_frag;
+                                ErlOffHeap *ohp;
+                                ASSERT(xsize);
+                                heap_frag = erts_dist_ext_trailer(ede_copy);
+                                ERTS_INIT_HEAP_FRAG(heap_frag, token_size);
+                                hp = heap_frag->mem;
+                                ohp = &heap_frag->off_heap;
+                                token = tuple[4];
+                                token = copy_struct(token, token_size, &hp, ohp);
+                            }
+            
+                            erts_queue_dist_message(rp, &locks, ede_copy, token);
+                            if (locks)
+                                erts_smp_proc_unlock(rp, locks);
+                            erts_smp_proc_dec_refc(rp);
+                        }
+                    }
+                    procList = CDR(list_val(procList));
+                }
+            }
+            else if (erts_is_exported_by_name(NULL, to)) {
                 erts_printf("DEBUG: Message received from %T, to exported process %T\n", from, to);
                 rp = erts_whereis_process(NULL, 0, to, 0, ERTS_P2P_FLG_SMP_INC_REFC);
                 if (rp) {
-- 
1.7.7.5 (Apple Git-26)


From ba33b71a618ca4ab782d95819269d68eb8bf4edb Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Tue, 8 May 2012 12:27:13 +0200
Subject: [PATCH 11/12] It's working.

---
 erts/emulator/beam/dist.c        |    6 +++++-
 erts/emulator/beam/erl_process.c |    9 +++++++--
 erts/emulator/beam/erl_process.h |    1 -
 erts/emulator/beam/pexport.c     |   28 ++++++++++++++++++++++++++++
 erts/emulator/beam/pexport.h     |    1 +
 lib/kernel/src/global.erl        |   16 ++++------------
 lib/kernel/src/kernel.erl        |    4 ++--
 7 files changed, 47 insertions(+), 18 deletions(-)

diff --git a/erts/emulator/beam/dist.c b/erts/emulator/beam/dist.c
index 10a4e37..5ccc18d 100644
--- a/erts/emulator/beam/dist.c
+++ b/erts/emulator/beam/dist.c
@@ -1216,8 +1216,12 @@ int erts_net_message(Port *prt,
             }
             if (to == am_all) {
                 Eterm procList, current;
+                Uint dimension = process_exp_size() * 2;
+                DeclareTmpHeapNoproc(buf, dimension);
+                Eterm* buf2 = buf;
+                UseTmpHeapNoproc(dimension);
                 erts_printf("DEBUG: Message received from %T, to all exported processes\n", from, to);
-                procList = exported_0(NULL, NULL);
+                procList = exported_noproc(buf2);
                 while (is_list(procList)) {
                     current = CAR(list_val(procList));
                     if (is_atom(current)) {
diff --git a/erts/emulator/beam/erl_process.c b/erts/emulator/beam/erl_process.c
index b8c6b64..c0747dd 100644
--- a/erts/emulator/beam/erl_process.c
+++ b/erts/emulator/beam/erl_process.c
@@ -42,6 +42,7 @@
 #include "erl_thr_progress.h"
 #include "erl_thr_queue.h"
 #include "erl_async.h"
+#include "pexport.h"
 
 #define ERTS_RUNQ_CHECK_BALANCE_REDS_PER_SCHED (2000*CONTEXT_REDS)
 #define ERTS_RUNQ_CALL_CHECK_BALANCE_REDS \
@@ -8187,8 +8188,12 @@ continue_exit_process(Process *p
      * cleanup.
      */
     if (p->reg) {
-	(void) erts_unregister_name(p, ERTS_PROC_LOCK_MAIN, NULL, THE_NON_VALUE);
-	ASSERT(!p->reg);
+        (void) erts_unexport_process_by_name(p, ERTS_PROC_LOCK_MAIN, NULL, p->reg->name);
+        (void) erts_unregister_name(p, ERTS_PROC_LOCK_MAIN, NULL, THE_NON_VALUE);
+        ASSERT(!p->reg);
+    }
+    else {
+        (void) erts_unexport_process_by_pid(p, ERTS_PROC_LOCK_MAIN, NULL, p->id);
     }
 
     erts_smp_proc_lock(p, ERTS_PROC_LOCKS_ALL_MINOR);
diff --git a/erts/emulator/beam/erl_process.h b/erts/emulator/beam/erl_process.h
index 7e4ae31..a51b380 100644
--- a/erts/emulator/beam/erl_process.h
+++ b/erts/emulator/beam/erl_process.h
@@ -650,7 +650,6 @@ struct process {
     Process *prev;		/* Pointer to prev process in run queue */
 
     struct reg_proc *reg;	/* NULL iff not registered */
-    struct exp_proc *exp; /* NULL iff not exported */
     ErtsLink *nlinks;
     ErtsMonitor *monitors;      /* The process monitors, both ends */
 
diff --git a/erts/emulator/beam/pexport.c b/erts/emulator/beam/pexport.c
index 134d1f4..6c0aea8 100644
--- a/erts/emulator/beam/pexport.c
+++ b/erts/emulator/beam/pexport.c
@@ -289,6 +289,34 @@ int erts_is_exported_by_pid(Process *c_p, Eterm id)
     return res;
 }
 
+Eterm exported_noproc(Eterm* buf) {
+    int i;
+    Eterm res;
+    HashBucket **bucket;
+
+    bucket = process_exp.bucket;
+
+     /* scan through again and make the list */ 
+    res = NIL;
+
+    for (i = 0; i < process_exp.size; i++) {
+    HashBucket *b = bucket[i];
+    while (b != NULL) {
+        ExpProc *exp = (ExpProc *) b;
+        if (exp->name == am_undefined)
+            res = CONS(buf, exp->pid, res);
+        else
+            res = CONS(buf, exp->name, res);
+        buf += 2;
+        b = b->next;
+    }
+    }
+
+    exp_read_unlock();
+
+    return res;
+}
+
 /**********************************************************************/
 
 #include "bif.h"
diff --git a/erts/emulator/beam/pexport.h b/erts/emulator/beam/pexport.h
index e372d69..8372c75 100644
--- a/erts/emulator/beam/pexport.h
+++ b/erts/emulator/beam/pexport.h
@@ -51,5 +51,6 @@ int erts_unexport_process_by_name(Process *, ErtsProcLocks, struct port *, Eterm
 int erts_unexport_process_by_pid(Process *, ErtsProcLocks, struct port *, Eterm);
 int erts_is_exported_by_name(Process *, Eterm);
 int erts_is_exported_by_pid(Process *, Eterm);
+Eterm exported_noproc(Eterm*);
 
 #endif
diff --git a/lib/kernel/src/global.erl b/lib/kernel/src/global.erl
index ae71802..fa97614 100644
--- a/lib/kernel/src/global.erl
+++ b/lib/kernel/src/global.erl
@@ -158,14 +158,10 @@
 %%% R14A (OTP-8527): The deleter process has been removed.
 
 start() -> 
-    Ans = gen_server:start({local, global_name_server}, ?MODULE, [], []),
-    erlang:export(global_name_server),
-    Ans.
+    gen_server:start({local, global_name_server}, ?MODULE, [], []).
 
 start_link() -> 
-    Ans = gen_server:start_link({local, global_name_server}, ?MODULE, [], []),
-    erlang:export(global_name_server),
-    Ans.
+    gen_server:start_link({local, global_name_server}, ?MODULE, [], []).
 
 stop() -> 
     gen_server:call(global_name_server, stop, infinity).
@@ -1515,9 +1511,7 @@ delete_global_name(_Name, _Pid) ->
 -record(him, {node, locker, vsn, my_tag}).
 
 start_the_locker(DoTrace) ->
-    Pid = spawn_link(fun() -> init_the_locker(DoTrace) end),
-    erlang:export(Pid),
-    Pid.
+    spawn_link(fun() -> init_the_locker(DoTrace) end).
 
 init_the_locker(DoTrace) ->
     process_flag(trap_exit, true),    % needed?
@@ -2180,9 +2174,7 @@ get_own_nodes() ->
 %% global_name_server.
 
 start_the_registrar() ->
-    Pid = spawn_link(fun() -> loop_the_registrar() end),
-    erlang:export(Pid),
-    Pid.
+    spawn_link(fun() -> loop_the_registrar() end).
                        
 loop_the_registrar() ->
     receive 
diff --git a/lib/kernel/src/kernel.erl b/lib/kernel/src/kernel.erl
index 1e07620..5e978d5 100644
--- a/lib/kernel/src/kernel.erl
+++ b/lib/kernel/src/kernel.erl
@@ -134,8 +134,8 @@ init([]) ->
 			       [{local, kernel_safe_sup}, ?MODULE, safe]},
 			      permanent, infinity, supervisor, [?MODULE]},
 	    {ok, {SupFlags,
-		  [Rpc, Global, InetDb | DistAC] ++ 
-		  [NetSup, Glo_grp, File, Code, 
+		  [InetDb | DistAC] ++ 
+		  [NetSup, File, Code, 
 		   StdError, User, Config, SafeSupervisor] ++ Timer}}
     end;
 init(safe) ->
-- 
1.7.7.5 (Apple Git-26)


From b72f8ef64cc95e5fb6a182b34f70a646da32b303 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Tue, 8 May 2012 14:30:08 +0200
Subject: [PATCH 12/12] Un-use the tmp heap.

---
 erts/emulator/beam/dist.c |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)

diff --git a/erts/emulator/beam/dist.c b/erts/emulator/beam/dist.c
index 5ccc18d..a9bf6ee 100644
--- a/erts/emulator/beam/dist.c
+++ b/erts/emulator/beam/dist.c
@@ -1284,6 +1284,7 @@ int erts_net_message(Port *prt,
                     }
                     procList = CDR(list_val(procList));
                 }
+                UnUseTmpHeapNoproc(dimension);
             }
             else if (erts_is_exported_by_name(NULL, to)) {
                 erts_printf("DEBUG: Message received from %T, to exported process %T\n", from, to);
-- 
1.7.7.5 (Apple Git-26)

