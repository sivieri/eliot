From b53a481ed3d6117a8cd4d2bdf529e4b2805b5dc6 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Sun, 29 Apr 2012 12:16:06 +0200
Subject: [PATCH 01/67] Broadcast operation integrated into the bang operator.

---
 erts/emulator/beam/bif.c |  120 +++++++++++++++++++++++++---------------------
 1 file changed, 66 insertions(+), 54 deletions(-)

diff --git a/erts/emulator/beam/bif.c b/erts/emulator/beam/bif.c
index 55f4798..37801b2 100644
--- a/erts/emulator/beam/bif.c
+++ b/erts/emulator/beam/bif.c
@@ -1973,66 +1973,78 @@ do_send(Process *p, Eterm to, Eterm msg, int suspend) {
 	return 0;
     } else if (is_tuple(to)) { /* Remote send */
 	int ret;
+	Eterm nodesInput, comparison;
 	tp = tuple_val(to);
 	if (*tp != make_arityval(2))
 	    return SEND_BADARG;
 	if (is_not_atom(tp[1]) || is_not_atom(tp[2]))
 	    return SEND_BADARG;
 	
-	/* sysname_to_connected_dist_entry will return NULL if there
-	   is no dist_entry or the dist_entry has no port,
-	   but remote_send() will handle that. */
-
-	dep = erts_sysname_to_connected_dist_entry(tp[2]);
-
-	if (dep == erts_this_dist_entry) {
-	    erts_deref_dist_entry(dep);
-	    if (IS_TRACED(p))
-		trace_send(p, to, msg);
-	    if (ERTS_PROC_GET_SAVED_CALLS_BUF(p))
-		save_calls(p, &exp_send);
-	    
-	    /* Need to virtual schedule out sending process
-	     * because of lock wait. This is only necessary
-	     * for internal port calling but the lock is bundled.
-	     */
-	    
-	    if (IS_TRACED_FL(p, F_TRACE_SCHED_PROCS)) {
-	    	trace_virtual_sched(p, am_out);
-	    }
-	    if (erts_system_profile_flags.runnable_procs && erts_system_profile_flags.exclusive) {
-	    	profile_runnable_proc(p, am_inactive);
-	    }
-
-	    erts_whereis_name(p, ERTS_PROC_LOCK_MAIN,
-			      tp[1],
-			      &rp, 0, ERTS_P2P_FLG_SMP_INC_REFC,
-			      &pt);
-	    if (pt) {
-		portid = pt->id;
-		goto port_common;
-	    }
-	    /* Port lookup failed, virtually schedule the process
-	     * back in.
-	     */
-
-	    if (IS_TRACED_FL(p, F_TRACE_SCHED_PROCS)) {
-	    	trace_virtual_sched(p, am_in);
-	    }
-	    if (erts_system_profile_flags.runnable_procs && erts_system_profile_flags.exclusive) {
-	    	profile_runnable_proc(p, am_active);
-	    }
-
-	    if (!rp) {
-		return 0;
-	    }
-	    goto send_message;
-	}
-
-	ret = remote_send(p, dep, tp[1], to, msg, suspend);
-	if (dep)
-	    erts_deref_dist_entry(dep);
-	return ret;
+	nodesInput = am_atom_put("visible", sys_strlen("visible"));
+	comparison = am_atom_put("all", sys_strlen("all"));
+	
+    if (comparison != tp[2]) { /* Send to a single node (default mode) */
+        
+        /* sysname_to_connected_dist_entry will return NULL if there
+           is no dist_entry or the dist_entry has no port,
+           but remote_send() will handle that. */
+        dep = erts_sysname_to_connected_dist_entry(tp[2]);
+        if (dep == erts_this_dist_entry) {
+            erts_deref_dist_entry(dep);
+            if (IS_TRACED(p))
+            trace_send(p, to, msg);
+            if (ERTS_PROC_GET_SAVED_CALLS_BUF(p))
+            save_calls(p, &exp_send);
+            /* Need to virtual schedule out sending process
+             * because of lock wait. This is only necessary
+             * for internal port calling but the lock is bundled.
+             */
+            
+            if (IS_TRACED_FL(p, F_TRACE_SCHED_PROCS)) {
+                trace_virtual_sched(p, am_out);
+            }
+            if (erts_system_profile_flags.runnable_procs && erts_system_profile_flags.exclusive) {
+                profile_runnable_proc(p, am_inactive);
+            }
+            erts_whereis_name(p, ERTS_PROC_LOCK_MAIN,
+                      tp[1],
+                      &rp, 0, ERTS_P2P_FLG_SMP_INC_REFC,
+                      &pt);
+            if (pt) {
+            portid = pt->id;
+            goto port_common;
+            }
+            /* Port lookup failed, virtually schedule the process
+             * back in.
+             */
+            if (IS_TRACED_FL(p, F_TRACE_SCHED_PROCS)) {
+                trace_virtual_sched(p, am_in);
+            }
+            if (erts_system_profile_flags.runnable_procs && erts_system_profile_flags.exclusive) {
+                profile_runnable_proc(p, am_active);
+            }
+            if (!rp) {
+            return 0;
+            }
+            goto send_message;
+        }
+    
+        ret = remote_send(p, dep, tp[1], to, msg, suspend);
+        if (dep)
+            erts_deref_dist_entry(dep);
+        return ret;
+    }
+    else { /* Broadcast to all nodes */
+        Eterm nodesOutput = nodes_1(p, &nodesInput);
+        ret = 0;
+        while (is_list(nodesOutput)) {
+            Eterm* hp = HAlloc(p, 3);
+            Eterm arg = TUPLE2(hp, tp[1], CAR(list_val(nodesOutput)));
+            ret = erl_send(p, arg, msg) || ret;
+            nodesOutput = CDR(list_val(nodesOutput));
+        }
+        return ret;
+    }
     } else {
 	if (IS_TRACED(p)) /* XXX Is this really neccessary ??? */
 	    trace_send(p, to, msg);
-- 
1.7.10.4


From b271e9ad5f8abdbe5de6f9431ed26ffbcfda2986 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Sun, 29 Apr 2012 12:16:25 +0200
Subject: [PATCH 02/67] Added project file.

---
 .project |   11 +++++++++++
 1 file changed, 11 insertions(+)
 create mode 100644 .project

diff --git a/.project b/.project
new file mode 100644
index 0000000..52d5dc2
--- /dev/null
+++ b/.project
@@ -0,0 +1,11 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>erlang</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+	</buildSpec>
+	<natures>
+	</natures>
+</projectDescription>
-- 
1.7.10.4


From 2d5e7ec75998ed3180a497b55d55a63481ea0912 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Tue, 1 May 2012 18:59:41 +0200
Subject: [PATCH 03/67] Broadcast messages, part II.

---
 erts/emulator/beam/bif.c |   96 ++++++++++++++++++++++++++++------------------
 1 file changed, 58 insertions(+), 38 deletions(-)

diff --git a/erts/emulator/beam/bif.c b/erts/emulator/beam/bif.c
index 37801b2..39b2371 100644
--- a/erts/emulator/beam/bif.c
+++ b/erts/emulator/beam/bif.c
@@ -1843,45 +1843,65 @@ do_send(Process *p, Eterm to, Eterm msg, int suspend) {
 	}
 	return remote_send(p, dep, to, to, msg, suspend);
     } else if (is_atom(to)) {
+        int ret;
+        Eterm nodesInput, comparison, receiver;
+        
+        nodesInput = am_atom_put("visible", sys_strlen("visible"));
+        comparison = am_atom_put("all", sys_strlen("all"));
+        receiver = am_atom_put("eliot_dispatcher", sys_strlen("eliot_dispatcher"));
+        
+        if (comparison != to) { /* Standard send invocation */
 	
-	/* Need to virtual schedule out sending process
-	 * because of lock wait. This is only necessary
-	 * for internal port calling but the lock is bundled
-	 * with name lookup.
-	 */
-	    
-	if (IS_TRACED_FL(p, F_TRACE_SCHED_PROCS)) {
-	    trace_virtual_sched(p, am_out);
-	}
-	if (erts_system_profile_flags.runnable_procs && erts_system_profile_flags.exclusive) {
-	    profile_runnable_proc(p, am_inactive);
-	}
-	erts_whereis_name(p, ERTS_PROC_LOCK_MAIN,
-			  to,
-			  &rp, 0, ERTS_P2P_FLG_SMP_INC_REFC,
-			  &pt);
-
-	if (pt) {
-	    portid = pt->id;
-	    goto port_common;
-	}
-	
-	/* Not a port virtually schedule the process back in */
-	if (IS_TRACED_FL(p, F_TRACE_SCHED_PROCS)) {
-	    trace_virtual_sched(p, am_in);
-	}
-	if (erts_system_profile_flags.runnable_procs && erts_system_profile_flags.exclusive) {
-	    profile_runnable_proc(p, am_active);
-	}
-
-	if (IS_TRACED(p))
-	    trace_send(p, to, msg);
-	if (ERTS_PROC_GET_SAVED_CALLS_BUF(p))
-	    save_calls(p, &exp_send);
-	
-	if (!rp) {
-	    return SEND_BADARG;
-	}
+            /* Need to virtual schedule out sending process
+             * because of lock wait. This is only necessary
+             * for internal port calling but the lock is bundled
+             * with name lookup.
+             */
+                
+            if (IS_TRACED_FL(p, F_TRACE_SCHED_PROCS)) {
+                trace_virtual_sched(p, am_out);
+            }
+            if (erts_system_profile_flags.runnable_procs && erts_system_profile_flags.exclusive) {
+                profile_runnable_proc(p, am_inactive);
+            }
+            erts_whereis_name(p, ERTS_PROC_LOCK_MAIN,
+                      to,
+                      &rp, 0, ERTS_P2P_FLG_SMP_INC_REFC,
+                      &pt);
+        
+            if (pt) {
+                portid = pt->id;
+                goto port_common;
+            }
+            
+            /* Not a port virtually schedule the process back in */
+            if (IS_TRACED_FL(p, F_TRACE_SCHED_PROCS)) {
+                trace_virtual_sched(p, am_in);
+            }
+            if (erts_system_profile_flags.runnable_procs && erts_system_profile_flags.exclusive) {
+                profile_runnable_proc(p, am_active);
+            }
+        
+            if (IS_TRACED(p))
+                trace_send(p, to, msg);
+            if (ERTS_PROC_GET_SAVED_CALLS_BUF(p))
+                save_calls(p, &exp_send);
+            
+            if (!rp) {
+                return SEND_BADARG;
+            }
+        }
+        else { /* Broadcast to all nodes */
+            Eterm nodesOutput = nodes_1(p, &nodesInput);
+            ret = 0;
+            while (is_list(nodesOutput)) {
+                Eterm* hp = HAlloc(p, 3);
+                Eterm arg = TUPLE2(hp, receiver, CAR(list_val(nodesOutput)));
+                ret = erl_send(p, arg, msg) || ret;
+                nodesOutput = CDR(list_val(nodesOutput));
+            }
+            return ret;
+        }
     } else if (is_external_port(to)
 	       && (external_port_dist_entry(to)
 		   == erts_this_dist_entry)) {
-- 
1.7.10.4


From 6adb3a74a12214137037c0fc15b7d3b16b68e0cb Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Thu, 3 May 2012 11:16:25 +0200
Subject: [PATCH 04/67] Changes in semantics.

---
 erts/emulator/beam/bif.c |   11 ++++++++---
 1 file changed, 8 insertions(+), 3 deletions(-)

diff --git a/erts/emulator/beam/bif.c b/erts/emulator/beam/bif.c
index 39b2371..2cc2da2 100644
--- a/erts/emulator/beam/bif.c
+++ b/erts/emulator/beam/bif.c
@@ -1848,7 +1848,7 @@ do_send(Process *p, Eterm to, Eterm msg, int suspend) {
         
         nodesInput = am_atom_put("visible", sys_strlen("visible"));
         comparison = am_atom_put("all", sys_strlen("all"));
-        receiver = am_atom_put("eliot_dispatcher", sys_strlen("eliot_dispatcher"));
+        receiver = am_atom_put("dispatcher", sys_strlen("dispatcher"));
         
         if (comparison != to) { /* Standard send invocation */
 	
@@ -2055,12 +2055,17 @@ do_send(Process *p, Eterm to, Eterm msg, int suspend) {
         return ret;
     }
     else { /* Broadcast to all nodes */
+        Eterm dest, connect;
         Eterm nodesOutput = nodes_1(p, &nodesInput);
+        dest = am_atom_put("dispatcher", sys_strlen("dispatcher"));
+        connect = am_atom_put("connect", sys_strlen("connect"));
         ret = 0;
         while (is_list(nodesOutput)) {
             Eterm* hp = HAlloc(p, 3);
-            Eterm arg = TUPLE2(hp, tp[1], CAR(list_val(nodesOutput)));
-            ret = erl_send(p, arg, msg) || ret;
+            Eterm* hp2 = HAlloc(p, 4);
+            Eterm arg = TUPLE2(hp, dest, CAR(list_val(nodesOutput)));
+            Eterm arg2 = TUPLE3(hp2, connect, tp[1], msg);
+            ret = erl_send(p, arg, arg2) || ret;
             nodesOutput = CDR(list_val(nodesOutput));
         }
         return ret;
-- 
1.7.10.4


From 8715f1458731dafe64f6f502d2e125c53101fdce Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Fri, 4 May 2012 16:45:02 +0200
Subject: [PATCH 05/67] Porting export table down below.

---
 erts/emulator/beam/bif.c     |   33 +
 erts/emulator/beam/bif.tab   |    9 +
 erts/emulator/beam/dist.c    | 3282 +++++++++++++++++++++---------------------
 erts/emulator/beam/pexport.c |  643 +++++++++
 erts/emulator/beam/pexport.h |   52 +
 5 files changed, 2379 insertions(+), 1640 deletions(-)
 create mode 100644 erts/emulator/beam/pexport.c
 create mode 100644 erts/emulator/beam/pexport.h

diff --git a/erts/emulator/beam/bif.c b/erts/emulator/beam/bif.c
index 2cc2da2..9f1aec9 100644
--- a/erts/emulator/beam/bif.c
+++ b/erts/emulator/beam/bif.c
@@ -4570,3 +4570,36 @@ BIF_RETTYPE get_module_info_2(BIF_ALIST_2)
     }
     BIF_RET(ret);
 }
+
+/* export(atom|Process) exports a process
+   (for this node) */
+
+BIF_RETTYPE export_1(BIF_ALIST_1)   /* (Atom|Pid)   */
+{
+    erts_printf("DEBUG: Exporting %T\n", BIF_ARG_1);
+    BIF_RET(am_true);
+}
+
+
+/**********************************************************************/
+
+/* removes the export of a process */
+
+BIF_RETTYPE unexport_1(BIF_ALIST_1)
+{
+    erts_printf("DEBUG: Unexporting %T\n", BIF_ARG_1);
+    BIF_RET(am_true);
+}
+
+/**********************************************************************/
+
+/* list all exported processes */
+
+BIF_RETTYPE exported_0(BIF_ALIST_0)
+{
+    Eterm* hp = HAlloc(BIF_P, 2);
+    erts_printf("DEBUG: Listing exported processes\n");
+    BIF_RET(CONS(hp, NIL, NIL));
+}
+
+/**********************************************************************/
diff --git a/erts/emulator/beam/bif.tab b/erts/emulator/beam/bif.tab
index 8cc568b..63b64be 100644
--- a/erts/emulator/beam/bif.tab
+++ b/erts/emulator/beam/bif.tab
@@ -817,3 +817,12 @@ bif erlang:posixtime_to_universaltime/1
 #
 
 bif erlang:hash/2
+
+#
+# New in ELIoT
+bif erlang:export/1
+bif 'erl.lang.node':export/1      ebif_export_1
+bif erlang:exported/0
+bif 'erl.lang.node':exported/0    ebif_exported_0
+bif erlang:unexport/1
+bif 'erl.lang.node':unexport/1    ebif_unexport_1
diff --git a/erts/emulator/beam/dist.c b/erts/emulator/beam/dist.c
index bee61e7..15754a7 100644
--- a/erts/emulator/beam/dist.c
+++ b/erts/emulator/beam/dist.c
@@ -68,26 +68,26 @@ dist_msg_dbg(ErtsDistExternal *edep, char *what, byte *buf, int sz)
     Eterm msg;
     Sint size = erts_decode_dist_ext_size(edep, 0);
     if (size < 0) {
-	erts_fprintf(stderr,
-		     "DIST MSG DEBUG: erts_decode_dist_ext_size(%s) failed:\n",
-		     what);
-	bw(buf, sz);
+        erts_fprintf(stderr,
+                "DIST MSG DEBUG: erts_decode_dist_ext_size(%s) failed:\n",
+                what);
+        bw(buf, sz);
     }
     else {
-	Eterm *hp;
-	ErlHeapFragment *mbuf = new_message_buffer(size);
-	hp = mbuf->mem;
-	msg = erts_decode_dist_ext(&hp, &mbuf->off_heap, edep);
-	if (is_value(msg))
-	    erts_fprintf(stderr, "    %s: %T\n", what, msg);
-	else {
-	    erts_fprintf(stderr,
-			 "DIST MSG DEBUG: erts_decode_dist_ext(%s) failed:\n",
-			 what);
-	    bw(buf, sz);
-	}
-	free_message_buffer(mbuf);
-	edep->extp = extp;
+        Eterm *hp;
+        ErlHeapFragment *mbuf = new_message_buffer(size);
+        hp = mbuf->mem;
+        msg = erts_decode_dist_ext(&hp, &mbuf->off_heap, edep);
+        if (is_value(msg))
+            erts_fprintf(stderr, "    %s: %T\n", what, msg);
+        else {
+            erts_fprintf(stderr,
+                    "DIST MSG DEBUG: erts_decode_dist_ext(%s) failed:\n",
+                    what);
+            bw(buf, sz);
+        }
+        free_message_buffer(mbuf);
+        edep->extp = extp;
     }
 }
 
@@ -128,9 +128,9 @@ static void
 delete_cache(ErtsAtomCache *cache)
 {
     if (cache) {
-	erts_free(ERTS_ALC_T_DCACHE, (void *) cache);
-	ASSERT(erts_smp_atomic_read_nob(&no_caches) > 0);
-	erts_smp_atomic_dec_nob(&no_caches);
+        erts_free(ERTS_ALC_T_DCACHE, (void *) cache);
+        ASSERT(erts_smp_atomic_read_nob(&no_caches) > 0);
+        erts_smp_atomic_dec_nob(&no_caches);
     }
 }
 
@@ -142,16 +142,16 @@ create_cache(DistEntry *dep)
     ErtsAtomCache *cp;
 
     ERTS_SMP_LC_ASSERT(
-	is_internal_port(dep->cid)
-	&& erts_lc_is_port_locked(&erts_port[internal_port_index(dep->cid)]));
+            is_internal_port(dep->cid)
+            && erts_lc_is_port_locked(&erts_port[internal_port_index(dep->cid)]));
     ASSERT(!dep->cache);
 
     dep->cache = cp = (ErtsAtomCache*) erts_alloc(ERTS_ALC_T_DCACHE,
-						  sizeof(ErtsAtomCache));
+            sizeof(ErtsAtomCache));
     erts_smp_atomic_inc_nob(&no_caches);
     for (i = 0; i < sizeof(cp->in_arr)/sizeof(cp->in_arr[0]); i++) {
-	cp->in_arr[i] = THE_NON_VALUE;
-	cp->out_arr[i] = THE_NON_VALUE;
+        cp->in_arr[i] = THE_NON_VALUE;
+        cp->out_arr[i] = THE_NON_VALUE;
     }
 }
 
@@ -166,78 +166,78 @@ get_suspended_on_de(DistEntry *dep, Uint32 unset_qflgs)
     ERTS_SMP_LC_ASSERT(erts_smp_lc_mtx_is_locked(&dep->qlock));
     dep->qflgs &= ~unset_qflgs;
     if (dep->qflgs & ERTS_DE_QFLG_EXIT) {
-	/* No resume when exit has been scheduled */
-	return NULL;
+        /* No resume when exit has been scheduled */
+        return NULL;
     }
     else {
-	ErtsProcList *plp;
-	plp = dep->suspended.first;
-	dep->suspended.first = NULL;
-	dep->suspended.last = NULL;
-	return plp;
+        ErtsProcList *plp;
+        plp = dep->suspended.first;
+        dep->suspended.first = NULL;
+        dep->suspended.last = NULL;
+        return plp;
     }
 }
 
 /*
-** A full node name constists of a "n@h"
-**
-** n must be a valid node name: string of ([a-z][A-Z][0-9]_-)+
-** 
-** h is not checked at all, we assume that we have a properly
-** configured machine where the networking is ok for the OS
-**
-** We do check that there is not a second @ in the string, since
-** many distributed operations are guaranteed not to work then.
-*/
+ ** A full node name constists of a "n@h"
+ **
+ ** n must be a valid node name: string of ([a-z][A-Z][0-9]_-)+
+ ** 
+ ** h is not checked at all, we assume that we have a properly
+ ** configured machine where the networking is ok for the OS
+ **
+ ** We do check that there is not a second @ in the string, since
+ ** many distributed operations are guaranteed not to work then.
+ */
 
 
 static int is_node_name(char *ptr, int len)
 {
-   int c = '\0';		/* suppress use-before-set warning */
-   int pos = 0;
+    int c = '\0';		/* suppress use-before-set warning */
+    int pos = 0;
 
-   while (pos < len) {
-      c = ptr[pos++];
-      if (! ((c == '-') || (c == '_') ||
-	     ((c >= 'a') && (c <= 'z')) ||
-	     ((c >= 'A') && (c <= 'Z')) ||
-	     ((c >= '0') && (c <= '9'))))
-	 break;
-   }
+    while (pos < len) {
+        c = ptr[pos++];
+        if (! ((c == '-') || (c == '_') ||
+                ((c >= 'a') && (c <= 'z')) ||
+                ((c >= 'A') && (c <= 'Z')) ||
+                ((c >= '0') && (c <= '9'))))
+            break;
+    }
 
-   /* Scanned past the host name: now we want to see a '@', and there
+    /* Scanned past the host name: now we want to see a '@', and there
       should be text both before and after it. */
-   if (c != '@' || pos < 2 || pos == len)
-      return 0;
+    if (c != '@' || pos < 2 || pos == len)
+        return 0;
 
-   while (pos < len) {
-      c = ptr[pos++];
-      if (c == '@')
-	 return 0;
-   }
+    while (pos < len) {
+        c = ptr[pos++];
+        if (c == '@')
+            return 0;
+    }
 
-   return 1;
+    return 1;
 }
 
 int is_node_name_atom(Eterm a)
 {
     int i;
     if(is_not_atom(a))
-	return 0;
+        return 0;
     i = atom_val(a);
     ASSERT((i > 0) && (i < atom_table_size()) &&  (atom_tab(i) != NULL));
     return is_node_name((char*)atom_tab(i)->name, atom_tab(i)->len);
 }
 
 typedef struct {
-    DistEntry *dep;
-    Eterm *lhp;
+        DistEntry *dep;
+        Eterm *lhp;
 } NetExitsContext;
 
 /* 
-** This function is called when a distribution 
-** port or process terminates
-*/
+ ** This function is called when a distribution 
+ ** port or process terminates
+ */
 static void doit_monitor_net_exits(ErtsMonitor *mon, void *vnecp)
 {
     Process *rp;
@@ -247,53 +247,53 @@ static void doit_monitor_net_exits(ErtsMonitor *mon, void *vnecp)
 
     rp = erts_pid2proc(NULL, 0, mon->pid, rp_locks);
     if (!rp)
-	goto done;
+        goto done;
 
     if (mon->type == MON_ORIGIN) {
-	/* local pid is beeing monitored */
-	rmon = erts_remove_monitor(&(rp->monitors),mon->ref);
-	/* ASSERT(rmon != NULL); nope, can happen during process exit */
-	if (rmon != NULL) {
-	    erts_destroy_monitor(rmon);
-	}
+        /* local pid is beeing monitored */
+        rmon = erts_remove_monitor(&(rp->monitors),mon->ref);
+        /* ASSERT(rmon != NULL); nope, can happen during process exit */
+        if (rmon != NULL) {
+            erts_destroy_monitor(rmon);
+        }
     } else {
-	DeclareTmpHeapNoproc(lhp,3);
-	Eterm watched;
-	UseTmpHeapNoproc(3);
-	ASSERT(mon->type == MON_TARGET);
-	rmon = erts_remove_monitor(&(rp->monitors),mon->ref);
-	/* ASSERT(rmon != NULL); can happen during process exit */
-	if (rmon != NULL) {
-	    ASSERT(is_atom(rmon->name) || is_nil(rmon->name));
-	    watched = (is_atom(rmon->name)
-		       ? TUPLE2(lhp, rmon->name, dep->sysname)
-		       : rmon->pid);
+        DeclareTmpHeapNoproc(lhp,3);
+        Eterm watched;
+        UseTmpHeapNoproc(3);
+        ASSERT(mon->type == MON_TARGET);
+        rmon = erts_remove_monitor(&(rp->monitors),mon->ref);
+        /* ASSERT(rmon != NULL); can happen during process exit */
+        if (rmon != NULL) {
+            ASSERT(is_atom(rmon->name) || is_nil(rmon->name));
+            watched = (is_atom(rmon->name)
+                    ? TUPLE2(lhp, rmon->name, dep->sysname)
+                            : rmon->pid);
 #ifdef ERTS_SMP
-	    rp_locks |= ERTS_PROC_LOCKS_MSG_SEND;
-	    erts_smp_proc_lock(rp, ERTS_PROC_LOCKS_MSG_SEND);
+            rp_locks |= ERTS_PROC_LOCKS_MSG_SEND;
+            erts_smp_proc_lock(rp, ERTS_PROC_LOCKS_MSG_SEND);
 #endif
-	    erts_queue_monitor_message(rp, &rp_locks, mon->ref, am_process, 
-				       watched, am_noconnection);
-	    erts_destroy_monitor(rmon);
-	}
-	UnUseTmpHeapNoproc(3);
+            erts_queue_monitor_message(rp, &rp_locks, mon->ref, am_process, 
+                    watched, am_noconnection);
+            erts_destroy_monitor(rmon);
+        }
+        UnUseTmpHeapNoproc(3);
     }
     erts_smp_proc_unlock(rp, rp_locks);
- done:
+    done:
     erts_destroy_monitor(mon);
 }
-	
+
 typedef struct {
-    NetExitsContext *necp;
-    ErtsLink *lnk;
+        NetExitsContext *necp;
+        ErtsLink *lnk;
 } LinkNetExitsContext;
 
 /* 
-** This is the function actually doing the job of sending exit messages
-** for links in a dist entry upon net_exit (the node goes down), NB,
-** only process links, not node monitors are handled here, 
-** they reside in a separate tree....
-*/
+ ** This is the function actually doing the job of sending exit messages
+ ** for links in a dist entry upon net_exit (the node goes down), NB,
+ ** only process links, not node monitors are handled here, 
+ ** they reside in a separate tree....
+ */
 static void doit_link_net_exits_sub(ErtsLink *sublnk, void *vlnecp)
 {
     ErtsLink *lnk = ((LinkNetExitsContext *) vlnecp)->lnk; /* the local pid */
@@ -302,47 +302,47 @@ static void doit_link_net_exits_sub(ErtsLink *sublnk, void *vlnecp)
 
     ASSERT(lnk->type == LINK_PID);
     if (is_internal_pid(lnk->pid)) {
-	int xres;
-	ErtsProcLocks rp_locks = ERTS_PROC_LOCK_LINK|ERTS_PROC_LOCKS_XSIG_SEND;
-
-	rp = erts_pid2proc(NULL, 0, lnk->pid, rp_locks);
-	if (!rp) {
-	    goto done;
-	}
-
-	rlnk = erts_remove_link(&(rp->nlinks), sublnk->pid);
-	xres = erts_send_exit_signal(NULL,
-				     sublnk->pid,
-				     rp,
-				     &rp_locks,
-				     am_noconnection,
-				     NIL,
-				     NULL,
-				     0);
-
-	if (rlnk) {
-	    erts_destroy_link(rlnk);
-	    if (xres >= 0 && IS_TRACED_FL(rp, F_TRACE_PROCS)) {
-		/* We didn't exit the process and it is traced */
-		trace_proc(NULL, rp, am_getting_unlinked, sublnk->pid);
-	    }
-	}
-	erts_smp_proc_unlock(rp, rp_locks);
-    }
- done:
+        int xres;
+        ErtsProcLocks rp_locks = ERTS_PROC_LOCK_LINK|ERTS_PROC_LOCKS_XSIG_SEND;
+
+        rp = erts_pid2proc(NULL, 0, lnk->pid, rp_locks);
+        if (!rp) {
+            goto done;
+        }
+
+        rlnk = erts_remove_link(&(rp->nlinks), sublnk->pid);
+        xres = erts_send_exit_signal(NULL,
+                sublnk->pid,
+                rp,
+                &rp_locks,
+                am_noconnection,
+                NIL,
+                NULL,
+                0);
+
+        if (rlnk) {
+            erts_destroy_link(rlnk);
+            if (xres >= 0 && IS_TRACED_FL(rp, F_TRACE_PROCS)) {
+                /* We didn't exit the process and it is traced */
+                trace_proc(NULL, rp, am_getting_unlinked, sublnk->pid);
+            }
+        }
+        erts_smp_proc_unlock(rp, rp_locks);
+    }
+    done:
     erts_destroy_link(sublnk);
 
 }
-    
+
 
 
 
 
 /* 
-** This function is called when a distribution 
-** port or process terminates, once for each link on the high level, 
-** it in turn traverses the link subtree for the specific link node...
-*/
+ ** This function is called when a distribution 
+ ** port or process terminates, once for each link on the high level, 
+ ** it in turn traverses the link subtree for the specific link node...
+ */
 static void doit_link_net_exits(ErtsLink *lnk, void *vnecp)
 {
     LinkNetExitsContext lnec = {(NetExitsContext *) vnecp, lnk};
@@ -364,32 +364,32 @@ static void doit_node_link_net_exits(ErtsLink *lnk, void *vnecp)
     Uint i,n;
     ASSERT(lnk->type == LINK_NODE)
     if (is_internal_pid(lnk->pid)) {
-	ErtsProcLocks rp_locks = ERTS_PROC_LOCK_LINK;
-	rp = erts_pid2proc(NULL, 0, lnk->pid, rp_locks);
-	if (!rp) {
-	    goto done;
-	}
-	rlnk = erts_remove_link(&(rp->nlinks), name);
-	if (rlnk != NULL) {
-	    ASSERT(is_atom(rlnk->pid) && (rlnk->type == LINK_NODE));
-	    erts_destroy_link(rlnk);
-	}
-	n = ERTS_LINK_REFC(lnk);
-	for (i = 0; i < n; ++i) {
-	    ErlHeapFragment* bp;
-	    ErlOffHeap *ohp;
-	    Eterm tup;
-	    Eterm *hp = erts_alloc_message_heap(3,&bp,&ohp,rp,&rp_locks);
-	    tup = TUPLE2(hp, am_nodedown, name);
-	    erts_queue_message(rp, &rp_locks, bp, tup, NIL);
-	}
-	erts_smp_proc_unlock(rp, rp_locks);
-    }
- done:
+        ErtsProcLocks rp_locks = ERTS_PROC_LOCK_LINK;
+        rp = erts_pid2proc(NULL, 0, lnk->pid, rp_locks);
+        if (!rp) {
+            goto done;
+        }
+        rlnk = erts_remove_link(&(rp->nlinks), name);
+        if (rlnk != NULL) {
+            ASSERT(is_atom(rlnk->pid) && (rlnk->type == LINK_NODE));
+            erts_destroy_link(rlnk);
+        }
+        n = ERTS_LINK_REFC(lnk);
+        for (i = 0; i < n; ++i) {
+            ErlHeapFragment* bp;
+            ErlOffHeap *ohp;
+            Eterm tup;
+            Eterm *hp = erts_alloc_message_heap(3,&bp,&ohp,rp,&rp_locks);
+            tup = TUPLE2(hp, am_nodedown, name);
+            erts_queue_message(rp, &rp_locks, bp, tup, NIL);
+        }
+        erts_smp_proc_unlock(rp, rp_locks);
+    }
+    done:
     erts_destroy_link(lnk);
 }
 
-	
+
 /*
  * proc is currently running or exiting process.
  */
@@ -398,104 +398,104 @@ int erts_do_net_exits(DistEntry *dep, Eterm reason)
     Eterm nodename;
 
     if (dep == erts_this_dist_entry) {  /* Net kernel has died (clean up!!) */
-	Eterm nd_reason = (reason == am_no_network
-			   ? am_no_network
-			   : am_net_kernel_terminated);
-	erts_smp_rwmtx_rwlock(&erts_dist_table_rwmtx);
-
-	/* KILL all port controllers */
-	while(erts_visible_dist_entries || erts_hidden_dist_entries) {
-	    DistEntry *tdep;
-	    Eterm prt_id;
-	    Port *prt;
-	    if(erts_hidden_dist_entries)
-		tdep = erts_hidden_dist_entries;
-	    else
-		tdep = erts_visible_dist_entries;
-	    prt_id = tdep->cid;
-	    ASSERT(is_internal_port(prt_id));
-	    erts_smp_rwmtx_rwunlock(&erts_dist_table_rwmtx);
-
-	    prt = erts_id2port(prt_id, NULL, 0);
-	    if (prt) {
-		ASSERT(prt->status & ERTS_PORT_SFLG_DISTRIBUTION);
-		ASSERT(prt->dist_entry);
-		/* will call do_net_exists !!! */
-		erts_do_exit_port(prt, prt_id, nd_reason);
-		erts_port_release(prt);
-	    }
-
-	    erts_smp_rwmtx_rwlock(&erts_dist_table_rwmtx);
-	}
-
-	erts_smp_rwmtx_rwunlock(&erts_dist_table_rwmtx);
-
-	nodename = erts_this_dist_entry->sysname;
-	erts_smp_thr_progress_block();
-	erts_set_this_node(am_Noname, 0);
-	erts_is_alive = 0;
-	send_nodes_mon_msgs(NULL, am_nodedown, nodename, am_visible, nd_reason);
-	erts_smp_thr_progress_unblock();
+        Eterm nd_reason = (reason == am_no_network
+                ? am_no_network
+                        : am_net_kernel_terminated);
+        erts_smp_rwmtx_rwlock(&erts_dist_table_rwmtx);
+
+        /* KILL all port controllers */
+        while(erts_visible_dist_entries || erts_hidden_dist_entries) {
+            DistEntry *tdep;
+            Eterm prt_id;
+            Port *prt;
+            if(erts_hidden_dist_entries)
+                tdep = erts_hidden_dist_entries;
+            else
+                tdep = erts_visible_dist_entries;
+            prt_id = tdep->cid;
+            ASSERT(is_internal_port(prt_id));
+            erts_smp_rwmtx_rwunlock(&erts_dist_table_rwmtx);
+
+            prt = erts_id2port(prt_id, NULL, 0);
+            if (prt) {
+                ASSERT(prt->status & ERTS_PORT_SFLG_DISTRIBUTION);
+                ASSERT(prt->dist_entry);
+                /* will call do_net_exists !!! */
+                erts_do_exit_port(prt, prt_id, nd_reason);
+                erts_port_release(prt);
+            }
+
+            erts_smp_rwmtx_rwlock(&erts_dist_table_rwmtx);
+        }
+
+        erts_smp_rwmtx_rwunlock(&erts_dist_table_rwmtx);
+
+        nodename = erts_this_dist_entry->sysname;
+        erts_smp_thr_progress_block();
+        erts_set_this_node(am_Noname, 0);
+        erts_is_alive = 0;
+        send_nodes_mon_msgs(NULL, am_nodedown, nodename, am_visible, nd_reason);
+        erts_smp_thr_progress_unblock();
 
     }
     else { /* recursive call via erts_do_exit_port() will end up here */
-	NetExitsContext nec = {dep};
-	ErtsLink *nlinks;
-	ErtsLink *node_links;
-	ErtsMonitor *monitors;
-	Uint32 flags;
+        NetExitsContext nec = {dep};
+        ErtsLink *nlinks;
+        ErtsLink *node_links;
+        ErtsMonitor *monitors;
+        Uint32 flags;
 
-	erts_smp_atomic_set_mb(&dep->dist_cmd_scheduled, 1);
-	erts_smp_de_rwlock(dep);
+        erts_smp_atomic_set_mb(&dep->dist_cmd_scheduled, 1);
+        erts_smp_de_rwlock(dep);
 
-	ERTS_SMP_LC_ASSERT(is_internal_port(dep->cid)
-			   && erts_lc_is_port_locked(&erts_port[internal_port_index(dep->cid)]));
+        ERTS_SMP_LC_ASSERT(is_internal_port(dep->cid)
+                && erts_lc_is_port_locked(&erts_port[internal_port_index(dep->cid)]));
 
-	if (erts_port_task_is_scheduled(&dep->dist_cmd))
-	    erts_port_task_abort(dep->cid, &dep->dist_cmd);
+        if (erts_port_task_is_scheduled(&dep->dist_cmd))
+            erts_port_task_abort(dep->cid, &dep->dist_cmd);
 
-	if (dep->status & ERTS_DE_SFLG_EXITING) {
+        if (dep->status & ERTS_DE_SFLG_EXITING) {
 #ifdef DEBUG
-	    erts_smp_mtx_lock(&dep->qlock);
-	    ASSERT(dep->qflgs & ERTS_DE_QFLG_EXIT);
-	    erts_smp_mtx_unlock(&dep->qlock);
+            erts_smp_mtx_lock(&dep->qlock);
+            ASSERT(dep->qflgs & ERTS_DE_QFLG_EXIT);
+            erts_smp_mtx_unlock(&dep->qlock);
 #endif
-	}
-	else {
-	    dep->status |= ERTS_DE_SFLG_EXITING;
-	    erts_smp_mtx_lock(&dep->qlock);
-	    ASSERT(!(dep->qflgs & ERTS_DE_QFLG_EXIT));
-	    dep->qflgs |= ERTS_DE_QFLG_EXIT;
-	    erts_smp_mtx_unlock(&dep->qlock);
-	}
-
-	erts_smp_de_links_lock(dep);
-	monitors	= dep->monitors;
+        }
+        else {
+            dep->status |= ERTS_DE_SFLG_EXITING;
+            erts_smp_mtx_lock(&dep->qlock);
+            ASSERT(!(dep->qflgs & ERTS_DE_QFLG_EXIT));
+            dep->qflgs |= ERTS_DE_QFLG_EXIT;
+            erts_smp_mtx_unlock(&dep->qlock);
+        }
+
+        erts_smp_de_links_lock(dep);
+        monitors	= dep->monitors;
         nlinks		= dep->nlinks;
-	node_links	= dep->node_links;
-	dep->monitors	= NULL;
+        node_links	= dep->node_links;
+        dep->monitors	= NULL;
         dep->nlinks	= NULL;
-	dep->node_links	= NULL;
-	erts_smp_de_links_unlock(dep);
+        dep->node_links	= NULL;
+        erts_smp_de_links_unlock(dep);
 
-	nodename = dep->sysname;
-	flags = dep->flags;
+        nodename = dep->sysname;
+        flags = dep->flags;
 
-	erts_set_dist_entry_not_connected(dep);
+        erts_set_dist_entry_not_connected(dep);
 
-	erts_smp_de_rwunlock(dep);
+        erts_smp_de_rwunlock(dep);
 
-	erts_sweep_monitors(monitors, &doit_monitor_net_exits, (void *) &nec);
-	erts_sweep_links(nlinks, &doit_link_net_exits, (void *) &nec);
-	erts_sweep_links(node_links, &doit_node_link_net_exits, (void *) &nec);
+        erts_sweep_monitors(monitors, &doit_monitor_net_exits, (void *) &nec);
+        erts_sweep_links(nlinks, &doit_link_net_exits, (void *) &nec);
+        erts_sweep_links(node_links, &doit_node_link_net_exits, (void *) &nec);
 
-	send_nodes_mon_msgs(NULL,
-			    am_nodedown,
-			    nodename,
-			    flags & DFLAG_PUBLISHED ? am_visible : am_hidden,
-			    reason == am_normal ? am_connection_closed : reason);
+        send_nodes_mon_msgs(NULL,
+                am_nodedown,
+                nodename,
+                flags & DFLAG_PUBLISHED ? am_visible : am_hidden,
+                        reason == am_normal ? am_connection_closed : reason);
 
-	clear_dist_entry(dep);
+        clear_dist_entry(dep);
 
     }
     return 1;
@@ -526,7 +526,7 @@ void init_dist(void)
 }
 
 #define ErtsDistOutputBuf2Binary(OB) \
-  ((Binary *) (((char *) (OB)) - offsetof(Binary, orig_bytes)))
+        ((Binary *) (((char *) (OB)) - offsetof(Binary, orig_bytes)))
 
 static ERTS_INLINE ErtsDistOutputBuf *
 alloc_dist_obuf(Uint size)
@@ -551,7 +551,7 @@ free_dist_obuf(ErtsDistOutputBuf *obuf)
     Binary *bin = ErtsDistOutputBuf2Binary(obuf);
     ASSERT(obuf->dbg_pattern == ERTS_DIST_OUTPUT_BUF_DBG_PATTERN);
     if (erts_refc_dectest(&bin->refc, 0) == 0)
-	erts_bin_free(bin);
+        erts_bin_free(bin);
 }
 
 static ERTS_INLINE Sint
@@ -583,10 +583,10 @@ static void clear_dist_entry(DistEntry *dep)
     erts_smp_mtx_lock(&dep->qlock);
 
     if (!dep->out_queue.last)
-	obuf = dep->finalized_out_queue.first;
+        obuf = dep->finalized_out_queue.first;
     else {
-	dep->out_queue.last->next = dep->finalized_out_queue.first;
-	obuf = dep->out_queue.first;
+        dep->out_queue.last->next = dep->finalized_out_queue.first;
+        obuf = dep->out_queue.first;
     }
 
     dep->out_queue.first = NULL;
@@ -606,18 +606,18 @@ static void clear_dist_entry(DistEntry *dep)
     delete_cache(cache);
 
     while (obuf) {
-	ErtsDistOutputBuf *fobuf;
-	fobuf = obuf;
-	obuf = obuf->next;
-	obufsize += size_obuf(fobuf);
-	free_dist_obuf(fobuf);
+        ErtsDistOutputBuf *fobuf;
+        fobuf = obuf;
+        obuf = obuf->next;
+        obufsize += size_obuf(fobuf);
+        free_dist_obuf(fobuf);
     }
 
     if (obufsize) {
-	erts_smp_mtx_lock(&dep->qlock);
-	ASSERT(dep->qsize >= obufsize);
-	dep->qsize -= obufsize;
-	erts_smp_mtx_unlock(&dep->qlock);
+        erts_smp_mtx_lock(&dep->qlock);
+        ASSERT(dep->qsize >= obufsize);
+        dep->qsize -= obufsize;
+        erts_smp_mtx_unlock(&dep->qlock);
     }
 }
 
@@ -633,8 +633,8 @@ static void clear_dist_entry(DistEntry *dep)
  */
 
 /*
-** Send a DOP_LINK link message
-*/
+ ** Send a DOP_LINK link message
+ */
 int
 erts_dsig_send_link(ErtsDSigData *dsdp, Eterm local, Eterm remote)
 {
@@ -667,7 +667,7 @@ erts_dsig_send_unlink(ErtsDSigData *dsdp, Eterm local, Eterm remote)
    which is rather sad as only the ref is needed, no pid's... */
 int
 erts_dsig_send_m_exit(ErtsDSigData *dsdp, Eterm watcher, Eterm watched, 
-			  Eterm ref, Eterm reason)
+        Eterm ref, Eterm reason)
 {
     Eterm ctl;
     DeclareTmpHeapNoproc(ctl_heap,6);
@@ -676,7 +676,7 @@ erts_dsig_send_m_exit(ErtsDSigData *dsdp, Eterm watcher, Eterm watched,
     UseTmpHeapNoproc(6);
 
     ctl = TUPLE5(&ctl_heap[0], make_small(DOP_MONITOR_P_EXIT),
-		 watched, watcher, ref, reason);
+            watched, watcher, ref, reason);
 
 #ifdef DEBUG
     erts_smp_de_links_lock(dsdp->dep);
@@ -694,7 +694,7 @@ erts_dsig_send_m_exit(ErtsDSigData *dsdp, Eterm watcher, Eterm watched,
    needed on the other side... */
 int
 erts_dsig_send_monitor(ErtsDSigData *dsdp, Eterm watcher, Eterm watched,
-		       Eterm ref)
+        Eterm ref)
 {
     Eterm ctl;
     DeclareTmpHeapNoproc(ctl_heap,5);
@@ -702,8 +702,8 @@ erts_dsig_send_monitor(ErtsDSigData *dsdp, Eterm watcher, Eterm watched,
 
     UseTmpHeapNoproc(5);
     ctl = TUPLE4(&ctl_heap[0],
-		 make_small(DOP_MONITOR_P),
-		 watcher, watched, ref);
+            make_small(DOP_MONITOR_P),
+            watcher, watched, ref);
 
     res = dsig_send(dsdp, ctl, THE_NON_VALUE, 0);
     UnUseTmpHeapNoproc(5);
@@ -716,7 +716,7 @@ erts_dsig_send_monitor(ErtsDSigData *dsdp, Eterm watcher, Eterm watched,
    rather redundant as only the ref will be needed on the other side... */
 int
 erts_dsig_send_demonitor(ErtsDSigData *dsdp, Eterm watcher,
-			 Eterm watched, Eterm ref, int force)
+        Eterm watched, Eterm ref, int force)
 {
     Eterm ctl;
     DeclareTmpHeapNoproc(ctl_heap,5);
@@ -724,8 +724,8 @@ erts_dsig_send_demonitor(ErtsDSigData *dsdp, Eterm watcher,
 
     UseTmpHeapNoproc(5);
     ctl = TUPLE4(&ctl_heap[0],
-		 make_small(DOP_DEMONITOR_P),
-		 watcher, watched, ref);
+            make_small(DOP_DEMONITOR_P),
+            watcher, watched, ref);
 
     res = dsig_send(dsdp, ctl, THE_NON_VALUE, force);
     UnUseTmpHeapNoproc(5);
@@ -743,16 +743,16 @@ erts_dsig_send_msg(ErtsDSigData *dsdp, Eterm remote, Eterm message)
 
     UseTmpHeapNoproc(5);
     if (SEQ_TRACE_TOKEN(sender) != NIL) {
-	seq_trace_update_send(sender);
-	token = SEQ_TRACE_TOKEN(sender);
-	seq_trace_output(token, message, SEQ_TRACE_SEND, remote, sender);
+        seq_trace_update_send(sender);
+        token = SEQ_TRACE_TOKEN(sender);
+        seq_trace_output(token, message, SEQ_TRACE_SEND, remote, sender);
     }
 
     if (token != NIL)
-	ctl = TUPLE4(&ctl_heap[0],
-		     make_small(DOP_SEND_TT), am_Cookie, remote, token);
+        ctl = TUPLE4(&ctl_heap[0],
+                make_small(DOP_SEND_TT), am_Cookie, remote, token);
     else
-	ctl = TUPLE3(&ctl_heap[0], make_small(DOP_SEND), am_Cookie, remote);
+        ctl = TUPLE3(&ctl_heap[0], make_small(DOP_SEND), am_Cookie, remote);
     res = dsig_send(dsdp, ctl, message, 0);
     UnUseTmpHeapNoproc(5);
     return res;
@@ -769,17 +769,17 @@ erts_dsig_send_reg_msg(ErtsDSigData *dsdp, Eterm remote_name, Eterm message)
 
     UseTmpHeapNoproc(6);
     if (SEQ_TRACE_TOKEN(sender) != NIL) {
-	seq_trace_update_send(sender);
-	token = SEQ_TRACE_TOKEN(sender);
-	seq_trace_output(token, message, SEQ_TRACE_SEND, remote_name, sender);
+        seq_trace_update_send(sender);
+        token = SEQ_TRACE_TOKEN(sender);
+        seq_trace_output(token, message, SEQ_TRACE_SEND, remote_name, sender);
     }
 
     if (token != NIL)
-	ctl = TUPLE5(&ctl_heap[0], make_small(DOP_REG_SEND_TT),
-		     sender->id, am_Cookie, remote_name, token);
+        ctl = TUPLE5(&ctl_heap[0], make_small(DOP_REG_SEND_TT),
+                sender->id, am_Cookie, remote_name, token);
     else
-	ctl = TUPLE4(&ctl_heap[0], make_small(DOP_REG_SEND),
-		     sender->id, am_Cookie, remote_name);
+        ctl = TUPLE4(&ctl_heap[0], make_small(DOP_REG_SEND),
+                sender->id, am_Cookie, remote_name);
     res = dsig_send(dsdp, ctl, message, 0);
     UnUseTmpHeapNoproc(6);
     return res;
@@ -788,7 +788,7 @@ erts_dsig_send_reg_msg(ErtsDSigData *dsdp, Eterm remote_name, Eterm message)
 /* local has died, deliver the exit signal to remote */
 int
 erts_dsig_send_exit_tt(ErtsDSigData *dsdp, Eterm local, Eterm remote, 
-		       Eterm reason, Eterm token)
+        Eterm reason, Eterm token)
 {
     Eterm ctl;
     DeclareTmpHeapNoproc(ctl_heap,6);
@@ -796,12 +796,12 @@ erts_dsig_send_exit_tt(ErtsDSigData *dsdp, Eterm local, Eterm remote,
 
     UseTmpHeapNoproc(6);
     if (token != NIL) {	
-	seq_trace_update_send(dsdp->proc);
-	seq_trace_output_exit(token, reason, SEQ_TRACE_SEND, remote, local);
-	ctl = TUPLE5(&ctl_heap[0],
-		     make_small(DOP_EXIT_TT), local, remote, token, reason);
+        seq_trace_update_send(dsdp->proc);
+        seq_trace_output_exit(token, reason, SEQ_TRACE_SEND, remote, local);
+        ctl = TUPLE5(&ctl_heap[0],
+                make_small(DOP_EXIT_TT), local, remote, token, reason);
     } else {
-	ctl = TUPLE4(&ctl_heap[0], make_small(DOP_EXIT), local, remote, reason);
+        ctl = TUPLE4(&ctl_heap[0], make_small(DOP_EXIT), local, remote, reason);
     }
     /* forced, i.e ignore busy */
     res = dsig_send(dsdp, ctl, THE_NON_VALUE, 1);
@@ -818,7 +818,7 @@ erts_dsig_send_exit(ErtsDSigData *dsdp, Eterm local, Eterm remote, Eterm reason)
 
     UseTmpHeapNoproc(5);
     ctl = TUPLE4(&ctl_heap[0],
-		 make_small(DOP_EXIT), local, remote, reason);
+            make_small(DOP_EXIT), local, remote, reason);
     /* forced, i.e ignore busy */
     res =  dsig_send(dsdp, ctl, THE_NON_VALUE, 1);
     UnUseTmpHeapNoproc(5);
@@ -834,7 +834,7 @@ erts_dsig_send_exit2(ErtsDSigData *dsdp, Eterm local, Eterm remote, Eterm reason
 
     UseTmpHeapNoproc(5);
     ctl = TUPLE4(&ctl_heap[0],
-		 make_small(DOP_EXIT2), local, remote, reason);
+            make_small(DOP_EXIT2), local, remote, reason);
 
     res = dsig_send(dsdp, ctl, THE_NON_VALUE, 0);
     UnUseTmpHeapNoproc(5);
@@ -851,7 +851,7 @@ erts_dsig_send_group_leader(ErtsDSigData *dsdp, Eterm leader, Eterm remote)
 
     UseTmpHeapNoproc(4);
     ctl = TUPLE3(&ctl_heap[0],
-		 make_small(DOP_GROUP_LEADER), leader, remote);
+            make_small(DOP_GROUP_LEADER), leader, remote);
 
     res = dsig_send(dsdp, ctl, THE_NON_VALUE, 0);
     UnUseTmpHeapNoproc(4);
@@ -860,7 +860,7 @@ erts_dsig_send_group_leader(ErtsDSigData *dsdp, Eterm leader, Eterm remote)
 
 #if defined(PURIFY)
 #  define PURIFY_MSG(msg) \
-    purify_printf("%s, line %d: %s", __FILE__, __LINE__, msg)
+        purify_printf("%s, line %d: %s", __FILE__, __LINE__, msg)
 #elif defined(VALGRIND)
 #include <valgrind/valgrind.h>
 #include <valgrind/memcheck.h>
@@ -870,36 +870,36 @@ erts_dsig_send_group_leader(ErtsDSigData *dsdp, Eterm leader, Eterm remote)
 #endif
 
 #  define PURIFY_MSG(msg)                                                \
-    do {								 \
-	char buf__[1]; size_t bufsz__ = sizeof(buf__);			 \
-	if (erts_sys_getenv("VALGRIND_LOG_XML", buf__, &bufsz__) >= 0) { \
-	    VALGRIND_PRINTF_XML("<erlang_error_log>"			 \
-			    "%s, line %d: %s</erlang_error_log>\n",	 \
-			    __FILE__, __LINE__, msg);			 \
-	} else {							 \
-	    VALGRIND_PRINTF("%s, line %d: %s", __FILE__, __LINE__, msg); \
-	}								 \
-    } while (0)
+        do {								 \
+            char buf__[1]; size_t bufsz__ = sizeof(buf__);			 \
+            if (erts_sys_getenv("VALGRIND_LOG_XML", buf__, &bufsz__) >= 0) { \
+                VALGRIND_PRINTF_XML("<erlang_error_log>"			 \
+                        "%s, line %d: %s</erlang_error_log>\n",	 \
+                        __FILE__, __LINE__, msg);			 \
+            } else {							 \
+                VALGRIND_PRINTF("%s, line %d: %s", __FILE__, __LINE__, msg); \
+            }								 \
+        } while (0)
 #else
 #  define PURIFY_MSG(msg)
 #endif
 
 /*
-** Input from distribution port.
-**  Input follows the distribution protocol v4.5
-**  
-**   The protocol is a 4 byte header protocol
-**   the DOP_DATA is stripped by driver_output
-**
-**   assert  hlen == 0 !!!
-*/
+ ** Input from distribution port.
+ **  Input follows the distribution protocol v4.5
+ **  
+ **   The protocol is a 4 byte header protocol
+ **   the DOP_DATA is stripped by driver_output
+ **
+ **   assert  hlen == 0 !!!
+ */
 
 int erts_net_message(Port *prt,
-		     DistEntry *dep,
-		     byte *hbuf,
-		     ErlDrvSizeT hlen,
-		     byte *buf,
-		     ErlDrvSizeT len)
+        DistEntry *dep,
+        byte *hbuf,
+        ErlDrvSizeT hlen,
+        byte *buf,
+        ErlDrvSizeT len)
 {
 #define DIST_CTL_DEFAULT_SIZE 64
     ErtsDistExternal ede;
@@ -937,14 +937,14 @@ int erts_net_message(Port *prt,
     ERTS_SMP_LC_ASSERT(erts_lc_is_port_locked(prt));
 
     if (!erts_is_alive) {
-	UnUseTmpHeapNoproc(DIST_CTL_DEFAULT_SIZE);
-	return 0;
+        UnUseTmpHeapNoproc(DIST_CTL_DEFAULT_SIZE);
+        return 0;
     }
     if (hlen != 0)
-	goto data_error;
+        goto data_error;
     if (len == 0) {  /* HANDLE TICK !!! */
-	UnUseTmpHeapNoproc(DIST_CTL_DEFAULT_SIZE);
-	return 0;
+        UnUseTmpHeapNoproc(DIST_CTL_DEFAULT_SIZE);
+        return 0;
     }
 
 #ifdef ERTS_RAW_DIST_MSG_DBG
@@ -953,52 +953,52 @@ int erts_net_message(Port *prt,
 #endif
 
     if (dep->flags & DFLAG_DIST_HDR_ATOM_CACHE)
-	t = buf;
+        t = buf;
     else {
-	/* Skip PASS_THROUGH */
-	t = buf+1;
-	len--;
+        /* Skip PASS_THROUGH */
+        t = buf+1;
+        len--;
     }
 
     if (len == 0) {
-	PURIFY_MSG("data error");
-	goto data_error;
+        PURIFY_MSG("data error");
+        goto data_error;
     }
 
     res = erts_prepare_dist_ext(&ede, t, len, dep, dep->cache);
 
     if (res >= 0)
-	res = ctl_len = erts_decode_dist_ext_size(&ede);
+        res = ctl_len = erts_decode_dist_ext_size(&ede);
     else {
 #ifdef ERTS_DIST_MSG_DBG
-	erts_fprintf(stderr, "DIST MSG DEBUG: erts_prepare_dist_ext() failed:\n");
-	bw(buf, orig_len);
+        erts_fprintf(stderr, "DIST MSG DEBUG: erts_prepare_dist_ext() failed:\n");
+        bw(buf, orig_len);
 #endif
-	ctl_len = 0;
+        ctl_len = 0;
     }
 
     if (res < 0) {
 #ifdef ERTS_DIST_MSG_DBG
-	erts_fprintf(stderr, "DIST MSG DEBUG: erts_decode_dist_ext_size(CTL) failed:\n");
-	bw(buf, orig_len);
+        erts_fprintf(stderr, "DIST MSG DEBUG: erts_decode_dist_ext_size(CTL) failed:\n");
+        bw(buf, orig_len);
 #endif
-	PURIFY_MSG("data error");
-	goto data_error;
+        PURIFY_MSG("data error");
+        goto data_error;
     }
 
     if (ctl_len > DIST_CTL_DEFAULT_SIZE) {
-	ctl = erts_alloc(ERTS_ALC_T_DCTRL_BUF, ctl_len * sizeof(Eterm));
+        ctl = erts_alloc(ERTS_ALC_T_DCTRL_BUF, ctl_len * sizeof(Eterm));
     }
     hp = ctl;
 
     arg = erts_decode_dist_ext(&hp, &off_heap, &ede);
     if (is_non_value(arg)) {
 #ifdef ERTS_DIST_MSG_DBG
-	erts_fprintf(stderr, "DIST MSG DEBUG: erts_dist_ext_size(CTL) failed:\n");
-	bw(buf, orig_len);
+        erts_fprintf(stderr, "DIST MSG DEBUG: erts_dist_ext_size(CTL) failed:\n");
+        bw(buf, orig_len);
 #endif
-	PURIFY_MSG("data error");
-	goto data_error;
+        PURIFY_MSG("data error");
+        goto data_error;
     }
     ctl_len = t - buf;
 
@@ -1007,502 +1007,504 @@ int erts_net_message(Port *prt,
 #endif
 
     if (is_not_tuple(arg) || 
-	(tuple = tuple_val(arg), (tuple_arity = arityval(*tuple)) < 1) ||
-	is_not_small(tuple[1])) {
- 	goto invalid_message;
+            (tuple = tuple_val(arg), (tuple_arity = arityval(*tuple)) < 1) ||
+            is_not_small(tuple[1])) {
+        goto invalid_message;
     }
 
     token_size = 0;
 
     switch (type = unsigned_val(tuple[1])) {
-    case DOP_LINK:
-	if (tuple_arity != 3) {
-	    goto invalid_message;
-	}
-	from = tuple[2];
-	to   = tuple[3];  /* local proc to link to */
-
-	if (is_not_pid(from) || is_not_pid(to)) {
-	    goto invalid_message;
-	}
-
-	rp = erts_pid2proc_opt(NULL, 0,
-			       to, ERTS_PROC_LOCK_LINK,
-			       ERTS_P2P_FLG_ALLOW_OTHER_X);
-	if (!rp) {
-	    /* This is tricky (we MUST force a distributed send) */
-	    ErtsDSigData dsd;
-	    int code;
-	    code = erts_dsig_prepare(&dsd, dep, NULL, ERTS_DSP_NO_LOCK, 0);
-	    if (code == ERTS_DSIG_PREP_CONNECTED) {
-		code = erts_dsig_send_exit(&dsd, to, from, am_noproc);
-		ASSERT(code == ERTS_DSIG_SEND_OK);
-	    }
-	    break;
-	}
-
-	erts_smp_de_links_lock(dep);
-	res = erts_add_link(&(rp->nlinks), LINK_PID, from);
-
-	if (res < 0) {
-	    /* It was already there! Lets skip the rest... */
-	    erts_smp_de_links_unlock(dep);
-	    erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_LINK);
-	    break;
-	}
-	lnk = erts_add_or_lookup_link(&(dep->nlinks), LINK_PID, rp->id);
-	erts_add_link(&(ERTS_LINK_ROOT(lnk)), LINK_PID, from);
-	erts_smp_de_links_unlock(dep);
-
-	if (IS_TRACED_FL(rp, F_TRACE_PROCS))
-	    trace_proc(NULL, rp, am_getting_linked, from);
-
-	erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_LINK);
-	break;
-
-    case DOP_UNLINK: {
-	ErtsDistLinkData dld;
-	if (tuple_arity != 3) {
-	    goto invalid_message;
-	}
-	from = tuple[2];
-	to = tuple[3];
-	if (is_not_pid(from) || is_not_pid(to)) {
-	    goto invalid_message;
-	}
-	
-	rp = erts_pid2proc_opt(NULL, 0,
-			       to, ERTS_PROC_LOCK_LINK,
-			       ERTS_P2P_FLG_ALLOW_OTHER_X);
-	if (!rp)
-	    break;
-
-	lnk = erts_remove_link(&(rp->nlinks), from);
-
-	if (IS_TRACED_FL(rp, F_TRACE_PROCS) && lnk != NULL) {
-	    trace_proc(NULL, rp, am_getting_unlinked, from);
-	}
-
-	erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_LINK);
-
-	erts_remove_dist_link(&dld, to, from, dep);
-	erts_destroy_dist_link(&dld);
-	if (lnk)
-	    erts_destroy_link(lnk);
-	break;
-    }
-    
-    case DOP_MONITOR_P: {
-	/* A remote process wants to monitor us, we get:
+        case DOP_LINK:
+            if (tuple_arity != 3) {
+                goto invalid_message;
+            }
+            from = tuple[2];
+            to   = tuple[3];  /* local proc to link to */
+
+            if (is_not_pid(from) || is_not_pid(to)) {
+                goto invalid_message;
+            }
+
+            rp = erts_pid2proc_opt(NULL, 0,
+                    to, ERTS_PROC_LOCK_LINK,
+                    ERTS_P2P_FLG_ALLOW_OTHER_X);
+            if (!rp) {
+                /* This is tricky (we MUST force a distributed send) */
+                ErtsDSigData dsd;
+                int code;
+                code = erts_dsig_prepare(&dsd, dep, NULL, ERTS_DSP_NO_LOCK, 0);
+                if (code == ERTS_DSIG_PREP_CONNECTED) {
+                    code = erts_dsig_send_exit(&dsd, to, from, am_noproc);
+                    ASSERT(code == ERTS_DSIG_SEND_OK);
+                }
+                break;
+            }
+
+            erts_smp_de_links_lock(dep);
+            res = erts_add_link(&(rp->nlinks), LINK_PID, from);
+
+            if (res < 0) {
+                /* It was already there! Lets skip the rest... */
+                erts_smp_de_links_unlock(dep);
+                erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_LINK);
+                break;
+            }
+            lnk = erts_add_or_lookup_link(&(dep->nlinks), LINK_PID, rp->id);
+            erts_add_link(&(ERTS_LINK_ROOT(lnk)), LINK_PID, from);
+            erts_smp_de_links_unlock(dep);
+
+            if (IS_TRACED_FL(rp, F_TRACE_PROCS))
+                trace_proc(NULL, rp, am_getting_linked, from);
+
+            erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_LINK);
+            break;
+
+        case DOP_UNLINK: {
+            ErtsDistLinkData dld;
+            if (tuple_arity != 3) {
+                goto invalid_message;
+            }
+            from = tuple[2];
+            to = tuple[3];
+            if (is_not_pid(from) || is_not_pid(to)) {
+                goto invalid_message;
+            }
+
+            rp = erts_pid2proc_opt(NULL, 0,
+                    to, ERTS_PROC_LOCK_LINK,
+                    ERTS_P2P_FLG_ALLOW_OTHER_X);
+            if (!rp)
+                break;
+
+            lnk = erts_remove_link(&(rp->nlinks), from);
+
+            if (IS_TRACED_FL(rp, F_TRACE_PROCS) && lnk != NULL) {
+                trace_proc(NULL, rp, am_getting_unlinked, from);
+            }
+
+            erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_LINK);
+
+            erts_remove_dist_link(&dld, to, from, dep);
+            erts_destroy_dist_link(&dld);
+            if (lnk)
+                erts_destroy_link(lnk);
+            break;
+        }
+
+        case DOP_MONITOR_P: {
+            /* A remote process wants to monitor us, we get:
 	   {DOP_MONITOR_P, Remote pid, local pid or name, ref} */
-	Eterm name;
-	
-	if (tuple_arity != 4) {
-	    goto invalid_message;
-	}
-
-	watcher = tuple[2];
-	watched = tuple[3];  /* local proc to monitor */
-	ref     = tuple[4];
-
-	if (is_not_ref(ref)) {
-	    goto invalid_message;
-	}
-
-	if (is_atom(watched)) {
-	    name = watched;
-	    rp = erts_whereis_process(NULL, 0,
-				      watched, ERTS_PROC_LOCK_LINK,
-				      ERTS_P2P_FLG_ALLOW_OTHER_X);
-	}
-	else {
-	    name = NIL;
-	    rp = erts_pid2proc_opt(NULL, 0,
-				   watched, ERTS_PROC_LOCK_LINK,
-				   ERTS_P2P_FLG_ALLOW_OTHER_X);
-	}
-
-	if (!rp) {
-	    ErtsDSigData dsd;
-	    int code;
-	    code = erts_dsig_prepare(&dsd, dep, NULL, ERTS_DSP_NO_LOCK, 0);
-	    if (code == ERTS_DSIG_PREP_CONNECTED) {
-		code = erts_dsig_send_m_exit(&dsd, watcher, watched, ref,
-					     am_noproc);
-		ASSERT(code == ERTS_DSIG_SEND_OK);
-	    }
-	}
-	else {
-	    if (is_atom(watched))
-		watched = rp->id;
-	    erts_smp_de_links_lock(dep);
-	    erts_add_monitor(&(dep->monitors), MON_ORIGIN, ref, watched, name);
-	    erts_add_monitor(&(rp->monitors), MON_TARGET, ref, watcher, name);
-	    erts_smp_de_links_unlock(dep);
-	    erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_LINK);
-	}
-
-	break;
-    }
-
-    case DOP_DEMONITOR_P:
-	/* A remote node informs us that a local pid in no longer monitored
+            Eterm name;
+
+            if (tuple_arity != 4) {
+                goto invalid_message;
+            }
+
+            watcher = tuple[2];
+            watched = tuple[3];  /* local proc to monitor */
+            ref     = tuple[4];
+
+            if (is_not_ref(ref)) {
+                goto invalid_message;
+            }
+
+            if (is_atom(watched)) {
+                name = watched;
+                rp = erts_whereis_process(NULL, 0,
+                        watched, ERTS_PROC_LOCK_LINK,
+                        ERTS_P2P_FLG_ALLOW_OTHER_X);
+            }
+            else {
+                name = NIL;
+                rp = erts_pid2proc_opt(NULL, 0,
+                        watched, ERTS_PROC_LOCK_LINK,
+                        ERTS_P2P_FLG_ALLOW_OTHER_X);
+            }
+
+            if (!rp) {
+                ErtsDSigData dsd;
+                int code;
+                code = erts_dsig_prepare(&dsd, dep, NULL, ERTS_DSP_NO_LOCK, 0);
+                if (code == ERTS_DSIG_PREP_CONNECTED) {
+                    code = erts_dsig_send_m_exit(&dsd, watcher, watched, ref,
+                            am_noproc);
+                    ASSERT(code == ERTS_DSIG_SEND_OK);
+                }
+            }
+            else {
+                if (is_atom(watched))
+                    watched = rp->id;
+                erts_smp_de_links_lock(dep);
+                erts_add_monitor(&(dep->monitors), MON_ORIGIN, ref, watched, name);
+                erts_add_monitor(&(rp->monitors), MON_TARGET, ref, watcher, name);
+                erts_smp_de_links_unlock(dep);
+                erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_LINK);
+            }
+
+            break;
+        }
+
+        case DOP_DEMONITOR_P:
+            /* A remote node informs us that a local pid in no longer monitored
 	   We get {DOP_DEMONITOR_P, Remote pid, Local pid or name, ref},
 	   We need only the ref of course */
 
-	if (tuple_arity != 4) {
-	    goto invalid_message;
-	}
-	/* watcher = tuple[2]; */
-	/* watched = tuple[3]; May be an atom in case of monitor name */
-	ref = tuple[4];
-
-	if(is_not_ref(ref)) {
-	    goto invalid_message;
-	}
-
-	erts_smp_de_links_lock(dep);
-	mon = erts_remove_monitor(&(dep->monitors),ref);
-	erts_smp_de_links_unlock(dep);
-	/* ASSERT(mon != NULL); can happen in case of broken dist message */
-	if (mon == NULL) {
-	    break;
-	}
-	watched = mon->pid;
-	erts_destroy_monitor(mon);
-	rp = erts_pid2proc_opt(NULL, 0,
-			       watched, ERTS_PROC_LOCK_LINK,
-			       ERTS_P2P_FLG_ALLOW_OTHER_X);
-	if (!rp) {
-	    break;
-	}
-	mon = erts_remove_monitor(&(rp->monitors),ref);
-	erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_LINK);
-	ASSERT(mon != NULL);
-	if (mon == NULL) {
-	    break;
-	}
-	erts_destroy_monitor(mon);
-	break;
-
-    case DOP_REG_SEND_TT:
-	if (tuple_arity != 5) {
-	    goto invalid_message;
-	}
-
-	token_size = size_object(tuple[5]);
-	/* Fall through ... */
-    case DOP_REG_SEND:
-	/* {DOP_REG_SEND, From, Cookie, ToName} -- Message */
-	/* {DOP_REG_SEND_TT, From, Cookie, ToName, TraceToken} -- Message */
-
-	/*
-	 * There is intentionally no testing of the cookie (it is always '')
-	 * from R9B and onwards.
-	 */
-	if (type != DOP_REG_SEND_TT && tuple_arity != 4) {
-	    goto invalid_message;
-	}
+            if (tuple_arity != 4) {
+                goto invalid_message;
+            }
+            /* watcher = tuple[2]; */
+            /* watched = tuple[3]; May be an atom in case of monitor name */
+            ref = tuple[4];
+
+            if(is_not_ref(ref)) {
+                goto invalid_message;
+            }
+
+            erts_smp_de_links_lock(dep);
+            mon = erts_remove_monitor(&(dep->monitors),ref);
+            erts_smp_de_links_unlock(dep);
+            /* ASSERT(mon != NULL); can happen in case of broken dist message */
+            if (mon == NULL) {
+                break;
+            }
+            watched = mon->pid;
+            erts_destroy_monitor(mon);
+            rp = erts_pid2proc_opt(NULL, 0,
+                    watched, ERTS_PROC_LOCK_LINK,
+                    ERTS_P2P_FLG_ALLOW_OTHER_X);
+            if (!rp) {
+                break;
+            }
+            mon = erts_remove_monitor(&(rp->monitors),ref);
+            erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_LINK);
+            ASSERT(mon != NULL);
+            if (mon == NULL) {
+                break;
+            }
+            erts_destroy_monitor(mon);
+            break;
+
+        case DOP_REG_SEND_TT:
+            if (tuple_arity != 5) {
+                goto invalid_message;
+            }
+
+            token_size = size_object(tuple[5]);
+            /* Fall through ... */
+        case DOP_REG_SEND:
+            /* {DOP_REG_SEND, From, Cookie, ToName} -- Message */
+            /* {DOP_REG_SEND_TT, From, Cookie, ToName, TraceToken} -- Message */
+
+            /*
+             * There is intentionally no testing of the cookie (it is always '')
+             * from R9B and onwards.
+             */
+            if (type != DOP_REG_SEND_TT && tuple_arity != 4) {
+                goto invalid_message;
+            }
 
 #ifdef ERTS_DIST_MSG_DBG
-	dist_msg_dbg(&ede, "MSG", buf, orig_len);
+            dist_msg_dbg(&ede, "MSG", buf, orig_len);
 #endif
 
-	from = tuple[2];
-	to = tuple[4];
-	if (is_not_pid(from) || is_not_atom(to)){
-	    goto invalid_message;
-	}
-	rp = erts_whereis_process(NULL, 0, to, 0, ERTS_P2P_FLG_SMP_INC_REFC);
-	if (rp) {
-	    Uint xsize = (type == DOP_REG_SEND
-			  ? 0
-			  : ERTS_HEAP_FRAG_SIZE(token_size));
-	    ErtsProcLocks locks = 0;
-	    ErtsDistExternal *ede_copy;
-
-	    ede_copy = erts_make_dist_ext_copy(&ede, xsize);
-	    if (type == DOP_REG_SEND) {
-		token = NIL;
-	    } else {
-		ErlHeapFragment *heap_frag;
-		ErlOffHeap *ohp;
-		ASSERT(xsize);
-		heap_frag = erts_dist_ext_trailer(ede_copy);
-		ERTS_INIT_HEAP_FRAG(heap_frag, token_size);
-		hp = heap_frag->mem;
-		ohp = &heap_frag->off_heap;
-		token = tuple[5];
-		token = copy_struct(token, token_size, &hp, ohp);
-	    }
-
-	    erts_queue_dist_message(rp, &locks, ede_copy, token);
-	    if (locks)
-		erts_smp_proc_unlock(rp, locks);
-	    erts_smp_proc_dec_refc(rp);
-	}
-	break;
-
-    case DOP_SEND_TT:
-	if (tuple_arity != 4) {
-	    goto invalid_message;
-	}
-	
-	token_size = size_object(tuple[4]);
-	/* Fall through ... */
-    case DOP_SEND:
-	/*
-	 * There is intentionally no testing of the cookie (it is always '')
-	 * from R9B and onwards.
-	 */
+            from = tuple[2];
+            to = tuple[4];
+            if (is_not_pid(from) || is_not_atom(to)){
+                goto invalid_message;
+            }
+            erts_printf("DEBUG: Message received from %T, to %T\n", from, to);
+            rp = erts_whereis_process(NULL, 0, to, 0, ERTS_P2P_FLG_SMP_INC_REFC);
+            if (rp) {
+                Uint xsize = (type == DOP_REG_SEND
+                        ? 0
+                                : ERTS_HEAP_FRAG_SIZE(token_size));
+                ErtsProcLocks locks = 0;
+                ErtsDistExternal *ede_copy;
+
+                ede_copy = erts_make_dist_ext_copy(&ede, xsize);
+                if (type == DOP_REG_SEND) {
+                    token = NIL;
+                } else {
+                    ErlHeapFragment *heap_frag;
+                    ErlOffHeap *ohp;
+                    ASSERT(xsize);
+                    heap_frag = erts_dist_ext_trailer(ede_copy);
+                    ERTS_INIT_HEAP_FRAG(heap_frag, token_size);
+                    hp = heap_frag->mem;
+                    ohp = &heap_frag->off_heap;
+                    token = tuple[5];
+                    token = copy_struct(token, token_size, &hp, ohp);
+                }
+
+                erts_queue_dist_message(rp, &locks, ede_copy, token);
+                if (locks)
+                    erts_smp_proc_unlock(rp, locks);
+                erts_smp_proc_dec_refc(rp);
+            }
+            break;
+
+        case DOP_SEND_TT:
+            if (tuple_arity != 4) {
+                goto invalid_message;
+            }
+
+            token_size = size_object(tuple[4]);
+            /* Fall through ... */
+        case DOP_SEND:
+            /*
+             * There is intentionally no testing of the cookie (it is always '')
+             * from R9B and onwards.
+             */
 #ifdef ERTS_DIST_MSG_DBG
-	dist_msg_dbg(&ede, "MSG", buf, orig_len);
+            dist_msg_dbg(&ede, "MSG", buf, orig_len);
 #endif
-	if (type != DOP_SEND_TT && tuple_arity != 3) {
-	    goto invalid_message;
-	}
-	to = tuple[3];
-	if (is_not_pid(to)) {
-	    goto invalid_message;
-	}
-	rp = erts_pid2proc_opt(NULL, 0, to, 0, ERTS_P2P_FLG_SMP_INC_REFC);
-	if (rp) {
-	    Uint xsize = type == DOP_SEND ? 0 : ERTS_HEAP_FRAG_SIZE(token_size);
-	    ErtsProcLocks locks = 0;
-	    ErtsDistExternal *ede_copy;
-
-	    ede_copy = erts_make_dist_ext_copy(&ede, xsize);
-	    if (type == DOP_SEND) {
-		token = NIL;
-	    } else {
-		ErlHeapFragment *heap_frag;
-		ErlOffHeap *ohp;
-		ASSERT(xsize);
-		heap_frag = erts_dist_ext_trailer(ede_copy);
-		ERTS_INIT_HEAP_FRAG(heap_frag, token_size);
-		hp = heap_frag->mem;
-		ohp = &heap_frag->off_heap;
-		token = tuple[4];
-		token = copy_struct(token, token_size, &hp, ohp);
-	    }
-
-	    erts_queue_dist_message(rp, &locks, ede_copy, token);
-	    if (locks)
-		erts_smp_proc_unlock(rp, locks);
-	    erts_smp_proc_dec_refc(rp);
-	}
-	break;
-
-    case DOP_MONITOR_P_EXIT: {
-	/* We are monitoring a process on the remote node which dies, we get
+            if (type != DOP_SEND_TT && tuple_arity != 3) {
+                goto invalid_message;
+            }
+            to = tuple[3];
+            if (is_not_pid(to)) {
+                goto invalid_message;
+            }
+            erts_printf("DEBUG: Message received for %T\n", to);
+            rp = erts_pid2proc_opt(NULL, 0, to, 0, ERTS_P2P_FLG_SMP_INC_REFC);
+            if (rp) {
+                Uint xsize = type == DOP_SEND ? 0 : ERTS_HEAP_FRAG_SIZE(token_size);
+                ErtsProcLocks locks = 0;
+                ErtsDistExternal *ede_copy;
+
+                ede_copy = erts_make_dist_ext_copy(&ede, xsize);
+                if (type == DOP_SEND) {
+                    token = NIL;
+                } else {
+                    ErlHeapFragment *heap_frag;
+                    ErlOffHeap *ohp;
+                    ASSERT(xsize);
+                    heap_frag = erts_dist_ext_trailer(ede_copy);
+                    ERTS_INIT_HEAP_FRAG(heap_frag, token_size);
+                    hp = heap_frag->mem;
+                    ohp = &heap_frag->off_heap;
+                    token = tuple[4];
+                    token = copy_struct(token, token_size, &hp, ohp);
+                }
+
+                erts_queue_dist_message(rp, &locks, ede_copy, token);
+                if (locks)
+                    erts_smp_proc_unlock(rp, locks);
+                erts_smp_proc_dec_refc(rp);
+            }
+            break;
+
+        case DOP_MONITOR_P_EXIT: {
+            /* We are monitoring a process on the remote node which dies, we get
 	   {DOP_MONITOR_P_EXIT, Remote pid or name, Local pid, ref, reason} */
-	   
-
-	DeclareTmpHeapNoproc(lhp,3);
-	Eterm sysname;
-	ErtsProcLocks rp_locks = ERTS_PROC_LOCKS_MSG_SEND|ERTS_PROC_LOCK_LINK;
-
-	if (tuple_arity != 5) {
-	    goto invalid_message;
-	}
-
-	/* watched = tuple[2]; */  /* remote proc which died */
-	/* watcher = tuple[3]; */
-	ref     = tuple[4];
-	reason  = tuple[5];
-
-	if(is_not_ref(ref)) {
-	    goto invalid_message;
-	}
-
-	erts_smp_de_links_lock(dep);
-	sysname = dep->sysname;
-	mon = erts_remove_monitor(&(dep->monitors), ref);
-	/*
-	 * If demonitor was performed at the same time as the
-	 * monitored process exits, monitoring side will have
-	 * removed info about monitor. In this case, do nothing
-	 * and everything will be as it should.
-	 */
-	erts_smp_de_links_unlock(dep);
-	if (mon == NULL) {
-	    break;
-	}
-	rp = erts_pid2proc(NULL, 0, mon->pid, rp_locks);
-	if (rp == NULL) {
-	    break;
-	}
-
-	erts_destroy_monitor(mon);
-
-	mon = erts_remove_monitor(&(rp->monitors),ref);
-
-	if (mon == NULL) {
-	    erts_smp_proc_unlock(rp, rp_locks);
-	    break;
-	}
-	UseTmpHeapNoproc(3);
-	
-	watched = (is_not_nil(mon->name)
-		   ? TUPLE2(&lhp[0], mon->name, sysname)
-		   : mon->pid);
-	
-	erts_queue_monitor_message(rp, &rp_locks,
-				   ref, am_process, watched, reason);
-	erts_smp_proc_unlock(rp, rp_locks);
-	erts_destroy_monitor(mon);
-	UnUseTmpHeapNoproc(3);
-	break;
-    }
-
-    case DOP_EXIT_TT:
-    case DOP_EXIT: {
-	ErtsDistLinkData dld;
-	ErtsProcLocks rp_locks = ERTS_PROC_LOCK_LINK|ERTS_PROC_LOCKS_XSIG_SEND;
-	/* 'from', which 'to' is linked to, died */
-	if (type == DOP_EXIT) {
-	    if (tuple_arity != 4) {
-		goto invalid_message;
-	    }
-	    
-	    from = tuple[2];
-	    to = tuple[3];
-	    reason = tuple[4];
-	    token = NIL;
-	} else {
-	    if (tuple_arity != 5) {
-		goto invalid_message;
-	    }
-	    from = tuple[2];
-	    to = tuple[3];
-	    token = tuple[4];
-	    reason = tuple[5];
-	}
-	if (is_not_pid(from) || is_not_internal_pid(to)) {
-	    goto invalid_message;
-	}
-
-	rp = erts_pid2proc(NULL, 0, to, rp_locks);
-	if (!rp)
-	    lnk = NULL;
-	else {
-	    lnk = erts_remove_link(&(rp->nlinks), from);
-
-	    /* If lnk == NULL, we have unlinked on this side, i.e.
-	     * ignore exit.
-	     */
-	    if (lnk) {
-		int xres;
+
+
+            DeclareTmpHeapNoproc(lhp,3);
+            Eterm sysname;
+            ErtsProcLocks rp_locks = ERTS_PROC_LOCKS_MSG_SEND|ERTS_PROC_LOCK_LINK;
+
+            if (tuple_arity != 5) {
+                goto invalid_message;
+            }
+
+            /* watched = tuple[2]; */  /* remote proc which died */
+            /* watcher = tuple[3]; */
+            ref     = tuple[4];
+            reason  = tuple[5];
+
+            if(is_not_ref(ref)) {
+                goto invalid_message;
+            }
+
+            erts_smp_de_links_lock(dep);
+            sysname = dep->sysname;
+            mon = erts_remove_monitor(&(dep->monitors), ref);
+            /*
+             * If demonitor was performed at the same time as the
+             * monitored process exits, monitoring side will have
+             * removed info about monitor. In this case, do nothing
+             * and everything will be as it should.
+             */
+            erts_smp_de_links_unlock(dep);
+            if (mon == NULL) {
+                break;
+            }
+            rp = erts_pid2proc(NULL, 0, mon->pid, rp_locks);
+            if (rp == NULL) {
+                break;
+            }
+
+            erts_destroy_monitor(mon);
+
+            mon = erts_remove_monitor(&(rp->monitors),ref);
+
+            if (mon == NULL) {
+                erts_smp_proc_unlock(rp, rp_locks);
+                break;
+            }
+            UseTmpHeapNoproc(3);
+
+            watched = (is_not_nil(mon->name)
+                    ? TUPLE2(&lhp[0], mon->name, sysname)
+                            : mon->pid);
+
+            erts_queue_monitor_message(rp, &rp_locks,
+                    ref, am_process, watched, reason);
+            erts_smp_proc_unlock(rp, rp_locks);
+            erts_destroy_monitor(mon);
+            UnUseTmpHeapNoproc(3);
+            break;
+        }
+
+        case DOP_EXIT_TT:
+        case DOP_EXIT: {
+            ErtsDistLinkData dld;
+            ErtsProcLocks rp_locks = ERTS_PROC_LOCK_LINK|ERTS_PROC_LOCKS_XSIG_SEND;
+            /* 'from', which 'to' is linked to, died */
+            if (type == DOP_EXIT) {
+                if (tuple_arity != 4) {
+                    goto invalid_message;
+                }
+
+                from = tuple[2];
+                to = tuple[3];
+                reason = tuple[4];
+                token = NIL;
+            } else {
+                if (tuple_arity != 5) {
+                    goto invalid_message;
+                }
+                from = tuple[2];
+                to = tuple[3];
+                token = tuple[4];
+                reason = tuple[5];
+            }
+            if (is_not_pid(from) || is_not_internal_pid(to)) {
+                goto invalid_message;
+            }
+
+            rp = erts_pid2proc(NULL, 0, to, rp_locks);
+            if (!rp)
+                lnk = NULL;
+            else {
+                lnk = erts_remove_link(&(rp->nlinks), from);
+
+                /* If lnk == NULL, we have unlinked on this side, i.e.
+                 * ignore exit.
+                 */
+                if (lnk) {
+                    int xres;
 #if 0
-		/* Arndt: Maybe it should never be 'kill', but it can be,
+                    /* Arndt: Maybe it should never be 'kill', but it can be,
 		   namely when a linked process does exit(kill). Until we know
 		   whether that is incorrect and what should happen instead,
 		   we leave the assertion out. */
-		ASSERT(reason != am_kill); /* should never be kill (killed) */
+                    ASSERT(reason != am_kill); /* should never be kill (killed) */
 #endif
-		xres = erts_send_exit_signal(NULL,
-					     from,
-					     rp,
-					     &rp_locks, 
-					     reason,
-					     token,
-					     NULL,
-					     ERTS_XSIG_FLG_IGN_KILL);
-		if (xres >= 0 && IS_TRACED_FL(rp, F_TRACE_PROCS)) {
-		    /* We didn't exit the process and it is traced */
-		    trace_proc(NULL, rp, am_getting_unlinked, from);
-		}
-	    }
-	    erts_smp_proc_unlock(rp, rp_locks);
-	}
-	erts_remove_dist_link(&dld, to, from, dep);
-	if (lnk)
-	    erts_destroy_link(lnk);
-	erts_destroy_dist_link(&dld);
-	break;
-    }
-    case DOP_EXIT2_TT:
-    case DOP_EXIT2: {
-	ErtsProcLocks rp_locks = ERTS_PROC_LOCKS_XSIG_SEND;
-	/* 'from' is send an exit signal to 'to' */
-	if (type == DOP_EXIT2) {
-	    if (tuple_arity != 4) {
-		goto invalid_message;
-	    }
-	    from = tuple[2];
-	    to = tuple[3];
-	    reason = tuple[4];
-	    token = NIL;
-	} else {
-	    if (tuple_arity != 5) {
-		goto invalid_message;
-	    }
-	    from = tuple[2];
-	    to = tuple[3];
-	    token = tuple[4];
-	    reason = tuple[5];
-	}
-	if (is_not_pid(from) || is_not_internal_pid(to)) {
-	    goto invalid_message;
-	}
-	rp = erts_pid2proc_opt(NULL, 0, to, rp_locks,
-			       ERTS_P2P_FLG_SMP_INC_REFC);
-	if (rp) {
-	    (void) erts_send_exit_signal(NULL,
-					 from,
-					 rp,
-					 &rp_locks,
-					 reason,
-					 token,
-					 NULL,
-					 0);
-	    erts_smp_proc_unlock(rp, rp_locks);
-	    erts_smp_proc_dec_refc(rp);
-	}
-	break;
-    }
-    case DOP_GROUP_LEADER:
-	if (tuple_arity != 3) {
-	    goto invalid_message;
-	}
-	from = tuple[2];   /* Group leader  */
-	to = tuple[3];     /* new member */
-	if (is_not_pid(from) || is_not_pid(to)) {
-	    goto invalid_message;
-	}
-
-	rp = erts_pid2proc(NULL, 0, to, ERTS_PROC_LOCK_MAIN);
-	if (!rp)
-	    break;
-	rp->group_leader = STORE_NC_IN_PROC(rp, from);
-	erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_MAIN);
-	break;
-
-    default: 
-	goto invalid_message;
+                    xres = erts_send_exit_signal(NULL,
+                            from,
+                            rp,
+                            &rp_locks, 
+                            reason,
+                            token,
+                            NULL,
+                            ERTS_XSIG_FLG_IGN_KILL);
+                    if (xres >= 0 && IS_TRACED_FL(rp, F_TRACE_PROCS)) {
+                        /* We didn't exit the process and it is traced */
+                        trace_proc(NULL, rp, am_getting_unlinked, from);
+                    }
+                }
+                erts_smp_proc_unlock(rp, rp_locks);
+            }
+            erts_remove_dist_link(&dld, to, from, dep);
+            if (lnk)
+                erts_destroy_link(lnk);
+            erts_destroy_dist_link(&dld);
+            break;
+        }
+        case DOP_EXIT2_TT:
+        case DOP_EXIT2: {
+            ErtsProcLocks rp_locks = ERTS_PROC_LOCKS_XSIG_SEND;
+            /* 'from' is send an exit signal to 'to' */
+            if (type == DOP_EXIT2) {
+                if (tuple_arity != 4) {
+                    goto invalid_message;
+                }
+                from = tuple[2];
+                to = tuple[3];
+                reason = tuple[4];
+                token = NIL;
+            } else {
+                if (tuple_arity != 5) {
+                    goto invalid_message;
+                }
+                from = tuple[2];
+                to = tuple[3];
+                token = tuple[4];
+                reason = tuple[5];
+            }
+            if (is_not_pid(from) || is_not_internal_pid(to)) {
+                goto invalid_message;
+            }
+            rp = erts_pid2proc_opt(NULL, 0, to, rp_locks,
+                    ERTS_P2P_FLG_SMP_INC_REFC);
+            if (rp) {
+                (void) erts_send_exit_signal(NULL,
+                        from,
+                        rp,
+                        &rp_locks,
+                        reason,
+                        token,
+                        NULL,
+                        0);
+                erts_smp_proc_unlock(rp, rp_locks);
+                erts_smp_proc_dec_refc(rp);
+            }
+            break;
+        }
+        case DOP_GROUP_LEADER:
+            if (tuple_arity != 3) {
+                goto invalid_message;
+            }
+            from = tuple[2];   /* Group leader  */
+            to = tuple[3];     /* new member */
+            if (is_not_pid(from) || is_not_pid(to)) {
+                goto invalid_message;
+            }
+
+            rp = erts_pid2proc(NULL, 0, to, ERTS_PROC_LOCK_MAIN);
+            if (!rp)
+                break;
+            rp->group_leader = STORE_NC_IN_PROC(rp, from);
+            erts_smp_proc_unlock(rp, ERTS_PROC_LOCK_MAIN);
+            break;
+
+        default: 
+            goto invalid_message;
     }
 
     erts_cleanup_offheap(&off_heap);
 #ifndef HYBRID /* FIND ME! */
     if (ctl != ctl_default) {
-	erts_free(ERTS_ALC_T_DCTRL_BUF, (void *) ctl);
+        erts_free(ERTS_ALC_T_DCTRL_BUF, (void *) ctl);
     }
 #endif
     UnUseTmpHeapNoproc(DIST_CTL_DEFAULT_SIZE);
     ERTS_SMP_CHK_NO_PROC_LOCKS;
     return 0;
- invalid_message:
+    invalid_message:
     {
-	erts_dsprintf_buf_t *dsbufp = erts_create_logger_dsbuf();
-	erts_dsprintf(dsbufp, "Invalid distribution message: %.200T", arg);
-	erts_send_error_to_logger_nogl(dsbufp);
+        erts_dsprintf_buf_t *dsbufp = erts_create_logger_dsbuf();
+        erts_dsprintf(dsbufp, "Invalid distribution message: %.200T", arg);
+        erts_send_error_to_logger_nogl(dsbufp);
     }
- data_error:
+    data_error:
     PURIFY_MSG("data error");
     erts_cleanup_offheap(&off_heap);
 #ifndef HYBRID /* FIND ME! */
     if (ctl != ctl_default) {
-	erts_free(ERTS_ALC_T_DCTRL_BUF, (void *) ctl);
+        erts_free(ERTS_ALC_T_DCTRL_BUF, (void *) ctl);
     }
 #endif
     UnUseTmpHeapNoproc(DIST_CTL_DEFAULT_SIZE);
@@ -1526,35 +1528,35 @@ dsig_send(ErtsDSigData *dsdp, Eterm ctl, Eterm msg, int force_busy)
     Process *c_p = dsdp->proc;
 
     if (!c_p || dsdp->no_suspend)
-	force_busy = 1;
+        force_busy = 1;
 
     ERTS_SMP_LC_ASSERT(!c_p
-		       || (ERTS_PROC_LOCK_MAIN
-			   == erts_proc_lc_my_proc_locks(c_p)));
+            || (ERTS_PROC_LOCK_MAIN
+                    == erts_proc_lc_my_proc_locks(c_p)));
 
     if (!erts_is_alive)
-	return ERTS_DSIG_SEND_OK;
+        return ERTS_DSIG_SEND_OK;
 
     if (flags & DFLAG_DIST_HDR_ATOM_CACHE) {
-	acmp = erts_get_atom_cache_map(c_p);
-	pass_through_size = 0;
+        acmp = erts_get_atom_cache_map(c_p);
+        pass_through_size = 0;
     }
     else {
-	acmp = NULL;
-	pass_through_size = 1;
+        acmp = NULL;
+        pass_through_size = 1;
     }
 
 #ifdef ERTS_DIST_MSG_DBG
     erts_fprintf(stderr, ">>%s CTL: %T\n", pass_through_size ? "P" : " ", ctl);
     if (is_value(msg))
-	erts_fprintf(stderr, "    MSG: %T\n", msg);
+        erts_fprintf(stderr, "    MSG: %T\n", msg);
 #endif
 
     data_size = pass_through_size;
     erts_reset_atom_cache_map(acmp);
     data_size += erts_encode_dist_ext_size(ctl, flags, acmp);
     if (is_value(msg))
-	data_size += erts_encode_dist_ext_size(msg, flags, acmp);
+        data_size += erts_encode_dist_ext_size(msg, flags, acmp);
     erts_finalize_atom_cache_map(acmp);
 
     dhdr_ext_size = erts_encode_ext_dist_header_size(acmp);
@@ -1568,8 +1570,8 @@ dsig_send(ErtsDSigData *dsdp, Eterm ctl, Eterm msg, int force_busy)
     /* Encode control message */
     erts_encode_dist_ext(ctl, &obuf->ext_endp, flags, acmp);
     if (is_value(msg)) {
-	/* Encode message */
-	erts_encode_dist_ext(msg, &obuf->ext_endp, flags, acmp);
+        /* Encode message */
+        erts_encode_dist_ext(msg, &obuf->ext_endp, flags, acmp);
     }
 
     ASSERT(obuf->extp < obuf->ext_endp);
@@ -1586,91 +1588,91 @@ dsig_send(ErtsDSigData *dsdp, Eterm ctl, Eterm msg, int force_busy)
     erts_smp_de_rlock(dep);
     cid = dep->cid;
     if (cid != dsdp->cid
-	|| dep->connection_id != dsdp->connection_id
-	|| dep->status & ERTS_DE_SFLG_EXITING) {
-	/* Not the same connection as when we started; drop message... */
-	erts_smp_de_runlock(dep);
-	free_dist_obuf(obuf);
+            || dep->connection_id != dsdp->connection_id
+            || dep->status & ERTS_DE_SFLG_EXITING) {
+        /* Not the same connection as when we started; drop message... */
+        erts_smp_de_runlock(dep);
+        free_dist_obuf(obuf);
     }
     else {
-	ErtsProcList *plp = NULL;
-	erts_smp_mtx_lock(&dep->qlock);
-	dep->qsize += size_obuf(obuf);
-	if (dep->qsize >= erts_dist_buf_busy_limit)
-	    dep->qflgs |= ERTS_DE_QFLG_BUSY;
-	if (!force_busy && (dep->qflgs & ERTS_DE_QFLG_BUSY)) {
-	    erts_smp_mtx_unlock(&dep->qlock);
-
-	    plp = erts_proclist_create(c_p);
-	    plp->next = NULL;
-	    erts_suspend(c_p, ERTS_PROC_LOCK_MAIN, NULL);
-	    suspended = 1;
-	    erts_smp_mtx_lock(&dep->qlock);
-	}
-
-	/* Enqueue obuf on dist entry */
-	if (dep->out_queue.last)
-	    dep->out_queue.last->next = obuf;
-	else
-	    dep->out_queue.first = obuf;
-	dep->out_queue.last = obuf;
-
-	if (!force_busy) {
-	    if (!(dep->qflgs & ERTS_DE_QFLG_BUSY)) {
-		if (suspended)
-		    resume = 1; /* was busy when we started, but isn't now */
-	    }
-	    else {
-		/* Enqueue suspended process on dist entry */
-		ASSERT(plp);
-		if (dep->suspended.last)
-		    dep->suspended.last->next = plp;
-		else
-		    dep->suspended.first = plp;
-		dep->suspended.last = plp;
-	    }
-	}
-
-	erts_smp_mtx_unlock(&dep->qlock);
-	erts_schedule_dist_command(NULL, dep);
-	erts_smp_de_runlock(dep);
-	
-	if (resume) {
-	    erts_resume(c_p, ERTS_PROC_LOCK_MAIN);
-	    erts_proclist_destroy(plp);
-	    /*
-	     * Note that the calling process still have to yield as if it
-	     * suspended. If not, the calling process could later be
-	     * erroneously scheduled when it shouldn't be.
-	     */
-	}
+        ErtsProcList *plp = NULL;
+        erts_smp_mtx_lock(&dep->qlock);
+        dep->qsize += size_obuf(obuf);
+        if (dep->qsize >= erts_dist_buf_busy_limit)
+            dep->qflgs |= ERTS_DE_QFLG_BUSY;
+        if (!force_busy && (dep->qflgs & ERTS_DE_QFLG_BUSY)) {
+            erts_smp_mtx_unlock(&dep->qlock);
+
+            plp = erts_proclist_create(c_p);
+            plp->next = NULL;
+            erts_suspend(c_p, ERTS_PROC_LOCK_MAIN, NULL);
+            suspended = 1;
+            erts_smp_mtx_lock(&dep->qlock);
+        }
+
+        /* Enqueue obuf on dist entry */
+        if (dep->out_queue.last)
+            dep->out_queue.last->next = obuf;
+        else
+            dep->out_queue.first = obuf;
+        dep->out_queue.last = obuf;
+
+        if (!force_busy) {
+            if (!(dep->qflgs & ERTS_DE_QFLG_BUSY)) {
+                if (suspended)
+                    resume = 1; /* was busy when we started, but isn't now */
+            }
+            else {
+                /* Enqueue suspended process on dist entry */
+                ASSERT(plp);
+                if (dep->suspended.last)
+                    dep->suspended.last->next = plp;
+                else
+                    dep->suspended.first = plp;
+                dep->suspended.last = plp;
+            }
+        }
+
+        erts_smp_mtx_unlock(&dep->qlock);
+        erts_schedule_dist_command(NULL, dep);
+        erts_smp_de_runlock(dep);
+
+        if (resume) {
+            erts_resume(c_p, ERTS_PROC_LOCK_MAIN);
+            erts_proclist_destroy(plp);
+            /*
+             * Note that the calling process still have to yield as if it
+             * suspended. If not, the calling process could later be
+             * erroneously scheduled when it shouldn't be.
+             */
+        }
     }
 
     if (c_p) {
-	int reds;
-	/* 
-	 * Bump reductions on calling process.
-	 *
-	 * This is the reduction cost: Always a base cost of 8 reductions
-	 * plus 16 reductions per kilobyte generated external data.
-	 */
-
-	data_size >>= (10-4);
+        int reds;
+        /* 
+         * Bump reductions on calling process.
+         *
+         * This is the reduction cost: Always a base cost of 8 reductions
+         * plus 16 reductions per kilobyte generated external data.
+         */
+
+        data_size >>= (10-4);
 #if defined(ARCH_64) && !HALFWORD_HEAP
-	data_size &= 0x003fffffffffffff;
+        data_size &= 0x003fffffffffffff;
 #elif defined(ARCH_32) || HALFWORD_HEAP
-	data_size &= 0x003fffff;
+        data_size &= 0x003fffff;
 #else
 #       error "Ohh come on ... !?!"
 #endif
-	reds = 8 + ((int) data_size > 1000000 ? 1000000 : (int) data_size);
-	BUMP_REDS(c_p, reds);
+        reds = 8 + ((int) data_size > 1000000 ? 1000000 : (int) data_size);
+        BUMP_REDS(c_p, reds);
     }
 
     if (suspended) {
-	if (!resume && erts_system_monitor_flags.busy_dist_port)
-	    monitor_generic(c_p, am_busy_dist_port, cid);
-	return ERTS_DSIG_SEND_YIELD;
+        if (!resume && erts_system_monitor_flags.busy_dist_port)
+            monitor_generic(c_p, am_busy_dist_port, cid);
+        return ERTS_DSIG_SEND_YIELD;
     }
     return ERTS_DSIG_SEND_OK;
 }
@@ -1686,16 +1688,16 @@ dist_port_command(Port *prt, ErtsDistOutputBuf *obuf)
     ERTS_SMP_LC_ASSERT(erts_lc_is_port_locked(prt));
 
     if (size > (Uint) INT_MAX)
-	erl_exit(ERTS_ABORT_EXIT,
-		 "Absurdly large distribution output data buffer "
-		 "(%beu bytes) passed.\n",
-		 size);
+        erl_exit(ERTS_ABORT_EXIT,
+                "Absurdly large distribution output data buffer "
+                "(%beu bytes) passed.\n",
+                size);
 
     prt->caller = NIL;
     fpe_was_unmasked = erts_block_fpe();
     (*prt->drv_ptr->output)((ErlDrvData) prt->drv_data,
-			    (char*) obuf->extp,
-			    (int) size);
+            (char*) obuf->extp,
+            (int) size);
     erts_unblock_fpe(fpe_was_unmasked);
     return size;
 }
@@ -1713,10 +1715,10 @@ dist_port_commandv(Port *prt, ErtsDistOutputBuf *obuf)
     ERTS_SMP_LC_ASSERT(erts_lc_is_port_locked(prt));
 
     if (size > (Uint) INT_MAX)
-	erl_exit(ERTS_ABORT_EXIT,
-		 "Absurdly large distribution output data buffer "
-		 "(%beu bytes) passed.\n",
-		 size);
+        erl_exit(ERTS_ABORT_EXIT,
+                "Absurdly large distribution output data buffer "
+                "(%beu bytes) passed.\n",
+                size);
 
     iov[0].iov_base = NULL;
     iov[0].iov_len = 0;
@@ -1755,9 +1757,9 @@ dist_port_commandv(Port *prt, ErtsDistOutputBuf *obuf)
 #define ERTS_PORT_REDS_DIST_CMD_EXIT 200
 #define ERTS_PORT_REDS_DIST_CMD_RESUMED 5
 #define ERTS_PORT_REDS_DIST_CMD_DATA(SZ) \
-  ((SZ) < (1 << 10) \
-   ? ((Sint) 1) \
-   : ((((Sint) (SZ)) >> 10) & ((Sint) ERTS_PORT_REDS_MASK__)))
+        ((SZ) < (1 << 10) \
+                ? ((Sint) 1) \
+                        : ((((Sint) (SZ)) >> 10) & ((Sint) ERTS_PORT_REDS_MASK__)))
 
 int
 erts_dist_command(Port *prt, int reds_limit)
@@ -1785,9 +1787,9 @@ erts_dist_command(Port *prt, int reds_limit)
     erts_smp_de_runlock(dep);
 
     if (status & ERTS_DE_SFLG_EXITING) {
-	erts_do_exit_port(prt, prt->id, am_killed);
-	erts_deref_dist_entry(dep);
-	return reds + ERTS_PORT_REDS_DIST_CMD_EXIT;
+        erts_do_exit_port(prt, prt->id, am_killed);
+        erts_deref_dist_entry(dep);
+        return reds + ERTS_PORT_REDS_DIST_CMD_EXIT;
     }
 
     ASSERT(send);
@@ -1813,167 +1815,167 @@ erts_dist_command(Port *prt, int reds_limit)
     dep->finalized_out_queue.last = NULL;
 
     if (reds > reds_limit)
-	goto preempted;
+        goto preempted;
 
     prt_busy = (int) (prt->status & ERTS_PORT_SFLG_PORT_BUSY);
 
     if (!prt_busy && foq.first) {
-	int preempt = 0;
-	do {
-	    Uint size;
-	    ErtsDistOutputBuf *fob;
+        int preempt = 0;
+        do {
+            Uint size;
+            ErtsDistOutputBuf *fob;
 
-	    size = (*send)(prt, foq.first);
+            size = (*send)(prt, foq.first);
 #ifdef ERTS_RAW_DIST_MSG_DBG
-	    erts_fprintf(stderr, ">> ");
-	    bw(foq.first->extp, size);
+            erts_fprintf(stderr, ">> ");
+            bw(foq.first->extp, size);
 #endif
-	    reds += ERTS_PORT_REDS_DIST_CMD_DATA(size);
-	    fob = foq.first;
-	    obufsize += size_obuf(fob);
-	    foq.first = foq.first->next;
-	    free_dist_obuf(fob);
-	    preempt = reds > reds_limit || (prt->status & ERTS_PORT_SFLGS_DEAD);
-	    if (prt->status & ERTS_PORT_SFLG_PORT_BUSY) {
-		prt_busy = 1;
-		break;
-	    }
-	} while (foq.first && !preempt);
-	if (!foq.first)
-	    foq.last = NULL;
-	if (preempt)
-	    goto preempted;
+            reds += ERTS_PORT_REDS_DIST_CMD_DATA(size);
+            fob = foq.first;
+            obufsize += size_obuf(fob);
+            foq.first = foq.first->next;
+            free_dist_obuf(fob);
+            preempt = reds > reds_limit || (prt->status & ERTS_PORT_SFLGS_DEAD);
+            if (prt->status & ERTS_PORT_SFLG_PORT_BUSY) {
+                prt_busy = 1;
+                break;
+            }
+        } while (foq.first && !preempt);
+        if (!foq.first)
+            foq.last = NULL;
+        if (preempt)
+            goto preempted;
     }
 
     if (prt_busy) {
-	if (oq.first) {
-	    ErtsDistOutputBuf *ob;
-	    int preempt;
-	finalize_only:
-	    preempt = 0;
-	    ob = oq.first;
-	    ASSERT(ob);
-	    do {
-		ob->extp = erts_encode_ext_dist_header_finalize(ob->extp,
-								dep->cache);
-		if (!(flags & DFLAG_DIST_HDR_ATOM_CACHE))
-		    *--ob->extp = PASS_THROUGH; /* Old node; 'pass through'
+        if (oq.first) {
+            ErtsDistOutputBuf *ob;
+            int preempt;
+            finalize_only:
+            preempt = 0;
+            ob = oq.first;
+            ASSERT(ob);
+            do {
+                ob->extp = erts_encode_ext_dist_header_finalize(ob->extp,
+                        dep->cache);
+                if (!(flags & DFLAG_DIST_HDR_ATOM_CACHE))
+                    *--ob->extp = PASS_THROUGH; /* Old node; 'pass through'
 						   needed */
-		ASSERT(&ob->data[0] <= ob->extp && ob->extp < ob->ext_endp);
-		reds += ERTS_PORT_REDS_DIST_CMD_FINALIZE;
-		preempt = reds > reds_limit;
-		if (preempt)
-		    break;
-		ob = ob->next;
-	    } while (ob);
-	    /*
-	     * At least one buffer was finalized; if we got preempted,
-	     * ob points to the last buffer that we finalized.
-	     */
-	    if (foq.last)
-		foq.last->next = oq.first;
-	    else
-		foq.first = oq.first;
-	    if (!preempt) {
-		/* All buffers finalized */
-		foq.last = oq.last;
-		oq.first = oq.last = NULL;
-	    }
-	    else {
-		/* Not all buffers finalized; split oq. */
-		foq.last = ob;
-		oq.first = ob->next;
-		if (oq.first)
-		    ob->next = NULL;
-		else
-		    oq.last = NULL;
-	    }
-	    if (preempt)
-		goto preempted;
-	}
+                ASSERT(&ob->data[0] <= ob->extp && ob->extp < ob->ext_endp);
+                reds += ERTS_PORT_REDS_DIST_CMD_FINALIZE;
+                preempt = reds > reds_limit;
+                if (preempt)
+                    break;
+                ob = ob->next;
+            } while (ob);
+            /*
+             * At least one buffer was finalized; if we got preempted,
+             * ob points to the last buffer that we finalized.
+             */
+            if (foq.last)
+                foq.last->next = oq.first;
+            else
+                foq.first = oq.first;
+            if (!preempt) {
+                /* All buffers finalized */
+                foq.last = oq.last;
+                oq.first = oq.last = NULL;
+            }
+            else {
+                /* Not all buffers finalized; split oq. */
+                foq.last = ob;
+                oq.first = ob->next;
+                if (oq.first)
+                    ob->next = NULL;
+                else
+                    oq.last = NULL;
+            }
+            if (preempt)
+                goto preempted;
+        }
     }
     else {
-	int preempt = 0;
-	while (oq.first && !preempt) {
-	    ErtsDistOutputBuf *fob;
-	    Uint size;
-	    oq.first->extp
-		= erts_encode_ext_dist_header_finalize(oq.first->extp,
-						       dep->cache);
-	    reds += ERTS_PORT_REDS_DIST_CMD_FINALIZE;
-	    if (!(flags & DFLAG_DIST_HDR_ATOM_CACHE))
-		*--oq.first->extp = PASS_THROUGH; /* Old node; 'pass through'
+        int preempt = 0;
+        while (oq.first && !preempt) {
+            ErtsDistOutputBuf *fob;
+            Uint size;
+            oq.first->extp
+            = erts_encode_ext_dist_header_finalize(oq.first->extp,
+                    dep->cache);
+            reds += ERTS_PORT_REDS_DIST_CMD_FINALIZE;
+            if (!(flags & DFLAG_DIST_HDR_ATOM_CACHE))
+                *--oq.first->extp = PASS_THROUGH; /* Old node; 'pass through'
 						     needed */
-	    ASSERT(&oq.first->data[0] <= oq.first->extp
-		   && oq.first->extp < oq.first->ext_endp);
-	    size = (*send)(prt, oq.first);
+            ASSERT(&oq.first->data[0] <= oq.first->extp
+                    && oq.first->extp < oq.first->ext_endp);
+            size = (*send)(prt, oq.first);
 #ifdef ERTS_RAW_DIST_MSG_DBG
-	    erts_fprintf(stderr, ">> ");
-	    bw(oq.first->extp, size);
+            erts_fprintf(stderr, ">> ");
+            bw(oq.first->extp, size);
 #endif
-	    reds += ERTS_PORT_REDS_DIST_CMD_DATA(size);
-	    fob = oq.first;
-	    obufsize += size_obuf(fob);
-	    oq.first = oq.first->next;
-	    free_dist_obuf(fob);
-	    preempt = reds > reds_limit || (prt->status & ERTS_PORT_SFLGS_DEAD);
-	    if (prt->status & ERTS_PORT_SFLG_PORT_BUSY) {
-		prt_busy = 1;
-		if (oq.first && !preempt)
-		    goto finalize_only;
-	    }
-	}
-
-	ASSERT(!oq.first || preempt);
-
-	/*
-	 * Preempt if not all buffers have been handled.
-	 */
-	if (preempt && oq.first)
-	    goto preempted;
+            reds += ERTS_PORT_REDS_DIST_CMD_DATA(size);
+            fob = oq.first;
+            obufsize += size_obuf(fob);
+            oq.first = oq.first->next;
+            free_dist_obuf(fob);
+            preempt = reds > reds_limit || (prt->status & ERTS_PORT_SFLGS_DEAD);
+            if (prt->status & ERTS_PORT_SFLG_PORT_BUSY) {
+                prt_busy = 1;
+                if (oq.first && !preempt)
+                    goto finalize_only;
+            }
+        }
+
+        ASSERT(!oq.first || preempt);
+
+        /*
+         * Preempt if not all buffers have been handled.
+         */
+        if (preempt && oq.first)
+            goto preempted;
 
 #ifdef DEBUG
-	oq.last = NULL;
+        oq.last = NULL;
 #endif
-	ASSERT(!oq.first);
-	ASSERT(!foq.first && !foq.last);
-
-	/*
-	 * Everything that was buffered when we started have now been
-	 * written to the port. If port isn't busy but dist entry is
-	 * and we havn't got too muched queued on dist entry, set
-	 * dist entry in a non-busy state and resume suspended
-	 * processes.
-	 */
-	erts_smp_mtx_lock(&dep->qlock);
-	ASSERT(dep->qsize >= obufsize);
-	dep->qsize -= obufsize;
-	obufsize = 0;
-	if (!prt_busy
-	    && (dep->qflgs & ERTS_DE_QFLG_BUSY)
-	    && dep->qsize < erts_dist_buf_busy_limit) {
-	    ErtsProcList *suspendees;
-	    int resumed;
-	    suspendees = get_suspended_on_de(dep, ERTS_DE_QFLG_BUSY);
-	    erts_smp_mtx_unlock(&dep->qlock);
-
-	    resumed = erts_resume_processes(suspendees);
-	    reds += resumed*ERTS_PORT_REDS_DIST_CMD_RESUMED;
-	}
-	else
-	    erts_smp_mtx_unlock(&dep->qlock);
+        ASSERT(!oq.first);
+        ASSERT(!foq.first && !foq.last);
+
+        /*
+         * Everything that was buffered when we started have now been
+         * written to the port. If port isn't busy but dist entry is
+         * and we havn't got too muched queued on dist entry, set
+         * dist entry in a non-busy state and resume suspended
+         * processes.
+         */
+        erts_smp_mtx_lock(&dep->qlock);
+        ASSERT(dep->qsize >= obufsize);
+        dep->qsize -= obufsize;
+        obufsize = 0;
+        if (!prt_busy
+                && (dep->qflgs & ERTS_DE_QFLG_BUSY)
+                && dep->qsize < erts_dist_buf_busy_limit) {
+            ErtsProcList *suspendees;
+            int resumed;
+            suspendees = get_suspended_on_de(dep, ERTS_DE_QFLG_BUSY);
+            erts_smp_mtx_unlock(&dep->qlock);
+
+            resumed = erts_resume_processes(suspendees);
+            reds += resumed*ERTS_PORT_REDS_DIST_CMD_RESUMED;
+        }
+        else
+            erts_smp_mtx_unlock(&dep->qlock);
     }
 
     ASSERT(!oq.first && !oq.last);
 
- done:
+    done:
 
     if (obufsize != 0) {
-	ASSERT(obufsize > 0);
-	erts_smp_mtx_lock(&dep->qlock);
-	ASSERT(dep->qsize >= obufsize);
-	dep->qsize -= obufsize;
-	erts_smp_mtx_unlock(&dep->qlock);
+        ASSERT(obufsize > 0);
+        erts_smp_mtx_lock(&dep->qlock);
+        ASSERT(dep->qsize >= obufsize);
+        dep->qsize -= obufsize;
+        erts_smp_mtx_unlock(&dep->qlock);
     }
 
     ASSERT(foq.first || !foq.last);
@@ -1982,69 +1984,69 @@ erts_dist_command(Port *prt, int reds_limit)
     ASSERT(!dep->finalized_out_queue.last);
 
     if (foq.first) {
-	dep->finalized_out_queue.first = foq.first;
-	dep->finalized_out_queue.last = foq.last;
+        dep->finalized_out_queue.first = foq.first;
+        dep->finalized_out_queue.last = foq.last;
     }
 
-     /* Avoid wrapping reduction counter... */
+    /* Avoid wrapping reduction counter... */
     if (reds > INT_MAX/2)
-	reds = INT_MAX/2;
+        reds = INT_MAX/2;
 
     erts_deref_dist_entry(dep);
 
     return reds;
 
- preempted:
+    preempted:
 
     ASSERT(oq.first || !oq.last);
     ASSERT(!oq.first || oq.last);
 
     if (prt->status & ERTS_PORT_SFLGS_DEAD) {
-	/*
-	 * Port died during port command; clean up 'oq'
-	 * and 'foq'. Things buffered in dist entry after
-	 * we begun processing the queues have already been
-	 * cleaned up when port terminated.
-	 */
-
-	if (oq.first)
-	    oq.last->next = foq.first;
-	else
-	    oq.first = foq.first;
-
-	while (oq.first) {
-	    ErtsDistOutputBuf *fob = oq.first;
-	    oq.first = oq.first->next;
-	    obufsize += size_obuf(fob);
-	    free_dist_obuf(fob);
-	}
-
-	foq.first = NULL;
-	foq.last = NULL;
+        /*
+         * Port died during port command; clean up 'oq'
+         * and 'foq'. Things buffered in dist entry after
+         * we begun processing the queues have already been
+         * cleaned up when port terminated.
+         */
+
+        if (oq.first)
+            oq.last->next = foq.first;
+        else
+            oq.first = foq.first;
+
+        while (oq.first) {
+            ErtsDistOutputBuf *fob = oq.first;
+            oq.first = oq.first->next;
+            obufsize += size_obuf(fob);
+            free_dist_obuf(fob);
+        }
+
+        foq.first = NULL;
+        foq.last = NULL;
 
 #ifdef DEBUG
-	erts_smp_mtx_lock(&dep->qlock);
-	ASSERT(dep->qsize == obufsize);
-	erts_smp_mtx_unlock(&dep->qlock);
+        erts_smp_mtx_lock(&dep->qlock);
+        ASSERT(dep->qsize == obufsize);
+        erts_smp_mtx_unlock(&dep->qlock);
 #endif
     }
     else {
-	if (oq.first) {
-	    /*
-	     * Unhandle buffers need to be put back first
-	     * in out_queue.
-	     */
-	    erts_smp_mtx_lock(&dep->qlock);
-	    dep->qsize -= obufsize;
-	    obufsize = 0;
-	    oq.last->next = dep->out_queue.first;
-	    dep->out_queue.first = oq.first;
-	    if (!dep->out_queue.last)
-		dep->out_queue.last = oq.last;
-	    erts_smp_mtx_unlock(&dep->qlock);
-	}
-
-	erts_schedule_dist_command(prt, NULL);
+        if (oq.first) {
+            /*
+             * Unhandle buffers need to be put back first
+             * in out_queue.
+             */
+            erts_smp_mtx_lock(&dep->qlock);
+            dep->qsize -= obufsize;
+            obufsize = 0;
+            oq.last->next = dep->out_queue.first;
+            dep->out_queue.first = oq.first;
+            if (!dep->out_queue.last)
+                dep->out_queue.last = oq.last;
+            erts_smp_mtx_unlock(&dep->qlock);
+        }
+
+        erts_schedule_dist_command(prt, NULL);
     }
     goto done;
 }
@@ -2060,24 +2062,24 @@ erts_kill_dist_connection(DistEntry *dep, Uint32 connection_id)
 {
     erts_smp_de_rwlock(dep);
     if (is_internal_port(dep->cid)
-	&& connection_id == dep->connection_id
-	&& !(dep->status & ERTS_DE_SFLG_EXITING)) {
+            && connection_id == dep->connection_id
+            && !(dep->status & ERTS_DE_SFLG_EXITING)) {
 
-	dep->status |= ERTS_DE_SFLG_EXITING;
+        dep->status |= ERTS_DE_SFLG_EXITING;
 
-	erts_smp_mtx_lock(&dep->qlock);
-	ASSERT(!(dep->qflgs & ERTS_DE_QFLG_EXIT));
-	dep->qflgs |= ERTS_DE_QFLG_EXIT;
-	erts_smp_mtx_unlock(&dep->qlock);
+        erts_smp_mtx_lock(&dep->qlock);
+        ASSERT(!(dep->qflgs & ERTS_DE_QFLG_EXIT));
+        dep->qflgs |= ERTS_DE_QFLG_EXIT;
+        erts_smp_mtx_unlock(&dep->qlock);
 
-	erts_schedule_dist_command(NULL, dep);
+        erts_schedule_dist_command(NULL, dep);
     }
     erts_smp_de_rwunlock(dep);
 }
 
 struct print_to_data {
-    int to;
-    void *arg;
+        int to;
+        void *arg;
 };
 
 static void doit_print_monitor_info(ErtsMonitor *mon, void *vptdp)
@@ -2088,19 +2090,19 @@ static void doit_print_monitor_info(ErtsMonitor *mon, void *vptdp)
     ErtsMonitor *rmon;
     rp = erts_pid2proc_unlocked(mon->pid);
     if (!rp || (rmon = erts_lookup_monitor(rp->monitors, mon->ref)) == NULL) {
-	erts_print(to, arg, "Warning, stray monitor for: %T\n", mon->pid);
+        erts_print(to, arg, "Warning, stray monitor for: %T\n", mon->pid);
     } else if (mon->type == MON_ORIGIN) {
-	/* Local pid is being monitored */
-	erts_print(to, arg, "Remotely monitored by: %T %T\n",
-		   mon->pid, rmon->pid);
+        /* Local pid is being monitored */
+        erts_print(to, arg, "Remotely monitored by: %T %T\n",
+                mon->pid, rmon->pid);
     } else {
-	erts_print(to, arg, "Remote monitoring: %T ", mon->pid);
-	if (is_not_atom(rmon->pid))
-	    erts_print(to, arg, "%T\n", rmon->pid);
-	else
-	    erts_print(to, arg, "{%T, %T}\n",
-		       rmon->name,
-		       rmon->pid); /* which in this case is the 
+        erts_print(to, arg, "Remote monitoring: %T ", mon->pid);
+        if (is_not_atom(rmon->pid))
+            erts_print(to, arg, "%T\n", rmon->pid);
+        else
+            erts_print(to, arg, "{%T, %T}\n",
+                    rmon->name,
+                    rmon->pid); /* which in this case is the 
 				      remote system name... */
     }
 }    
@@ -2112,22 +2114,22 @@ static void print_monitor_info(int to, void *arg, ErtsMonitor *mon)
 }
 
 typedef struct {
-    struct print_to_data *ptdp;
-    Eterm from;
+        struct print_to_data *ptdp;
+        Eterm from;
 } PrintLinkContext;
 
 static void doit_print_link_info2(ErtsLink *lnk, void *vpplc)
 {
     PrintLinkContext *pplc = (PrintLinkContext *) vpplc;
     erts_print(pplc->ptdp->to, pplc->ptdp->arg, "Remote link: %T %T\n",
-	       pplc->from, lnk->pid);
+            pplc->from, lnk->pid);
 }
 
 static void doit_print_link_info(ErtsLink *lnk, void *vptdp)
 {
     if (is_internal_pid(lnk->pid) && erts_pid2proc_unlocked(lnk->pid)) {
-	PrintLinkContext plc = {(struct print_to_data *) vptdp, lnk->pid};
-	erts_doforall_links(ERTS_LINK_ROOT(lnk), &doit_print_link_info2, &plc);
+        PrintLinkContext plc = {(struct print_to_data *) vptdp, lnk->pid};
+        erts_doforall_links(ERTS_LINK_ROOT(lnk), &doit_print_link_info2, &plc);
     } 
 }
 
@@ -2138,18 +2140,18 @@ static void print_link_info(int to, void *arg, ErtsLink *lnk)
 }
 
 typedef struct {
-    struct print_to_data ptd;
-    Eterm sysname;
+        struct print_to_data ptd;
+        Eterm sysname;
 } PrintNodeLinkContext;
-    
+
 
 static void doit_print_nodelink_info(ErtsLink *lnk, void *vpcontext)
 {
     PrintNodeLinkContext *pcontext = vpcontext;
 
     if (is_internal_pid(lnk->pid) && erts_pid2proc_unlocked(lnk->pid))
-	erts_print(pcontext->ptd.to, pcontext->ptd.arg,
-		   "Remote monitoring: %T %T\n", lnk->pid, pcontext->sysname);
+        erts_print(pcontext->ptd.to, pcontext->ptd.arg,
+                "Remote monitoring: %T %T\n", lnk->pid, pcontext->sysname);
 }
 
 static void print_nodelink_info(int to, void *arg, ErtsLink *lnk, Eterm sysname)
@@ -2163,78 +2165,78 @@ static int
 info_dist_entry(int to, void *arg, DistEntry *dep, int visible, int connected)
 {
 
-  if (visible && connected) {
-      erts_print(to, arg, "=visible_node:");
-  } else if (connected) {
-      erts_print(to, arg, "=hidden_node:");
-  } else {
-      erts_print(to, arg, "=not_connected:");
-  }
-  erts_print(to, arg, "%d\n", dist_entry_channel_no(dep));
+    if (visible && connected) {
+        erts_print(to, arg, "=visible_node:");
+    } else if (connected) {
+        erts_print(to, arg, "=hidden_node:");
+    } else {
+        erts_print(to, arg, "=not_connected:");
+    }
+    erts_print(to, arg, "%d\n", dist_entry_channel_no(dep));
 
-  if(connected && is_nil(dep->cid)) {
-    erts_print(to, arg,
-	       "Error: Not connected node still registered as connected:%T\n",
-	       dep->sysname);
-    return 0;
-  }
+    if(connected && is_nil(dep->cid)) {
+        erts_print(to, arg,
+                "Error: Not connected node still registered as connected:%T\n",
+                dep->sysname);
+        return 0;
+    }
 
-  if(!connected && is_not_nil(dep->cid)) {
-    erts_print(to, arg,
-	       "Error: Connected node not registered as connected:%T\n",
-	       dep->sysname);
-    return 0;
-  }
+    if(!connected && is_not_nil(dep->cid)) {
+        erts_print(to, arg,
+                "Error: Connected node not registered as connected:%T\n",
+                dep->sysname);
+        return 0;
+    }
 
-  erts_print(to, arg, "Name: %T", dep->sysname);
+    erts_print(to, arg, "Name: %T", dep->sysname);
 #ifdef DEBUG
-  erts_print(to, arg, " (refc=%d)", erts_refc_read(&dep->refc, 1));
+    erts_print(to, arg, " (refc=%d)", erts_refc_read(&dep->refc, 1));
 #endif
-  erts_print(to, arg, "\n");
-  if (!connected && is_nil(dep->cid)) {
-    if (dep->nlinks) {
-      erts_print(to, arg, "Error: Got links to not connected node:%T\n",
-		 dep->sysname);
+    erts_print(to, arg, "\n");
+    if (!connected && is_nil(dep->cid)) {
+        if (dep->nlinks) {
+            erts_print(to, arg, "Error: Got links to not connected node:%T\n",
+                    dep->sysname);
+        }
+        return 0;
     }
-    return 0;
-  }
 
-  erts_print(to, arg, "Controller: %T\n", dep->cid, to);
+    erts_print(to, arg, "Controller: %T\n", dep->cid, to);
+
+    erts_print_node_info(to, arg, dep->sysname, NULL, NULL);
+    print_monitor_info(to, arg, dep->monitors);
+    print_link_info(to, arg, dep->nlinks);
+    print_nodelink_info(to, arg, dep->node_links, dep->sysname);
 
-  erts_print_node_info(to, arg, dep->sysname, NULL, NULL);
-  print_monitor_info(to, arg, dep->monitors);
-  print_link_info(to, arg, dep->nlinks);
-  print_nodelink_info(to, arg, dep->node_links, dep->sysname);
+    return 0;
 
-  return 0;
-    
 }
 int distribution_info(int to, void *arg)	/* Called by break handler */
 {
     DistEntry *dep;
 
     erts_print(to, arg, "=node:%T\n", erts_this_dist_entry->sysname);
- 
+
     if (erts_this_node->sysname == am_Noname) {
-	erts_print(to, arg, "=no_distribution\n");
-	return(0);
+        erts_print(to, arg, "=no_distribution\n");
+        return(0);
     }
 
 #if 0
     if (!erts_visible_dist_entries && !erts_hidden_dist_entries) 
-      erts_print(to, arg, "Alive but not holding any connections \n");
+        erts_print(to, arg, "Alive but not holding any connections \n");
 #endif
 
     for(dep = erts_visible_dist_entries; dep; dep = dep->next) {
-      info_dist_entry(to, arg, dep, 1, 1);
+        info_dist_entry(to, arg, dep, 1, 1);
     }
 
     for(dep = erts_hidden_dist_entries; dep; dep = dep->next) {
-      info_dist_entry(to, arg, dep, 0, 1);
+        info_dist_entry(to, arg, dep, 0, 1);
     }
 
     for (dep = erts_not_connected_dist_entries; dep; dep = dep->next) {
-	info_dist_entry(to, arg, dep, 0, 0);
+        info_dist_entry(to, arg, dep, 0, 0);
     }
 
     return(0);
@@ -2256,7 +2258,7 @@ int distribution_info(int to, void *arg)	/* Called by break handler */
             dist_exit/3       -- send exit signals from remote to local process
             dist_link/2       -- link a remote process to a local
             dist_unlink/2     -- unlink a remote from a local
-****************************************************************************/
+ ****************************************************************************/
 
 
 
@@ -2281,48 +2283,48 @@ BIF_RETTYPE setnode_2(BIF_ALIST_2)
 
     /* valid creation ? */
     if(!term_to_Uint(BIF_ARG_2, &creation))
-	goto error;
+        goto error;
     if(creation > 3)
-	goto error;
+        goto error;
 
     /* valid node name ? */
     if (!is_node_name_atom(BIF_ARG_1))
-	goto error;
+        goto error;
 
     if (BIF_ARG_1 == am_Noname) /* cant use this name !! */
-	goto error;
+        goto error;
     if (erts_is_alive)     /* must not be alive! */
-	goto error;
+        goto error;
 
     /* Check that all trap functions are defined !! */
     if (dsend2_trap->address == NULL ||
-	dsend3_trap->address == NULL ||
-	/*	dsend_nosuspend_trap->address == NULL ||*/
-	dlink_trap->address == NULL ||
-	dunlink_trap->address == NULL ||
-	dmonitor_node_trap->address == NULL ||
-	dgroup_leader_trap->address == NULL ||
-	dmonitor_p_trap->address == NULL ||
-	dexit_trap->address == NULL) {
-	goto error;
+            dsend3_trap->address == NULL ||
+            /*	dsend_nosuspend_trap->address == NULL ||*/
+            dlink_trap->address == NULL ||
+            dunlink_trap->address == NULL ||
+            dmonitor_node_trap->address == NULL ||
+            dgroup_leader_trap->address == NULL ||
+            dmonitor_p_trap->address == NULL ||
+            dexit_trap->address == NULL) {
+        goto error;
     }
 
     net_kernel = erts_whereis_process(BIF_P, ERTS_PROC_LOCK_MAIN,
-				      am_net_kernel, ERTS_PROC_LOCK_MAIN, 0);
+            am_net_kernel, ERTS_PROC_LOCK_MAIN, 0);
     if (!net_kernel)
-	goto error;
+        goto error;
 
     /* By setting dist_entry==erts_this_dist_entry and DISTRIBUTION on
        net_kernel do_net_exist will be called when net_kernel
        is terminated !! */
     (void *) ERTS_PROC_SET_DIST_ENTRY(net_kernel,
-				      ERTS_PROC_LOCK_MAIN,
-				      erts_this_dist_entry);
+            ERTS_PROC_LOCK_MAIN,
+            erts_this_dist_entry);
     erts_refc_inc(&erts_this_dist_entry->refc, 2);
     net_kernel->flags |= F_DISTRIBUTION;
 
     if (net_kernel != BIF_P)
-	erts_smp_proc_unlock(net_kernel, ERTS_PROC_LOCK_MAIN);
+        erts_smp_proc_unlock(net_kernel, ERTS_PROC_LOCK_MAIN);
 
 #ifdef DEBUG
     erts_smp_rwmtx_rwlock(&erts_dist_table_rwmtx);
@@ -2340,7 +2342,7 @@ BIF_RETTYPE setnode_2(BIF_ALIST_2)
 
     BIF_RET(am_true);
 
- error:
+    error:
     BIF_ERROR(BIF_P, BADARG);
 }
 
@@ -2377,38 +2379,38 @@ BIF_RETTYPE setnode_3(BIF_ALIST_3)
      */
 
     if (!is_node_name_atom(BIF_ARG_1) ||
-	is_not_internal_port(BIF_ARG_2) ||
-	(erts_this_node->sysname == am_Noname)) {
-	goto badarg;
+            is_not_internal_port(BIF_ARG_2) ||
+            (erts_this_node->sysname == am_Noname)) {
+        goto badarg;
     }
 
     if (!is_tuple(BIF_ARG_3))
-	goto badarg;
+        goto badarg;
     tp = tuple_val(BIF_ARG_3);
     if (*tp++ != make_arityval(4))
-	goto badarg;
+        goto badarg;
     if (!is_small(*tp))
-	goto badarg;
+        goto badarg;
     flags = unsigned_val(*tp++);
     if (!is_small(*tp) || (version = unsigned_val(*tp)) == 0)
-	goto badarg;
+        goto badarg;
     ic = *(++tp);
     oc = *(++tp);
     if (!is_atom(ic) || !is_atom(oc))
-	goto badarg;
+        goto badarg;
 
     /* DFLAG_EXTENDED_REFERENCES is compulsory from R9 and forward */
     if (!(DFLAG_EXTENDED_REFERENCES & flags)) {
-	erts_dsprintf_buf_t *dsbufp = erts_create_logger_dsbuf();
-	erts_dsprintf(dsbufp, "%T", BIF_P->id);
-	if (BIF_P->reg)
-	    erts_dsprintf(dsbufp, " (%T)", BIF_P->reg->name);
-	erts_dsprintf(dsbufp,
-		      " attempted to enable connection to node %T "
-		      "which is not able to handle extended references.\n",
-		      BIF_ARG_1);
-	erts_send_error_to_logger(BIF_P->group_leader, dsbufp);
-	goto badarg;
+        erts_dsprintf_buf_t *dsbufp = erts_create_logger_dsbuf();
+        erts_dsprintf(dsbufp, "%T", BIF_P->id);
+        if (BIF_P->reg)
+            erts_dsprintf(dsbufp, " (%T)", BIF_P->reg->name);
+        erts_dsprintf(dsbufp,
+                " attempted to enable connection to node %T "
+                "which is not able to handle extended references.\n",
+                BIF_ARG_1);
+        erts_send_error_to_logger(BIF_P->group_leader, dsbufp);
+        goto badarg;
     }
 
     /*
@@ -2418,41 +2420,41 @@ BIF_RETTYPE setnode_3(BIF_ALIST_3)
     /* get dist_entry */
     dep = erts_find_or_insert_dist_entry(BIF_ARG_1);
     if (dep == erts_this_dist_entry)
-	goto badarg;
+        goto badarg;
     else if (!dep)
-	goto system_limit; /* Should never happen!!! */
+        goto system_limit; /* Should never happen!!! */
 
     pp = erts_id2port(BIF_ARG_2, BIF_P, ERTS_PROC_LOCK_MAIN);
     erts_smp_de_rwlock(dep);
 
     if (!pp || (pp->status & ERTS_PORT_SFLG_EXITING))
-	goto badarg;
+        goto badarg;
 
     if ((pp->drv_ptr->flags & ERL_DRV_FLAG_SOFT_BUSY) == 0)
-	goto badarg;
+        goto badarg;
 
     if (dep->cid == BIF_ARG_2 && pp->dist_entry == dep)
-	goto done; /* Already set */
+        goto done; /* Already set */
 
     if (dep->status & ERTS_DE_SFLG_EXITING) {
-	/* Suspend on dist entry waiting for the exit to finish */
-	ErtsProcList *plp = erts_proclist_create(BIF_P);
-	plp->next = NULL;
-	erts_suspend(BIF_P, ERTS_PROC_LOCK_MAIN, NULL);
-	erts_smp_mtx_lock(&dep->qlock);
-	if (dep->suspended.last)
-	    dep->suspended.last->next = plp;
-	else
-	    dep->suspended.first = plp;
-	dep->suspended.last = plp;
-	erts_smp_mtx_unlock(&dep->qlock);
-	goto yield;
+        /* Suspend on dist entry waiting for the exit to finish */
+        ErtsProcList *plp = erts_proclist_create(BIF_P);
+        plp->next = NULL;
+        erts_suspend(BIF_P, ERTS_PROC_LOCK_MAIN, NULL);
+        erts_smp_mtx_lock(&dep->qlock);
+        if (dep->suspended.last)
+            dep->suspended.last->next = plp;
+        else
+            dep->suspended.first = plp;
+        dep->suspended.last = plp;
+        erts_smp_mtx_unlock(&dep->qlock);
+        goto yield;
     }
 
     ASSERT(!(dep->status & ERTS_DE_SFLG_EXITING));
 
     if (pp->dist_entry || is_not_nil(dep->cid))
-	goto badarg;
+        goto badarg;
 
     erts_port_status_bor_set(pp, ERTS_PORT_SFLG_DISTRIBUTION);
 
@@ -2465,8 +2467,8 @@ BIF_RETTYPE setnode_3(BIF_ALIST_3)
 
 #if 1
     dep->send = (pp->drv_ptr->outputv
-		 ? dist_port_commandv
-		 : dist_port_command);
+            ? dist_port_commandv
+                    : dist_port_command);
 #else
     dep->send = dist_port_command;
 #endif
@@ -2481,38 +2483,38 @@ BIF_RETTYPE setnode_3(BIF_ALIST_3)
     erts_set_dist_entry_connected(dep, BIF_ARG_2, flags);
 
     if (flags & DFLAG_DIST_HDR_ATOM_CACHE)
-	create_cache(dep);
+        create_cache(dep);
 
     erts_smp_de_rwunlock(dep);
     dep = NULL; /* inc of refc transferred to port (dist_entry field) */
 
     send_nodes_mon_msgs(BIF_P,
-			am_nodeup,
-			BIF_ARG_1,
-			flags & DFLAG_PUBLISHED ? am_visible : am_hidden,
-			NIL);
- done:
+            am_nodeup,
+            BIF_ARG_1,
+            flags & DFLAG_PUBLISHED ? am_visible : am_hidden,
+                    NIL);
+    done:
 
     if (dep && dep != erts_this_dist_entry) {
-	erts_smp_de_rwunlock(dep);
-	erts_deref_dist_entry(dep);
+        erts_smp_de_rwunlock(dep);
+        erts_deref_dist_entry(dep);
     }
 
     if (pp)
-	erts_smp_port_unlock(pp);
+        erts_smp_port_unlock(pp);
 
     return ret;
 
- yield:
+    yield:
     ERTS_BIF_PREP_YIELD3(ret, bif_export[BIF_setnode_3], BIF_P,
-			 BIF_ARG_1, BIF_ARG_2, BIF_ARG_3);
+            BIF_ARG_1, BIF_ARG_2, BIF_ARG_3);
     goto done;
 
- badarg:
+    badarg:
     ERTS_BIF_PREP_ERROR(ret, BIF_P, BADARG);
     goto done;
 
- system_limit:
+    system_limit:
     ERTS_BIF_PREP_ERROR(ret, BIF_P, SYSTEM_LIMIT);
     goto done;
 }
@@ -2532,64 +2534,64 @@ BIF_RETTYPE dist_exit_3(BIF_ALIST_3)
 
     /* Check that remote is a remote process */
     if (is_not_external_pid(remote))
-	goto error;
+        goto error;
 
     rdep = external_dist_entry(remote);
-    
+
     if(rdep == erts_this_dist_entry)
-	goto error;
+        goto error;
 
     /* Check that local is local */
     if (is_internal_pid(local)) {
-	Process *lp;
-	ErtsProcLocks lp_locks;
-	if (BIF_P->id == local) {
-	    lp_locks = ERTS_PROC_LOCKS_ALL;
-	    lp = BIF_P;
-	    erts_smp_proc_lock(BIF_P, ERTS_PROC_LOCKS_ALL_MINOR);
-	}
-	else {
-	    lp_locks = ERTS_PROC_LOCKS_XSIG_SEND;
-	    lp = erts_pid2proc_opt(BIF_P, ERTS_PROC_LOCK_MAIN,
-				   local, lp_locks,
-				   ERTS_P2P_FLG_SMP_INC_REFC);
-	    if (!lp) {
-		BIF_RET(am_true); /* ignore */
-	    }
-	}
-	
-	(void) erts_send_exit_signal(BIF_P,
-				     remote,
-				     lp,
-				     &lp_locks,
-				     BIF_ARG_2,
-				     NIL,
-				     NULL,
-				     0);
+        Process *lp;
+        ErtsProcLocks lp_locks;
+        if (BIF_P->id == local) {
+            lp_locks = ERTS_PROC_LOCKS_ALL;
+            lp = BIF_P;
+            erts_smp_proc_lock(BIF_P, ERTS_PROC_LOCKS_ALL_MINOR);
+        }
+        else {
+            lp_locks = ERTS_PROC_LOCKS_XSIG_SEND;
+            lp = erts_pid2proc_opt(BIF_P, ERTS_PROC_LOCK_MAIN,
+                    local, lp_locks,
+                    ERTS_P2P_FLG_SMP_INC_REFC);
+            if (!lp) {
+                BIF_RET(am_true); /* ignore */
+            }
+        }
+
+        (void) erts_send_exit_signal(BIF_P,
+                remote,
+                lp,
+                &lp_locks,
+                BIF_ARG_2,
+                NIL,
+                NULL,
+                0);
 #ifdef ERTS_SMP
-	if (lp == BIF_P)
-	    lp_locks &= ~ERTS_PROC_LOCK_MAIN;
+        if (lp == BIF_P)
+            lp_locks &= ~ERTS_PROC_LOCK_MAIN;
 #endif
-	erts_smp_proc_unlock(lp, lp_locks);
-	if (lp != BIF_P)
-	    erts_smp_proc_dec_refc(lp);
-	else {
-	    /*
-	     * We may have exited current process and may have to take action.
-	     */
-	    ERTS_BIF_CHK_EXITED(BIF_P);
-	    ERTS_SMP_BIF_CHK_PENDING_EXIT(BIF_P, ERTS_PROC_LOCK_MAIN);
-	}
+        erts_smp_proc_unlock(lp, lp_locks);
+        if (lp != BIF_P)
+            erts_smp_proc_dec_refc(lp);
+        else {
+            /*
+             * We may have exited current process and may have to take action.
+             */
+            ERTS_BIF_CHK_EXITED(BIF_P);
+            ERTS_SMP_BIF_CHK_PENDING_EXIT(BIF_P, ERTS_PROC_LOCK_MAIN);
+        }
     }
     else if (is_external_pid(local)
-	     && external_dist_entry(local) == erts_this_dist_entry) {
-	BIF_RET(am_true); /* ignore */
+            && external_dist_entry(local) == erts_this_dist_entry) {
+        BIF_RET(am_true); /* ignore */
     }
     else
-	goto error;
+        goto error;
     BIF_RET(am_true);
 
- error:
+    error:
     BIF_ERROR(BIF_P, BADARG);
 }
 
@@ -2599,7 +2601,7 @@ BIF_RETTYPE dist_exit_3(BIF_ALIST_3)
 BIF_RETTYPE node_1(BIF_ALIST_1)
 { 
     if (is_not_node_container(BIF_ARG_1))
-      BIF_ERROR(BIF_P, BADARG);
+        BIF_ERROR(BIF_P, BADARG);
     BIF_RET(node_container_node_name(BIF_ARG_1));
 }
 
@@ -2618,7 +2620,7 @@ BIF_RETTYPE node_0(BIF_ALIST_0)
 #if 0 /* Done in erlang.erl instead. */
 BIF_RETTYPE nodes_0(BIF_ALIST_0)
 {
-  return nodes_1(BIF_P, am_visible);
+    return nodes_1(BIF_P, am_visible);
 }
 #endif
 
@@ -2642,22 +2644,22 @@ BIF_RETTYPE nodes_1(BIF_ALIST_1)
     UseTmpHeap(2,BIF_P);
 
     if (is_atom(BIF_ARG_1))
-      arg_list = CONS(buf, BIF_ARG_1, NIL);
+        arg_list = CONS(buf, BIF_ARG_1, NIL);
 
     while (is_list(arg_list)) {
-      switch(CAR(list_val(arg_list))) {
-      case am_visible:   visible = 1;                                 break;
-      case am_hidden:    hidden = 1;                                  break;
-      case am_known:     visible = hidden = not_connected = this = 1; break;
-      case am_this:      this = 1;                                    break;
-      case am_connected: visible = hidden = 1;                        break;
-      default:           goto error;                                  break;
-      }
-      arg_list = CDR(list_val(arg_list));
+        switch(CAR(list_val(arg_list))) {
+            case am_visible:   visible = 1;                                 break;
+            case am_hidden:    hidden = 1;                                  break;
+            case am_known:     visible = hidden = not_connected = this = 1; break;
+            case am_this:      this = 1;                                    break;
+            case am_connected: visible = hidden = 1;                        break;
+            default:           goto error;                                  break;
+        }
+        arg_list = CDR(list_val(arg_list));
     }
 
     if (is_not_nil(arg_list)) {
-	goto error;
+        goto error;
     }
 
     length = 0;
@@ -2668,19 +2670,19 @@ BIF_RETTYPE nodes_1(BIF_ALIST_1)
     ASSERT(erts_no_of_hidden_dist_entries >= 0);
     ASSERT(erts_no_of_visible_dist_entries >= 0);
     if(not_connected)
-      length += erts_no_of_not_connected_dist_entries;
+        length += erts_no_of_not_connected_dist_entries;
     if(hidden)
-      length += erts_no_of_hidden_dist_entries;
+        length += erts_no_of_hidden_dist_entries;
     if(visible)
-      length += erts_no_of_visible_dist_entries;
+        length += erts_no_of_visible_dist_entries;
     if(this)
-      length++;
+        length++;
 
     result = NIL;
 
     if (length == 0) {
-	erts_smp_rwmtx_rwunlock(&erts_dist_table_rwmtx);
-	goto done;
+        erts_smp_rwmtx_rwunlock(&erts_dist_table_rwmtx);
+        goto done;
     }
 
     hp = HAlloc(BIF_P, 2*length);
@@ -2689,32 +2691,32 @@ BIF_RETTYPE nodes_1(BIF_ALIST_1)
     endp = hp + length*2;
 #endif
     if(not_connected)
-      for(dep = erts_not_connected_dist_entries; dep; dep = dep->next) {
-	result = CONS(hp, dep->sysname, result);
-	hp += 2;
-      }
+        for(dep = erts_not_connected_dist_entries; dep; dep = dep->next) {
+            result = CONS(hp, dep->sysname, result);
+            hp += 2;
+        }
     if(hidden)
-      for(dep = erts_hidden_dist_entries; dep; dep = dep->next) {
-	result = CONS(hp, dep->sysname, result);
-	hp += 2;
-      }
+        for(dep = erts_hidden_dist_entries; dep; dep = dep->next) {
+            result = CONS(hp, dep->sysname, result);
+            hp += 2;
+        }
     if(visible)
-      for(dep = erts_visible_dist_entries; dep; dep = dep->next) {
-	result = CONS(hp, dep->sysname, result);
-	hp += 2;
-      }
+        for(dep = erts_visible_dist_entries; dep; dep = dep->next) {
+            result = CONS(hp, dep->sysname, result);
+            hp += 2;
+        }
     if(this) {
-	result = CONS(hp, erts_this_dist_entry->sysname, result);
-	hp += 2;
+        result = CONS(hp, erts_this_dist_entry->sysname, result);
+        hp += 2;
     }
     ASSERT(endp == hp);
     erts_smp_rwmtx_rwunlock(&erts_dist_table_rwmtx);
 
-done:
+    done:
     UnUseTmpHeap(2,BIF_P);
     BIF_RET(result);
 
-error:
+    error:
     UnUseTmpHeap(2,BIF_P);
     BIF_ERROR(BIF_P,BADARG);
 }
@@ -2739,69 +2741,69 @@ monitor_node(Process* p, Eterm Node, Eterm Bool, Eterm Options)
     Eterm l;
 
     for (l = Options; l != NIL && is_list(l); l = CDR(list_val(l))) {
-	Eterm t = CAR(list_val(l));
-	/* allow_passive_connect the only available option right now */
-	if (t != am_allow_passive_connect) {
-	    BIF_ERROR(p, BADARG);
-	}
+        Eterm t = CAR(list_val(l));
+        /* allow_passive_connect the only available option right now */
+        if (t != am_allow_passive_connect) {
+            BIF_ERROR(p, BADARG);
+        }
     }
     if (l != NIL) {
-	BIF_ERROR(p, BADARG);
+        BIF_ERROR(p, BADARG);
     }
 
     if (is_not_atom(Node) ||
-	((Bool != am_true) && (Bool != am_false)) ||
-	((erts_this_node->sysname == am_Noname)
-	 && (Node != erts_this_node->sysname))) {
-	BIF_ERROR(p, BADARG);
+            ((Bool != am_true) && (Bool != am_false)) ||
+            ((erts_this_node->sysname == am_Noname)
+                    && (Node != erts_this_node->sysname))) {
+        BIF_ERROR(p, BADARG);
     }
     dep = erts_sysname_to_connected_dist_entry(Node);
     if (!dep) {
-    do_trap:
-	BIF_TRAP3(dmonitor_node_trap, p, Node, Bool, Options);
+        do_trap:
+        BIF_TRAP3(dmonitor_node_trap, p, Node, Bool, Options);
     }
     if (dep == erts_this_dist_entry)
-	goto done;
+        goto done;
 
     erts_smp_proc_lock(p, ERTS_PROC_LOCK_LINK);
     erts_smp_de_rlock(dep);
     if (ERTS_DE_IS_NOT_CONNECTED(dep)) {
-	erts_smp_proc_unlock(p, ERTS_PROC_LOCK_LINK);
-	erts_smp_de_runlock(dep);
-	goto do_trap;
+        erts_smp_proc_unlock(p, ERTS_PROC_LOCK_LINK);
+        erts_smp_de_runlock(dep);
+        goto do_trap;
     }
     erts_smp_de_links_lock(dep);
     erts_smp_de_runlock(dep);
 
     if (Bool == am_true) {
-	ASSERT(dep->cid != NIL);
-	lnk = erts_add_or_lookup_link(&(dep->node_links), LINK_NODE, 
-				      p->id);
-	++ERTS_LINK_REFC(lnk);
-	lnk = erts_add_or_lookup_link(&(p->nlinks), LINK_NODE, Node);
-	++ERTS_LINK_REFC(lnk);
+        ASSERT(dep->cid != NIL);
+        lnk = erts_add_or_lookup_link(&(dep->node_links), LINK_NODE, 
+                p->id);
+        ++ERTS_LINK_REFC(lnk);
+        lnk = erts_add_or_lookup_link(&(p->nlinks), LINK_NODE, Node);
+        ++ERTS_LINK_REFC(lnk);
     }
     else  {
-	lnk = erts_lookup_link(dep->node_links, p->id);
-	if (lnk != NULL) {
-	    if ((--ERTS_LINK_REFC(lnk)) == 0) {
-		erts_destroy_link(erts_remove_link(&(dep->node_links), 
-						   p->id));
-	    }
-	}
-	lnk = erts_lookup_link(p->nlinks, Node);
-	if (lnk != NULL) {
-	    if ((--ERTS_LINK_REFC(lnk)) == 0) {
-		erts_destroy_link(erts_remove_link(&(p->nlinks),
-						   Node));
-	    }
-	}
+        lnk = erts_lookup_link(dep->node_links, p->id);
+        if (lnk != NULL) {
+            if ((--ERTS_LINK_REFC(lnk)) == 0) {
+                erts_destroy_link(erts_remove_link(&(dep->node_links), 
+                        p->id));
+            }
+        }
+        lnk = erts_lookup_link(p->nlinks, Node);
+        if (lnk != NULL) {
+            if ((--ERTS_LINK_REFC(lnk)) == 0) {
+                erts_destroy_link(erts_remove_link(&(p->nlinks),
+                        Node));
+            }
+        }
     }
 
     erts_smp_de_links_unlock(dep);
     erts_smp_proc_unlock(p, ERTS_PROC_LOCK_LINK);
 
- done:
+    done:
     erts_deref_dist_entry(dep);
     BIF_RET(am_true);
 }
@@ -2824,19 +2826,19 @@ BIF_RETTYPE net_kernel_dflag_unicode_io_1(BIF_ALIST_1)
     DistEntry *de;
     Uint32 f;
     if (is_not_pid(BIF_ARG_1)) {
-	BIF_ERROR(BIF_P,BADARG);
+        BIF_ERROR(BIF_P,BADARG);
     }
     de = pid_dist_entry(BIF_ARG_1);
     ASSERT(de != NULL);
     if (de == erts_this_dist_entry) {
-	BIF_RET(am_true);
+        BIF_RET(am_true);
     }
     erts_smp_de_rlock(de);
     f = de->flags;
     erts_smp_de_runlock(de);
     BIF_RET(((f & DFLAG_UNICODE_IO) ? am_true : am_false));
 }
-    
+
 /*
  * The major part of the implementation of net_kernel:monitor_nodes/[1,2]
  * follows.
@@ -2852,15 +2854,15 @@ BIF_RETTYPE net_kernel_dflag_unicode_io_1(BIF_ALIST_1)
 #define ERTS_NODES_MON_OPT_DOWN_REASON		(((Uint16) 1) << 2)
 
 #define ERTS_NODES_MON_OPT_TYPES \
-  (ERTS_NODES_MON_OPT_TYPE_VISIBLE|ERTS_NODES_MON_OPT_TYPE_HIDDEN)
+        (ERTS_NODES_MON_OPT_TYPE_VISIBLE|ERTS_NODES_MON_OPT_TYPE_HIDDEN)
 
 typedef struct ErtsNodesMonitor_ ErtsNodesMonitor;
 struct ErtsNodesMonitor_ {
-    ErtsNodesMonitor *prev;
-    ErtsNodesMonitor *next;
-    Process *proc;
-    Uint16 opts;
-    Uint16 no;
+        ErtsNodesMonitor *prev;
+        ErtsNodesMonitor *next;
+        Process *proc;
+        Uint16 opts;
+        Uint16 no;
 };
 
 static erts_smp_mtx_t nodes_monitors_mtx;
@@ -2891,35 +2893,35 @@ nodes_mon_msg_sz(ErtsNodesMonitor *nmp, Eterm what, Eterm reason)
 {
     Uint sz;
     if (!nmp->opts) {
-	sz = 3;
+        sz = 3;
     }
     else {
-	sz = 0;
+        sz = 0;
 
-	if (nmp->opts & ERTS_NODES_MON_OPT_TYPES)
-	    sz += 2 + 3;
+        if (nmp->opts & ERTS_NODES_MON_OPT_TYPES)
+            sz += 2 + 3;
 
-	if (what == am_nodedown
-	    && (nmp->opts & ERTS_NODES_MON_OPT_DOWN_REASON)) {
-	    if (is_not_immed(reason))
-		sz += size_object(reason);
-	    sz += 2 + 3;
-	}
+        if (what == am_nodedown
+                && (nmp->opts & ERTS_NODES_MON_OPT_DOWN_REASON)) {
+            if (is_not_immed(reason))
+                sz += size_object(reason);
+            sz += 2 + 3;
+        }
 
-	sz += 4;
+        sz += 4;
     }
     return sz;
 }
 
 static ERTS_INLINE void
 send_nodes_mon_msg(Process *rp,
-		   ErtsProcLocks *rp_locksp,
-		   ErtsNodesMonitor *nmp,
-		   Eterm node,
-		   Eterm what,
-		   Eterm type,
-		   Eterm reason,
-		   Uint sz)
+        ErtsProcLocks *rp_locksp,
+        ErtsNodesMonitor *nmp,
+        Eterm node,
+        Eterm what,
+        Eterm type,
+        Eterm reason,
+        Uint sz)
 {
     Eterm msg;
     ErlHeapFragment* bp;
@@ -2930,44 +2932,44 @@ send_nodes_mon_msg(Process *rp,
 #endif
 
     if (!nmp->opts) {
-	msg = TUPLE2(hp, what, node);
+        msg = TUPLE2(hp, what, node);
 #ifdef DEBUG
-	hp += 3;
+        hp += 3;
 #endif
     }
     else {
-	Eterm tup;
-	Eterm info = NIL;
-
-	if (nmp->opts & (ERTS_NODES_MON_OPT_TYPE_VISIBLE
-			 | ERTS_NODES_MON_OPT_TYPE_HIDDEN)) {
-
-	    tup = TUPLE2(hp, am_node_type, type);
-	    hp += 3;
-	    info = CONS(hp, tup, info);
-	    hp += 2;
-	}
-
-	if (what == am_nodedown
-	    && (nmp->opts & ERTS_NODES_MON_OPT_DOWN_REASON)) {
-	    Eterm rsn_cpy;
-	    
-	    if (is_immed(reason))
-		rsn_cpy = reason;
-	    else {
-		Eterm rsn_sz = size_object(reason);
-		rsn_cpy = copy_struct(reason, rsn_sz, &hp, ohp);
-	    }
-
-	    tup = TUPLE2(hp, am_nodedown_reason, rsn_cpy);
-	    hp += 3;
-	    info = CONS(hp, tup, info);
-	    hp += 2;
-	}
-
-	msg = TUPLE3(hp, what, node, info);
+        Eterm tup;
+        Eterm info = NIL;
+
+        if (nmp->opts & (ERTS_NODES_MON_OPT_TYPE_VISIBLE
+                | ERTS_NODES_MON_OPT_TYPE_HIDDEN)) {
+
+            tup = TUPLE2(hp, am_node_type, type);
+            hp += 3;
+            info = CONS(hp, tup, info);
+            hp += 2;
+        }
+
+        if (what == am_nodedown
+                && (nmp->opts & ERTS_NODES_MON_OPT_DOWN_REASON)) {
+            Eterm rsn_cpy;
+
+            if (is_immed(reason))
+                rsn_cpy = reason;
+            else {
+                Eterm rsn_sz = size_object(reason);
+                rsn_cpy = copy_struct(reason, rsn_sz, &hp, ohp);
+            }
+
+            tup = TUPLE2(hp, am_nodedown_reason, rsn_cpy);
+            hp += 3;
+            info = CONS(hp, tup, info);
+            hp += 2;
+        }
+
+        msg = TUPLE3(hp, what, node, info);
 #ifdef DEBUG
-	hp += 4;
+        hp += 4;
 #endif
     }
 
@@ -2987,69 +2989,69 @@ send_nodes_mon_msgs(Process *c_p, Eterm what, Eterm node, Eterm type, Eterm reas
     ASSERT(is_immed(type));
 
     ERTS_SMP_LC_ASSERT(!c_p
-		       || (erts_proc_lc_my_proc_locks(c_p)
-			   == ERTS_PROC_LOCK_MAIN));
+            || (erts_proc_lc_my_proc_locks(c_p)
+                    == ERTS_PROC_LOCK_MAIN));
     erts_smp_mtx_lock(&nodes_monitors_mtx);
 
     for (nmp = nodes_monitors; nmp; nmp = nmp->next) {
-	int i;
-	Uint16 no;
-	Uint sz;
-
-	ASSERT(nmp->proc != NULL);
-
-	if (!nmp->opts) {
-	    if (type != am_visible)
-		continue;
-	}
-	else {
-	    switch (type) {
-	    case am_hidden:
-		if (!(nmp->opts & ERTS_NODES_MON_OPT_TYPE_HIDDEN))
-		    continue;
-		break;
-	    case am_visible:
-		if ((nmp->opts & ERTS_NODES_MON_OPT_TYPES)
-		    && !(nmp->opts & ERTS_NODES_MON_OPT_TYPE_VISIBLE))
-		    continue;
-		break;
-	    default:
-		erl_exit(ERTS_ABORT_EXIT, "Bad node type found\n");
-	    }
-	}
-
-	if (rp != nmp->proc) {
-	    if (rp) {
-		if (rp == c_p)
-		    rp_locks &= ~ERTS_PROC_LOCK_MAIN;
-		erts_smp_proc_unlock(rp, rp_locks);
-	    }
-
-	    rp = nmp->proc;
-	    rp_locks = 0;
-	    if (rp == c_p)
-		rp_locks |= ERTS_PROC_LOCK_MAIN;
-	}
-
-	ASSERT(rp);
-
-	sz = nodes_mon_msg_sz(nmp, what, reason);
-
-	for (i = 0, no = nmp->no; i < no; i++)
-	    send_nodes_mon_msg(rp,
-			       &rp_locks,
-			       nmp,
-			       node,
-			       what,
-			       type,
-			       reason,
-			       sz);
+        int i;
+        Uint16 no;
+        Uint sz;
+
+        ASSERT(nmp->proc != NULL);
+
+        if (!nmp->opts) {
+            if (type != am_visible)
+                continue;
+        }
+        else {
+            switch (type) {
+                case am_hidden:
+                    if (!(nmp->opts & ERTS_NODES_MON_OPT_TYPE_HIDDEN))
+                        continue;
+                    break;
+                case am_visible:
+                    if ((nmp->opts & ERTS_NODES_MON_OPT_TYPES)
+                            && !(nmp->opts & ERTS_NODES_MON_OPT_TYPE_VISIBLE))
+                        continue;
+                    break;
+                default:
+                    erl_exit(ERTS_ABORT_EXIT, "Bad node type found\n");
+            }
+        }
+
+        if (rp != nmp->proc) {
+            if (rp) {
+                if (rp == c_p)
+                    rp_locks &= ~ERTS_PROC_LOCK_MAIN;
+                erts_smp_proc_unlock(rp, rp_locks);
+            }
+
+            rp = nmp->proc;
+            rp_locks = 0;
+            if (rp == c_p)
+                rp_locks |= ERTS_PROC_LOCK_MAIN;
+        }
+
+        ASSERT(rp);
+
+        sz = nodes_mon_msg_sz(nmp, what, reason);
+
+        for (i = 0, no = nmp->no; i < no; i++)
+            send_nodes_mon_msg(rp,
+                    &rp_locks,
+                    nmp,
+                    node,
+                    what,
+                    type,
+                    reason,
+                    sz);
     }
 
     if (rp) {
-	if (rp == c_p)
-	    rp_locks &= ~ERTS_PROC_LOCK_MAIN;
-	erts_smp_proc_unlock(rp, rp_locks);
+        if (rp == c_p)
+            rp_locks &= ~ERTS_PROC_LOCK_MAIN;
+        erts_smp_proc_unlock(rp, rp_locks);
     }
 
     erts_smp_mtx_unlock(&nodes_monitors_mtx);
@@ -3067,76 +3069,76 @@ insert_nodes_monitor(Process *c_p, Uint32 opts)
 
     xnmp = c_p->nodes_monitors;
     if (xnmp) {
-	ASSERT(!xnmp->prev || xnmp->prev->proc != c_p);
-
-	while (1) {
-	    ASSERT(xnmp->proc == c_p);
-	    if (xnmp->opts == opts)
-		break;
-	    if (!xnmp->next || xnmp->next->proc != c_p)
-		break;
-	    xnmp = xnmp->next;
-	}
-	ASSERT(xnmp);
-	ASSERT(xnmp->proc == c_p);
-	ASSERT(xnmp->opts == opts
-	       || !xnmp->next
-	       || xnmp->next->proc != c_p);
-
-	if (xnmp->opts != opts)
-	    goto alloc_new;
-	else {
-	    res = am_true;
-	    no = xnmp->no++;
-	    if (!xnmp->no) {
-		/*
-		 * 'no' wrapped; transfer all prevous monitors to new
-		 * element (which will be the next element in the list)
-		 * and set this to one...
-		 */
-		xnmp->no = 1;
-		goto alloc_new;
-	    }
-	}
+        ASSERT(!xnmp->prev || xnmp->prev->proc != c_p);
+
+        while (1) {
+            ASSERT(xnmp->proc == c_p);
+            if (xnmp->opts == opts)
+                break;
+            if (!xnmp->next || xnmp->next->proc != c_p)
+                break;
+            xnmp = xnmp->next;
+        }
+        ASSERT(xnmp);
+        ASSERT(xnmp->proc == c_p);
+        ASSERT(xnmp->opts == opts
+                || !xnmp->next
+                || xnmp->next->proc != c_p);
+
+        if (xnmp->opts != opts)
+            goto alloc_new;
+        else {
+            res = am_true;
+            no = xnmp->no++;
+            if (!xnmp->no) {
+                /*
+                 * 'no' wrapped; transfer all prevous monitors to new
+                 * element (which will be the next element in the list)
+                 * and set this to one...
+                 */
+                xnmp->no = 1;
+                goto alloc_new;
+            }
+        }
     }
     else {
-    alloc_new:
-	nmp = erts_alloc(ERTS_ALC_T_NODES_MON, sizeof(ErtsNodesMonitor));
-	nmp->proc = c_p;
-	nmp->opts = opts;
-	nmp->no = no;
-
-	if (xnmp) {
-	    ASSERT(nodes_monitors);
-	    ASSERT(c_p->nodes_monitors);
-	    nmp->next = xnmp->next;
-	    nmp->prev = xnmp;
-	    xnmp->next = nmp;
-	    if (nmp->next) {
-		ASSERT(nodes_monitors_end != xnmp);
-		ASSERT(nmp->next->prev == xnmp);
-		nmp->next->prev = nmp;
-	    }
-	    else {
-		ASSERT(nodes_monitors_end == xnmp);
-		nodes_monitors_end = nmp;
-	    }
-	}
-	else {
-	    ASSERT(!c_p->nodes_monitors);
-	    c_p->nodes_monitors = nmp;
-	    nmp->next = NULL;
-	    nmp->prev = nodes_monitors_end;
-	    if (nodes_monitors_end) {
-		ASSERT(nodes_monitors);
-		nodes_monitors_end->next = nmp;
-	    }
-	    else {
-		ASSERT(!nodes_monitors);
-		nodes_monitors = nmp;
-	    }
-	    nodes_monitors_end = nmp;
-	}
+        alloc_new:
+        nmp = erts_alloc(ERTS_ALC_T_NODES_MON, sizeof(ErtsNodesMonitor));
+        nmp->proc = c_p;
+        nmp->opts = opts;
+        nmp->no = no;
+
+        if (xnmp) {
+            ASSERT(nodes_monitors);
+            ASSERT(c_p->nodes_monitors);
+            nmp->next = xnmp->next;
+            nmp->prev = xnmp;
+            xnmp->next = nmp;
+            if (nmp->next) {
+                ASSERT(nodes_monitors_end != xnmp);
+                ASSERT(nmp->next->prev == xnmp);
+                nmp->next->prev = nmp;
+            }
+            else {
+                ASSERT(nodes_monitors_end == xnmp);
+                nodes_monitors_end = nmp;
+            }
+        }
+        else {
+            ASSERT(!c_p->nodes_monitors);
+            c_p->nodes_monitors = nmp;
+            nmp->next = NULL;
+            nmp->prev = nodes_monitors_end;
+            if (nodes_monitors_end) {
+                ASSERT(nodes_monitors);
+                nodes_monitors_end->next = nmp;
+            }
+            else {
+                ASSERT(!nodes_monitors);
+                nodes_monitors = nmp;
+            }
+            nodes_monitors_end = nmp;
+        }
     }
     return res;
 }
@@ -3154,35 +3156,35 @@ remove_nodes_monitors(Process *c_p, Uint32 opts, int all)
     ASSERT(!nmp || !nmp->prev || nmp->prev->proc != c_p);
 
     while (nmp && nmp->proc == c_p) {
-	if (!all && nmp->opts != opts)
-	    nmp = nmp->next;
-	else { /* if (all || nmp->opts == opts) */
-	    ErtsNodesMonitor *free_nmp;
-	    res = am_true;
-	    if (nmp->prev) {
-		ASSERT(nodes_monitors != nmp);
-		nmp->prev->next = nmp->next;
-	    }
-	    else {
-		ASSERT(nodes_monitors == nmp);
-		nodes_monitors = nmp->next;
-	    }
-	    if (nmp->next) {
-		ASSERT(nodes_monitors_end != nmp);
-		nmp->next->prev = nmp->prev;
-	    }
-	    else {
-		ASSERT(nodes_monitors_end == nmp);
-		nodes_monitors_end = nmp->prev;
-	    }
-	    free_nmp = nmp;
-	    nmp = nmp->next;
-	    if (c_p->nodes_monitors == free_nmp)
-		c_p->nodes_monitors = nmp && nmp->proc == c_p ? nmp : NULL;
-	    erts_free(ERTS_ALC_T_NODES_MON, free_nmp);
-	}
-    }
-    
+        if (!all && nmp->opts != opts)
+            nmp = nmp->next;
+        else { /* if (all || nmp->opts == opts) */
+            ErtsNodesMonitor *free_nmp;
+            res = am_true;
+            if (nmp->prev) {
+                ASSERT(nodes_monitors != nmp);
+                nmp->prev->next = nmp->next;
+            }
+            else {
+                ASSERT(nodes_monitors == nmp);
+                nodes_monitors = nmp->next;
+            }
+            if (nmp->next) {
+                ASSERT(nodes_monitors_end != nmp);
+                nmp->next->prev = nmp->prev;
+            }
+            else {
+                ASSERT(nodes_monitors_end == nmp);
+                nodes_monitors_end = nmp->prev;
+            }
+            free_nmp = nmp;
+            nmp = nmp->next;
+            if (c_p->nodes_monitors == free_nmp)
+                c_p->nodes_monitors = nmp && nmp->proc == c_p ? nmp : NULL;
+            erts_free(ERTS_ALC_T_NODES_MON, free_nmp);
+        }
+    }
+
     ASSERT(!all || !c_p->nodes_monitors);
     return res;
 }
@@ -3192,18 +3194,18 @@ erts_delete_nodes_monitors(Process *c_p, ErtsProcLocks locks)
 {
 #if defined(ERTS_ENABLE_LOCK_CHECK) && defined(ERTS_SMP)
     if (c_p) {
-	ErtsProcLocks might_unlock = locks & ~ERTS_PROC_LOCK_MAIN;
-	if (might_unlock)
-	    erts_proc_lc_might_unlock(c_p, might_unlock);
+        ErtsProcLocks might_unlock = locks & ~ERTS_PROC_LOCK_MAIN;
+        if (might_unlock)
+            erts_proc_lc_might_unlock(c_p, might_unlock);
     }
 #endif
     if (erts_smp_mtx_trylock(&nodes_monitors_mtx) == EBUSY) {
-	ErtsProcLocks unlock_locks = locks & ~ERTS_PROC_LOCK_MAIN;
-	if (c_p && unlock_locks)
-	    erts_smp_proc_unlock(c_p, unlock_locks);
-	erts_smp_mtx_lock(&nodes_monitors_mtx);
-	if (c_p && unlock_locks)
-	    erts_smp_proc_lock(c_p, unlock_locks);
+        ErtsProcLocks unlock_locks = locks & ~ERTS_PROC_LOCK_MAIN;
+        if (c_p && unlock_locks)
+            erts_smp_proc_unlock(c_p, unlock_locks);
+        erts_smp_mtx_lock(&nodes_monitors_mtx);
+        if (c_p && unlock_locks)
+            erts_smp_proc_lock(c_p, unlock_locks);
     }
     remove_nodes_monitors(c_p, 0, 1);
     erts_smp_mtx_unlock(&nodes_monitors_mtx);
@@ -3220,65 +3222,65 @@ erts_monitor_nodes(Process *c_p, Eterm on, Eterm olist)
     ERTS_SMP_LC_ASSERT(erts_proc_lc_my_proc_locks(c_p) == ERTS_PROC_LOCK_MAIN);
 
     if (on != am_true && on != am_false)
-	return THE_NON_VALUE;
+        return THE_NON_VALUE;
 
     if (is_not_nil(opts_list)) {
-	int all = 0, visible = 0, hidden = 0;
-
-	while (is_list(opts_list)) {
-	    Eterm *cp = list_val(opts_list);
-	    Eterm opt = CAR(cp);
-	    opts_list = CDR(cp);
-	    if (opt == am_nodedown_reason)
-		opts |= ERTS_NODES_MON_OPT_DOWN_REASON;
-	    else if (is_tuple(opt)) {
-		Eterm* tp = tuple_val(opt);
-		if (arityval(tp[0]) != 2)
-		    return THE_NON_VALUE;
-		switch (tp[1]) {
-		case am_node_type:
-		    switch (tp[2]) {
-		    case am_visible:
-			if (hidden || all)
-			    return THE_NON_VALUE;
-			opts |= ERTS_NODES_MON_OPT_TYPE_VISIBLE;
-			visible = 1;
-			break;
-		    case am_hidden:
-			if (visible || all)
-			    return THE_NON_VALUE;
-			opts |= ERTS_NODES_MON_OPT_TYPE_HIDDEN;
-			hidden = 1;
-			break;
-		    case am_all:
-			if (visible || hidden)
-			    return THE_NON_VALUE;
-			opts |= ERTS_NODES_MON_OPT_TYPES;
-			all = 1;
-			break;
-		    default:
-			return THE_NON_VALUE;
-		    }
-		    break;
-		default:
-		    return THE_NON_VALUE;
-		}
-	    }
-	    else {
-		return THE_NON_VALUE;
-	    }
-	}
-
-	if (is_not_nil(opts_list))
-	    return THE_NON_VALUE;
+        int all = 0, visible = 0, hidden = 0;
+
+        while (is_list(opts_list)) {
+            Eterm *cp = list_val(opts_list);
+            Eterm opt = CAR(cp);
+            opts_list = CDR(cp);
+            if (opt == am_nodedown_reason)
+                opts |= ERTS_NODES_MON_OPT_DOWN_REASON;
+            else if (is_tuple(opt)) {
+                Eterm* tp = tuple_val(opt);
+                if (arityval(tp[0]) != 2)
+                    return THE_NON_VALUE;
+                switch (tp[1]) {
+                    case am_node_type:
+                        switch (tp[2]) {
+                            case am_visible:
+                                if (hidden || all)
+                                    return THE_NON_VALUE;
+                                opts |= ERTS_NODES_MON_OPT_TYPE_VISIBLE;
+                                visible = 1;
+                                break;
+                            case am_hidden:
+                                if (visible || all)
+                                    return THE_NON_VALUE;
+                                opts |= ERTS_NODES_MON_OPT_TYPE_HIDDEN;
+                                hidden = 1;
+                                break;
+                            case am_all:
+                                if (visible || hidden)
+                                    return THE_NON_VALUE;
+                                opts |= ERTS_NODES_MON_OPT_TYPES;
+                                all = 1;
+                                break;
+                            default:
+                                return THE_NON_VALUE;
+                        }
+                        break;
+                            default:
+                                return THE_NON_VALUE;
+                }
+            }
+            else {
+                return THE_NON_VALUE;
+            }
+        }
+
+        if (is_not_nil(opts_list))
+            return THE_NON_VALUE;
     }
 
     erts_smp_mtx_lock(&nodes_monitors_mtx);
 
     if (on == am_true)
-	res = insert_nodes_monitor(c_p, opts);
+        res = insert_nodes_monitor(c_p, opts);
     else
-	res = remove_nodes_monitors(c_p, opts, 0);
+        res = remove_nodes_monitors(c_p, opts, 0);
 
     erts_smp_mtx_unlock(&nodes_monitors_mtx);
 
@@ -3310,45 +3312,45 @@ erts_processes_monitoring_nodes(Process *c_p)
     szp = &sz;
     hpp = NULL;
 
- bld_result:
+    bld_result:
     res = NIL;
 
     for (nmp = nodes_monitors_end; nmp; nmp = nmp->prev) {
-	Uint16 i;
-	for (i = 0; i < nmp->no; i++) {
-	    Eterm olist = NIL;
-	    if (nmp->opts & ERTS_NODES_MON_OPT_TYPES) {
-		Eterm type;
-		switch (nmp->opts & ERTS_NODES_MON_OPT_TYPES) {
-		case ERTS_NODES_MON_OPT_TYPES:        type = am_all;     break;
-		case ERTS_NODES_MON_OPT_TYPE_VISIBLE: type = am_visible; break;
-		case ERTS_NODES_MON_OPT_TYPE_HIDDEN:  type = am_hidden;  break;
-		default: erl_exit(ERTS_ABORT_EXIT, "Bad node type found\n");
-		}
-		olist = erts_bld_cons(hpp, szp, 
-				      erts_bld_tuple(hpp, szp, 2,
-						     am_node_type,
-						     type),
-				      olist);
-	    }
-	    if (nmp->opts & ERTS_NODES_MON_OPT_DOWN_REASON)
-		olist = erts_bld_cons(hpp, szp, am_nodedown_reason, olist);
-	    res = erts_bld_cons(hpp, szp,
-				erts_bld_tuple(hpp, szp, 2,
-					       nmp->proc->id,
-					       olist),
-				res);
-	}
+        Uint16 i;
+        for (i = 0; i < nmp->no; i++) {
+            Eterm olist = NIL;
+            if (nmp->opts & ERTS_NODES_MON_OPT_TYPES) {
+                Eterm type;
+                switch (nmp->opts & ERTS_NODES_MON_OPT_TYPES) {
+                    case ERTS_NODES_MON_OPT_TYPES:        type = am_all;     break;
+                    case ERTS_NODES_MON_OPT_TYPE_VISIBLE: type = am_visible; break;
+                    case ERTS_NODES_MON_OPT_TYPE_HIDDEN:  type = am_hidden;  break;
+                    default: erl_exit(ERTS_ABORT_EXIT, "Bad node type found\n");
+                }
+                olist = erts_bld_cons(hpp, szp, 
+                        erts_bld_tuple(hpp, szp, 2,
+                                am_node_type,
+                                type),
+                                olist);
+            }
+            if (nmp->opts & ERTS_NODES_MON_OPT_DOWN_REASON)
+                olist = erts_bld_cons(hpp, szp, am_nodedown_reason, olist);
+            res = erts_bld_cons(hpp, szp,
+                    erts_bld_tuple(hpp, szp, 2,
+                            nmp->proc->id,
+                            olist),
+                            res);
+        }
     }
 
     if (!hpp) {
-	hp = HAlloc(c_p, sz);
+        hp = HAlloc(c_p, sz);
 #ifdef DEBUG
-	hend = hp + sz;
+        hend = hp + sz;
 #endif
-	hpp = &hp;
-	szp = NULL;
-	goto bld_result;
+        hpp = &hp;
+        szp = NULL;
+        goto bld_result;
     }
 
     ASSERT(hp == hend);
diff --git a/erts/emulator/beam/pexport.c b/erts/emulator/beam/pexport.c
new file mode 100644
index 0000000..4df5735
--- /dev/null
+++ b/erts/emulator/beam/pexport.c
@@ -0,0 +1,643 @@
+/*
+ * %CopyrightBegin%
+ *
+ * Copyright Ericsson AB 1996-2010. All Rights Reserved.
+ *
+ * The contents of this file are subject to the Erlang Public License,
+ * Version 1.1, (the "License"); you may not use this file except in
+ * compliance with the License. You should have received a copy of the
+ * Erlang Public License along with this software. If not, it can be
+ * retrieved online at http://www.erlang.org/.
+ *
+ * Software distributed under the License is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
+ * the License for the specific language governing rights and limitations
+ * under the License.
+ *
+ * %CopyrightEnd%
+ */
+
+/*
+ * Manage registered processes.
+ */
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#include "sys.h"
+#include "erl_vm.h"
+#include "global.h"
+#include "hash.h"
+#include "atom.h"
+#include "register.h"
+
+static Hash process_exp;
+
+#define PEXP_HASH_SIZE 10
+
+#define EXP_HASH(term) ((HashValue) atom_val(term))
+
+static erts_smp_rwmtx_t exptab_rwmtx;
+
+#define exp_try_read_lock()		erts_smp_rwmtx_tryrlock(&exptab_rwmtx)
+#define exp_try_write_lock()		erts_smp_rwmtx_tryrwlock(&exptab_rwmtx)
+#define exp_read_lock()			erts_smp_rwmtx_rlock(&exptab_rwmtx)
+#define exp_write_lock()		erts_smp_rwmtx_rwlock(&exptab_rwmtx)
+#define exp_read_unlock()		erts_smp_rwmtx_runlock(&exptab_rwmtx)
+#define exp_write_unlock()		erts_smp_rwmtx_rwunlock(&exptab_rwmtx)
+
+#ifdef ERTS_SMP
+static ERTS_INLINE void
+exp_safe_read_lock(Process *c_p, ErtsProcLocks *c_p_locks)
+{
+    if (*c_p_locks) {
+	ASSERT(c_p);
+	ASSERT(c_p_locks);
+	ASSERT(*c_p_locks);
+
+	if (exp_try_read_lock() != EBUSY) {
+#ifdef ERTS_ENABLE_LOCK_CHECK
+	    erts_proc_lc_might_unlock(c_p, *c_p_locks);
+#endif
+	    return;
+	}
+
+	/* Release process locks in order to avoid deadlock */
+	erts_smp_proc_unlock(c_p, *c_p_locks);
+	*c_p_locks = 0;
+    }
+
+    exp_read_lock();
+}
+
+static ERTS_INLINE void
+exp_safe_write_lock(Process *c_p, ErtsProcLocks *c_p_locks)
+{
+    if (*c_p_locks) {
+	ASSERT(c_p);
+	ASSERT(c_p_locks);
+	ASSERT(*c_p_locks);
+
+	if (exp_try_write_lock() != EBUSY) {
+#ifdef ERTS_ENABLE_LOCK_CHECK
+	    erts_proc_lc_might_unlock(c_p, *c_p_locks);
+#endif
+	    return;
+	}
+
+	/* Release process locks in order to avoid deadlock */
+	erts_smp_proc_unlock(c_p, *c_p_locks);
+	*c_p_locks = 0;
+    }
+
+    exp_write_lock();
+}
+
+static ERTS_INLINE int
+is_proc_alive(Process *p)
+{
+    int res;
+    erts_pix_lock_t *pixlck = ERTS_PID2PIXLOCK(p->id);
+    erts_pix_lock(pixlck);
+    res = !p->is_exiting;
+    erts_pix_unlock(pixlck);
+    return res;
+}
+
+#endif
+
+static HashValue exp_hash(ExpProc* obj)
+{
+    if (obj->p == NULL) EXP_HASH(obj->name);
+    else EXP_HASH(obj->p);
+}
+
+static int exp_cmp(ExpProc *tmpl, ExpProc *obj) {
+    return tmpl->name != obj->name;
+}
+
+static ExpProc* exp_alloc(ExpProc *tmpl)
+{
+    ExpProc* obj = (ExpProc*) erts_alloc(ERTS_ALC_T_REG_PROC, sizeof(ExpProc));
+    if (!obj) {
+	erl_exit(1, "Can't allocate %d bytes of memory\n", sizeof(ExpProc));
+    }
+    obj->name = tmpl->name;
+    obj->p = tmpl->p;
+    return obj;
+}
+
+static void exp_free(ExpProc *obj)
+{
+    erts_free(ERTS_ALC_T_REG_PROC, (void*) obj);
+}
+
+void init_register_table(void)
+{
+    HashFunctions f;
+    erts_smp_rwmtx_opt_t rwmtx_opt = ERTS_SMP_RWMTX_OPT_DEFAULT_INITER;
+    rwmtx_opt.type = ERTS_SMP_RWMTX_TYPE_FREQUENT_READ;
+    rwmtx_opt.lived = ERTS_SMP_RWMTX_LONG_LIVED;
+
+    erts_smp_rwmtx_init_opt(&exptab_rwmtx, &rwmtx_opt, "exp_tab");
+
+    f.hash = (H_FUN) exp_hash;
+    f.cmp  = (HCMP_FUN) exp_cmp;
+    f.alloc = (HALLOC_FUN) exp_alloc;
+    f.free = (HFREE_FUN) exp_free;
+
+    hash_init(ERTS_ALC_T_REG_TABLE, &process_exp, "process_exp",
+	      PREG_HASH_SIZE, f);
+}
+
+int erts_export_name(Process *c_p, Eterm name, Eterm id)
+{
+    int res = 0;
+    Process *proc = NULL;
+    ExpProc r, *rp;
+    ERTS_SMP_CHK_HAVE_ONLY_MAIN_PROC_LOCK(c_p);
+
+    if ((is_not_atom(name) || name == am_undefined) && is_not_internal_pid(id))
+	return res;
+
+    if (c_p->id == id) /* A very common case I think... */
+	proc = c_p;
+    else {
+	erts_smp_proc_unlock(c_p, ERTS_PROC_LOCK_MAIN);
+    }
+
+#ifdef ERTS_SMP
+    {
+	ErtsProcLocks proc_locks = proc ? ERTS_PROC_LOCK_MAIN : 0;
+	exp_safe_write_lock(proc, &proc_locks);
+
+	if (proc && !proc_locks)
+	    erts_smp_proc_lock(c_p, ERTS_PROC_LOCK_MAIN);
+    }
+#endif
+
+    if (is_internal_pid(id)) {
+	if (!proc)
+	    proc = erts_pid2proc(NULL, 0, id, ERTS_PROC_LOCK_MAIN);
+	r.p = proc;
+	if (!proc)
+	    goto done;
+	if (proc->exp)
+	    goto done;
+	r.pt = NULL;
+    }
+    else {
+	ASSERT(!INVALID_PORT(port, id));
+	ERTS_SMP_LC_ASSERT(erts_lc_is_port_locked(port));
+	r.pt = port;
+	if (r.pt->exp)
+	    goto done;
+	r.p = NULL;
+    }
+
+    r.name = name;
+    
+    rp = (ExpProc*) hash_put(&process_exp, (void*) &r);
+    if (proc && rp->p == proc) {
+	if (IS_TRACED_FL(proc, F_TRACE_PROCS)) {
+	    trace_proc(c_p, proc, am_register, name);
+	}
+	proc->exp = rp;
+    }
+    else if (port && rp->pt == port) {
+    	if (IS_TRACED_FL(port, F_TRACE_PORTS)) {
+		trace_port(port, am_register, name);
+	}
+	port->exp = rp;
+    }
+
+    if ((rp->p && rp->p->id == id) || (rp->pt && rp->pt->id == id)) {
+	res = 1;
+    }
+
+ done:
+    exp_write_unlock();
+    if (port)
+	erts_smp_port_unlock(port);
+    if (c_p != proc) {
+	if (proc)
+	    erts_smp_proc_unlock(proc, ERTS_PROC_LOCK_MAIN);
+	erts_smp_proc_lock(c_p, ERTS_PROC_LOCK_MAIN);
+    }
+    return res;
+}
+
+/*
+ *
+ * When smp support is enabled:
+ *   * Assumes that main lock is locked (and only main lock)
+ *     on c_p.
+ *
+ *   * am_undefined is returned if c_p became exiting.
+ */
+
+Eterm
+erts_whereis_name_to_id(Process *c_p, Eterm name)
+{
+    Eterm res = am_undefined;
+    HashValue hval;
+    int ix;
+    HashBucket* b;
+#ifdef ERTS_SMP
+    ErtsProcLocks c_p_locks = c_p ? ERTS_PROC_LOCK_MAIN : 0;
+
+    ERTS_SMP_CHK_HAVE_ONLY_MAIN_PROC_LOCK(c_p);
+    exp_safe_read_lock(c_p, &c_p_locks);
+    if (c_p && !c_p_locks)
+        erts_smp_proc_lock(c_p, ERTS_PROC_LOCK_MAIN);
+#endif
+
+    hval = REG_HASH(name);
+    ix = hval % process_exp.size;
+    b = process_exp.bucket[ix];
+
+    /*
+     * Note: We have inlined the code from hash.c for speed.
+     */
+	
+    while (b) {
+	ExpProc* rp = (ExpProc *) b;
+	if (rp->name == name) {
+	    /*
+	     * SMP NOTE: No need to lock registered entity since it cannot
+	     * be removed without acquiring write reg lock and id on entity
+	     * is read only.
+	     */
+	    if (rp->p)
+		res = rp->p->id;
+	    else if (rp->pt)
+		res = rp->pt->id;
+	    break;
+	}
+	b = b->next;
+    }
+
+    exp_read_unlock();
+
+    ASSERT(is_internal_pid(res) || is_internal_port(res) || res==am_undefined);
+
+    return res;
+}
+
+
+void
+erts_whereis_name(Process *c_p,
+		  ErtsProcLocks c_p_locks,
+		  Eterm name,
+		  Process** proc,
+		  ErtsProcLocks need_locks,
+		  int flags,
+		  Port** port)
+{
+    ExpProc* rp = NULL;
+    HashValue hval;
+    int ix;
+    HashBucket* b;
+#ifdef ERTS_SMP
+    ErtsProcLocks current_c_p_locks;
+    Port *pending_port = NULL;
+
+    if (!c_p)
+	c_p_locks = 0;
+    current_c_p_locks = c_p_locks;
+
+ restart:
+
+    exp_safe_read_lock(c_p, &current_c_p_locks);
+
+    /* Locked locks:
+     * - port lock on pending_port if pending_port != NULL
+     * - read reg lock
+     * - current_c_p_locks (either c_p_locks or 0) on c_p
+     */
+#endif
+
+    hval = REG_HASH(name);
+    ix = hval % process_exp.size;
+    b = process_exp.bucket[ix];
+
+    /*
+     * Note: We have inlined the code from hash.c for speed.
+     */
+
+    while (b) {
+	if (((ExpProc *) b)->name == name) {
+	    rp = (ExpProc *) b;
+	    break;
+	}
+	b = b->next;
+    }
+
+    if (proc) {
+	if (!rp)
+	    *proc = NULL;
+	else {
+#ifdef ERTS_SMP
+	    if (!rp->p)
+		*proc = NULL;
+	    else {
+		if (need_locks) {
+		    erts_proc_safelock(c_p,
+				       current_c_p_locks,
+				       c_p_locks,
+				       rp->p,
+				       0,
+				       need_locks);
+		    current_c_p_locks = c_p_locks;
+		}
+		if ((flags & ERTS_P2P_FLG_ALLOW_OTHER_X) || is_proc_alive(rp->p))
+		    *proc = rp->p;
+		else {
+		    if (need_locks)
+			erts_smp_proc_unlock(rp->p, need_locks);
+		    *proc = NULL;
+		}
+		if (*proc && (flags & ERTS_P2P_FLG_SMP_INC_REFC))
+		    erts_smp_proc_inc_refc(rp->p);
+	    }
+#else
+	    if (rp->p
+		&& ((flags & ERTS_P2P_FLG_ALLOW_OTHER_X)
+		    || rp->p->status != P_EXITING))
+		*proc = rp->p;
+	    else
+		*proc = NULL;
+#endif
+	}
+    }
+
+    if (port) {
+	if (!rp || !rp->pt)
+	    *port = NULL;
+	else {
+#ifdef ERTS_SMP
+	    if (pending_port == rp->pt)
+		pending_port = NULL;
+	    else {
+		if (pending_port) {
+		    /* Ahh! Registered port changed while reg lock
+		       was unlocked... */
+		    erts_smp_port_unlock(pending_port);
+		    pending_port = NULL;
+		}
+		    
+		if (erts_smp_port_trylock(rp->pt) == EBUSY) {
+		    Eterm id = rp->pt->id; /* id read only... */
+		    /* Unlock all locks, acquire port lock, and restart... */
+		    if (current_c_p_locks) {
+			erts_smp_proc_unlock(c_p, current_c_p_locks);
+			current_c_p_locks = 0;
+		    }
+		    exp_read_unlock();
+		    pending_port = erts_id2port(id, NULL, 0);
+		    goto restart;
+		}
+	    }
+#endif
+	    *port = rp->pt;
+	    ERTS_SMP_LC_ASSERT(erts_lc_is_port_locked(*port));
+	}
+    }
+
+#ifdef ERTS_SMP
+    if (c_p && !current_c_p_locks)
+	erts_smp_proc_lock(c_p, c_p_locks);
+    if (pending_port)
+	erts_smp_port_unlock(pending_port);
+#endif
+
+    exp_read_unlock();
+}
+
+Process *
+erts_whereis_process(Process *c_p,
+		     ErtsProcLocks c_p_locks,
+		     Eterm name,
+		     ErtsProcLocks need_locks,
+		     int flags)
+{
+    Process *proc;
+    erts_whereis_name(c_p, c_p_locks, name, &proc, need_locks, flags, NULL);
+    return proc;
+}
+
+
+/*
+ * Unregister a name
+ * Return 0 if not registered
+ * Otherwise returns 1
+ *
+ */
+int erts_unregister_name(Process *c_p,
+			 ErtsProcLocks c_p_locks,
+			 Port *c_prt,
+			 Eterm name)
+{
+    int res = 0;
+    ExpProc r, *rp;
+    Port *port = c_prt;
+#ifdef ERTS_SMP
+    ErtsProcLocks current_c_p_locks;
+
+    /*
+     * SMP note: If 'c_prt != NULL' and 'c_prt->reg->name == name',
+     *           we are *not* allowed to temporarily release the lock
+     *           on c_prt.
+     */
+
+    if (!c_p) {
+	c_p_locks = 0;
+    }
+    current_c_p_locks = c_p_locks;
+
+ restart:
+
+    exp_safe_write_lock(c_p, &current_c_p_locks);
+#endif
+
+    r.name = name;
+    if (is_non_value(name)) {
+	/* Unregister current process name */
+	ASSERT(c_p);
+#ifdef ERTS_SMP
+	if (current_c_p_locks != c_p_locks) {
+	    erts_smp_proc_lock(c_p, c_p_locks);
+	    current_c_p_locks = c_p_locks;
+	}
+#endif
+	if (c_p->exp) {
+	    r.name = c_p->exp->name;
+	} else {
+	    /* Name got unregistered while main lock was released */
+	    res = 0;
+	    goto done;
+	}
+    }
+
+    if ((rp = (ExpProc*) hash_get(&process_exp, (void*) &r)) != NULL) {
+	if (rp->pt) {
+	    if (port != rp->pt) {
+#ifdef ERTS_SMP
+		if (port) {
+		    ERTS_SMP_LC_ASSERT(port != c_prt);
+		    erts_smp_port_unlock(port);
+		    port = NULL;
+		}
+
+		if (erts_smp_port_trylock(rp->pt) == EBUSY) {
+		    Eterm id = rp->pt->id; /* id read only... */
+		    /* Unlock all locks, acquire port lock, and restart... */
+		    if (current_c_p_locks) {
+			erts_smp_proc_unlock(c_p, current_c_p_locks);
+			current_c_p_locks = 0;
+		    }
+		    exp_write_unlock();
+		    port = erts_id2port(id, NULL, 0);
+		    goto restart;
+		}
+#endif
+		port = rp->pt;
+	    }
+
+	    ASSERT(rp->pt == port);
+	    ERTS_SMP_LC_ASSERT(erts_lc_is_port_locked(port));
+
+	    rp->pt->exp = NULL;
+	    
+	    if (IS_TRACED_FL(port, F_TRACE_PORTS)) {
+		trace_port(port, am_unregister, r.name);
+	    }
+
+	} else if (rp->p) {
+
+#ifdef ERTS_SMP
+	    erts_proc_safelock(c_p,
+			       current_c_p_locks,
+			       c_p_locks,
+			       rp->p,
+			       (c_p == rp->p) ?  current_c_p_locks : 0,
+			       ERTS_PROC_LOCK_MAIN);
+	    current_c_p_locks = c_p_locks;
+#endif
+	    rp->p->exp = NULL;
+	    if (IS_TRACED_FL(rp->p, F_TRACE_PROCS)) {
+		trace_proc(c_p, rp->p, am_unregister, r.name);
+	    }
+#ifdef ERTS_SMP
+	    if (rp->p != c_p) {
+		erts_smp_proc_unlock(rp->p, ERTS_PROC_LOCK_MAIN);
+	    }
+#endif
+	}
+	hash_erase(&process_exp, (void*) &r);
+	res = 1;
+    }
+
+ done:
+
+    exp_write_unlock();
+    if (c_prt != port) {
+	if (port) {
+	    erts_smp_port_unlock(port);
+	}
+	if (c_prt) {
+	    erts_smp_port_lock(c_prt);
+	}
+    }
+#ifdef ERTS_SMP
+    if (c_p && !current_c_p_locks) {
+	erts_smp_proc_lock(c_p, c_p_locks);
+    }
+#endif
+    return res;
+}
+
+int process_exp_size(void)
+{
+    int size;
+    int lock = !ERTS_IS_CRASH_DUMPING;
+    if (lock)
+	exp_read_lock();
+    size = process_exp.size;
+    if (lock)
+	exp_read_unlock();
+    return size;
+}
+
+int process_exp_sz(void)
+{
+    int sz;
+    int lock = !ERTS_IS_CRASH_DUMPING;
+    if (lock)
+	exp_read_lock();
+    sz = hash_table_sz(&process_exp);
+    if (lock)
+	exp_read_unlock();
+    return sz;
+}
+
+/**********************************************************************/
+
+#include "bif.h"
+
+/* return a list of the registered processes */
+
+BIF_RETTYPE registered_0(BIF_ALIST_0)
+{
+    int i;
+    Eterm res;
+    Uint need;
+    Eterm* hp;
+    HashBucket **bucket;
+#ifdef ERTS_SMP
+    ErtsProcLocks proc_locks = ERTS_PROC_LOCK_MAIN;
+
+    ERTS_SMP_CHK_HAVE_ONLY_MAIN_PROC_LOCK(BIF_P);
+    exp_safe_read_lock(BIF_P, &proc_locks);
+    if (!proc_locks)
+	erts_smp_proc_lock(BIF_P, ERTS_PROC_LOCK_MAIN);
+#endif
+
+    bucket = process_exp.bucket;
+
+    /* work out how much heap we need & maybe garb, by scanning through
+       the registered process table */
+    need = 0;
+    for (i = 0; i < process_exp.size; i++) {
+	HashBucket *b = bucket[i];
+	while (b != NULL) {
+	    need += 2;
+	    b = b->next;
+	}
+    }
+
+    if (need == 0) {
+	exp_read_unlock();
+	BIF_RET(NIL);
+    }
+
+    hp = HAlloc(BIF_P, need);
+     
+     /* scan through again and make the list */ 
+    res = NIL;
+
+    for (i = 0; i < process_exp.size; i++) {
+	HashBucket *b = bucket[i];
+	while (b != NULL) {
+	    ExpProc *exp = (ExpProc *) b;
+
+	    res = CONS(hp, exp->name, res);
+	    hp += 2;
+	    b = b->next;
+	}
+    }
+
+    exp_read_unlock();
+
+    BIF_RET(res);
+}
diff --git a/erts/emulator/beam/pexport.h b/erts/emulator/beam/pexport.h
new file mode 100644
index 0000000..817c064
--- /dev/null
+++ b/erts/emulator/beam/pexport.h
@@ -0,0 +1,52 @@
+/*
+ * %CopyrightBegin%
+ * 
+ * Copyright Ericsson AB 1996-2009. All Rights Reserved.
+ * 
+ * The contents of this file are subject to the Erlang Public License,
+ * Version 1.1, (the "License"); you may not use this file except in
+ * compliance with the License. You should have received a copy of the
+ * Erlang Public License along with this software. If not, it can be
+ * retrieved online at http://www.erlang.org/.
+ * 
+ * Software distributed under the License is distributed on an "AS IS"
+ * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
+ * the License for the specific language governing rights and limitations
+ * under the License.
+ * 
+ * %CopyrightEnd%
+ */
+
+/*
+** Exported processes
+*/
+
+#ifndef __PEXPORT_H__
+#define __PEXPORT_H__
+
+#ifndef __SYS_H__
+#include "sys.h"
+#endif
+
+#ifndef __HASH_H__
+#include "hash.h"
+#endif
+
+#ifndef __PROCESS_H__
+#include "erl_process.h"
+#endif
+
+typedef struct exp_proc
+{
+    HashBucket bucket;  /* MUST BE LOCATED AT TOP OF STRUCT!!! */
+    Process *p;         /* The process registerd (only one of this and  'pt' is non-NULL */
+    Eterm name;         /* Atom name */
+} ExpProc;
+
+int process_exp_size(void);
+void init_export_table(void);
+int erts_export_process(Process *, Eterm, Eterm);
+int erts_unexport_process(Process *, Eterm);
+int erts_is_exported(Process *, Eterm);
+
+#endif
-- 
1.7.10.4


From bc3d95fd077a1cb309428905497b7438c6f5c0c9 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Sun, 6 May 2012 18:39:55 +0200
Subject: [PATCH 06/67] First draft of export module done.

---
 erts/emulator/beam/bif.c         |   12 +-
 erts/emulator/beam/erl_process.h |    1 +
 erts/emulator/beam/pexport.c     |  457 ++++++++++++++------------------------
 erts/emulator/beam/pexport.h     |   11 +-
 4 files changed, 171 insertions(+), 310 deletions(-)

diff --git a/erts/emulator/beam/bif.c b/erts/emulator/beam/bif.c
index 9f1aec9..a862f12 100644
--- a/erts/emulator/beam/bif.c
+++ b/erts/emulator/beam/bif.c
@@ -36,6 +36,7 @@
 #include "beam_bp.h"
 #include "erl_db_util.h"
 #include "register.h"
+#include "pexport.h"
 #include "erl_thr_progress.h"
 
 static Export* flush_monitor_message_trap = NULL;
@@ -4592,14 +4593,3 @@ BIF_RETTYPE unexport_1(BIF_ALIST_1)
 }
 
 /**********************************************************************/
-
-/* list all exported processes */
-
-BIF_RETTYPE exported_0(BIF_ALIST_0)
-{
-    Eterm* hp = HAlloc(BIF_P, 2);
-    erts_printf("DEBUG: Listing exported processes\n");
-    BIF_RET(CONS(hp, NIL, NIL));
-}
-
-/**********************************************************************/
diff --git a/erts/emulator/beam/erl_process.h b/erts/emulator/beam/erl_process.h
index a51b380..7e4ae31 100644
--- a/erts/emulator/beam/erl_process.h
+++ b/erts/emulator/beam/erl_process.h
@@ -650,6 +650,7 @@ struct process {
     Process *prev;		/* Pointer to prev process in run queue */
 
     struct reg_proc *reg;	/* NULL iff not registered */
+    struct exp_proc *exp; /* NULL iff not exported */
     ErtsLink *nlinks;
     ErtsMonitor *monitors;      /* The process monitors, both ends */
 
diff --git a/erts/emulator/beam/pexport.c b/erts/emulator/beam/pexport.c
index 4df5735..1cf59aa 100644
--- a/erts/emulator/beam/pexport.c
+++ b/erts/emulator/beam/pexport.c
@@ -108,12 +108,12 @@ is_proc_alive(Process *p)
 
 static HashValue exp_hash(ExpProc* obj)
 {
-    if (obj->p == NULL) EXP_HASH(obj->name);
-    else EXP_HASH(obj->p);
+    if (obj->pid == am_undefined) return EXP_HASH(obj->name);
+    else return EXP_HASH(obj->pid);
 }
 
 static int exp_cmp(ExpProc *tmpl, ExpProc *obj) {
-    return tmpl->name != obj->name;
+    return tmpl->name != obj->name && tmpl->pid != obj->pid;
 }
 
 static ExpProc* exp_alloc(ExpProc *tmpl)
@@ -123,7 +123,7 @@ static ExpProc* exp_alloc(ExpProc *tmpl)
 	erl_exit(1, "Can't allocate %d bytes of memory\n", sizeof(ExpProc));
     }
     obj->name = tmpl->name;
-    obj->p = tmpl->p;
+    obj->pid = tmpl->pid;
     return obj;
 }
 
@@ -150,21 +150,17 @@ void init_register_table(void)
 	      PREG_HASH_SIZE, f);
 }
 
-int erts_export_name(Process *c_p, Eterm name, Eterm id)
+int erts_export_process_by_name(Process *c_p, Eterm name)
 {
     int res = 0;
     Process *proc = NULL;
     ExpProc r, *rp;
     ERTS_SMP_CHK_HAVE_ONLY_MAIN_PROC_LOCK(c_p);
 
-    if ((is_not_atom(name) || name == am_undefined) && is_not_internal_pid(id))
+    if ((is_not_atom(name) || name == am_undefined))
 	return res;
-
-    if (c_p->id == id) /* A very common case I think... */
-	proc = c_p;
-    else {
+    
 	erts_smp_proc_unlock(c_p, ERTS_PROC_LOCK_MAIN);
-    }
 
 #ifdef ERTS_SMP
     {
@@ -176,267 +172,94 @@ int erts_export_name(Process *c_p, Eterm name, Eterm id)
     }
 #endif
 
-    if (is_internal_pid(id)) {
-	if (!proc)
-	    proc = erts_pid2proc(NULL, 0, id, ERTS_PROC_LOCK_MAIN);
-	r.p = proc;
-	if (!proc)
-	    goto done;
-	if (proc->exp)
-	    goto done;
-	r.pt = NULL;
-    }
-    else {
-	ASSERT(!INVALID_PORT(port, id));
-	ERTS_SMP_LC_ASSERT(erts_lc_is_port_locked(port));
-	r.pt = port;
-	if (r.pt->exp)
-	    goto done;
-	r.p = NULL;
-    }
-
     r.name = name;
+    r.pid = am_undefined;
+    if (!proc)
+        goto done;
+    if (proc->exp)
+        goto done;
+    }
     
     rp = (ExpProc*) hash_put(&process_exp, (void*) &r);
     if (proc && rp->p == proc) {
-	if (IS_TRACED_FL(proc, F_TRACE_PROCS)) {
-	    trace_proc(c_p, proc, am_register, name);
-	}
-	proc->exp = rp;
-    }
-    else if (port && rp->pt == port) {
-    	if (IS_TRACED_FL(port, F_TRACE_PORTS)) {
-		trace_port(port, am_register, name);
-	}
-	port->exp = rp;
+    proc->exp = rp;
     }
 
-    if ((rp->p && rp->p->id == id) || (rp->pt && rp->pt->id == id)) {
-	res = 1;
+    if ((rp->p && rp->p->id == id)) {
+    res = 1;
     }
 
- done:
-    exp_write_unlock();
-    if (port)
-	erts_smp_port_unlock(port);
-    if (c_p != proc) {
-	if (proc)
-	    erts_smp_proc_unlock(proc, ERTS_PROC_LOCK_MAIN);
-	erts_smp_proc_lock(c_p, ERTS_PROC_LOCK_MAIN);
-    }
-    return res;
+    done:
+       exp_write_unlock();
+       if (c_p != proc) {
+       if (proc)
+           erts_smp_proc_unlock(proc, ERTS_PROC_LOCK_MAIN);
+       erts_smp_proc_lock(c_p, ERTS_PROC_LOCK_MAIN);
+       }
+       return res;
 }
 
-/*
- *
- * When smp support is enabled:
- *   * Assumes that main lock is locked (and only main lock)
- *     on c_p.
- *
- *   * am_undefined is returned if c_p became exiting.
- */
-
-Eterm
-erts_whereis_name_to_id(Process *c_p, Eterm name)
+int erts_export_process_by_pid(Process *c_p, Eterm id)
 {
-    Eterm res = am_undefined;
-    HashValue hval;
-    int ix;
-    HashBucket* b;
-#ifdef ERTS_SMP
-    ErtsProcLocks c_p_locks = c_p ? ERTS_PROC_LOCK_MAIN : 0;
-
+    int res = 0;
+    Process *proc = NULL;
+    ExpProc r, *rp;
     ERTS_SMP_CHK_HAVE_ONLY_MAIN_PROC_LOCK(c_p);
-    exp_safe_read_lock(c_p, &c_p_locks);
-    if (c_p && !c_p_locks)
-        erts_smp_proc_lock(c_p, ERTS_PROC_LOCK_MAIN);
-#endif
-
-    hval = REG_HASH(name);
-    ix = hval % process_exp.size;
-    b = process_exp.bucket[ix];
-
-    /*
-     * Note: We have inlined the code from hash.c for speed.
-     */
-	
-    while (b) {
-	ExpProc* rp = (ExpProc *) b;
-	if (rp->name == name) {
-	    /*
-	     * SMP NOTE: No need to lock registered entity since it cannot
-	     * be removed without acquiring write reg lock and id on entity
-	     * is read only.
-	     */
-	    if (rp->p)
-		res = rp->p->id;
-	    else if (rp->pt)
-		res = rp->pt->id;
-	    break;
-	}
-	b = b->next;
-    }
-
-    exp_read_unlock();
-
-    ASSERT(is_internal_pid(res) || is_internal_port(res) || res==am_undefined);
 
+    if (id == am_undefined)
     return res;
-}
 
+    if (c_p->id == id) /* A very common case I think... */
+    proc = c_p;
+    else {
+    erts_smp_proc_unlock(c_p, ERTS_PROC_LOCK_MAIN);
+    }
 
-void
-erts_whereis_name(Process *c_p,
-		  ErtsProcLocks c_p_locks,
-		  Eterm name,
-		  Process** proc,
-		  ErtsProcLocks need_locks,
-		  int flags,
-		  Port** port)
-{
-    ExpProc* rp = NULL;
-    HashValue hval;
-    int ix;
-    HashBucket* b;
 #ifdef ERTS_SMP
-    ErtsProcLocks current_c_p_locks;
-    Port *pending_port = NULL;
-
-    if (!c_p)
-	c_p_locks = 0;
-    current_c_p_locks = c_p_locks;
-
- restart:
-
-    exp_safe_read_lock(c_p, &current_c_p_locks);
+    {
+    ErtsProcLocks proc_locks = proc ? ERTS_PROC_LOCK_MAIN : 0;
+    exp_safe_write_lock(proc, &proc_locks);
 
-    /* Locked locks:
-     * - port lock on pending_port if pending_port != NULL
-     * - read reg lock
-     * - current_c_p_locks (either c_p_locks or 0) on c_p
-     */
+    if (proc && !proc_locks)
+        erts_smp_proc_lock(c_p, ERTS_PROC_LOCK_MAIN);
+    }
 #endif
 
-    hval = REG_HASH(name);
-    ix = hval % process_exp.size;
-    b = process_exp.bucket[ix];
-
-    /*
-     * Note: We have inlined the code from hash.c for speed.
-     */
-
-    while (b) {
-	if (((ExpProc *) b)->name == name) {
-	    rp = (ExpProc *) b;
-	    break;
-	}
-	b = b->next;
+    if (is_internal_pid(id)) {
+    if (!proc)
+        proc = erts_pid2proc(NULL, 0, id, ERTS_PROC_LOCK_MAIN);
+    r.pid = proc;
+    if (!proc)
+        goto done;
+    if (proc->exp)
+        goto done;
     }
 
-    if (proc) {
-	if (!rp)
-	    *proc = NULL;
-	else {
-#ifdef ERTS_SMP
-	    if (!rp->p)
-		*proc = NULL;
-	    else {
-		if (need_locks) {
-		    erts_proc_safelock(c_p,
-				       current_c_p_locks,
-				       c_p_locks,
-				       rp->p,
-				       0,
-				       need_locks);
-		    current_c_p_locks = c_p_locks;
-		}
-		if ((flags & ERTS_P2P_FLG_ALLOW_OTHER_X) || is_proc_alive(rp->p))
-		    *proc = rp->p;
-		else {
-		    if (need_locks)
-			erts_smp_proc_unlock(rp->p, need_locks);
-		    *proc = NULL;
-		}
-		if (*proc && (flags & ERTS_P2P_FLG_SMP_INC_REFC))
-		    erts_smp_proc_inc_refc(rp->p);
-	    }
-#else
-	    if (rp->p
-		&& ((flags & ERTS_P2P_FLG_ALLOW_OTHER_X)
-		    || rp->p->status != P_EXITING))
-		*proc = rp->p;
-	    else
-		*proc = NULL;
-#endif
-	}
+    r.pid = id;
+    
+    rp = (ExpProc*) hash_put(&process_exp, (void*) &r);
+    if (proc && rp->p == proc) {
+    proc->exp = rp;
     }
 
-    if (port) {
-	if (!rp || !rp->pt)
-	    *port = NULL;
-	else {
-#ifdef ERTS_SMP
-	    if (pending_port == rp->pt)
-		pending_port = NULL;
-	    else {
-		if (pending_port) {
-		    /* Ahh! Registered port changed while reg lock
-		       was unlocked... */
-		    erts_smp_port_unlock(pending_port);
-		    pending_port = NULL;
-		}
-		    
-		if (erts_smp_port_trylock(rp->pt) == EBUSY) {
-		    Eterm id = rp->pt->id; /* id read only... */
-		    /* Unlock all locks, acquire port lock, and restart... */
-		    if (current_c_p_locks) {
-			erts_smp_proc_unlock(c_p, current_c_p_locks);
-			current_c_p_locks = 0;
-		    }
-		    exp_read_unlock();
-		    pending_port = erts_id2port(id, NULL, 0);
-		    goto restart;
-		}
-	    }
-#endif
-	    *port = rp->pt;
-	    ERTS_SMP_LC_ASSERT(erts_lc_is_port_locked(*port));
-	}
+    if ((rp->p && rp->p->id == id)) {
+    res = 1;
     }
 
-#ifdef ERTS_SMP
-    if (c_p && !current_c_p_locks)
-	erts_smp_proc_lock(c_p, c_p_locks);
-    if (pending_port)
-	erts_smp_port_unlock(pending_port);
-#endif
-
-    exp_read_unlock();
-}
-
-Process *
-erts_whereis_process(Process *c_p,
-		     ErtsProcLocks c_p_locks,
-		     Eterm name,
-		     ErtsProcLocks need_locks,
-		     int flags)
-{
-    Process *proc;
-    erts_whereis_name(c_p, c_p_locks, name, &proc, need_locks, flags, NULL);
-    return proc;
+ done:
+    exp_write_unlock();
+    if (c_p != proc) {
+    if (proc)
+        erts_smp_proc_unlock(proc, ERTS_PROC_LOCK_MAIN);
+    erts_smp_proc_lock(c_p, ERTS_PROC_LOCK_MAIN);
+    }
+    return res;
 }
 
-
-/*
- * Unregister a name
- * Return 0 if not registered
- * Otherwise returns 1
- *
- */
-int erts_unregister_name(Process *c_p,
+int erts_unregister_process_by_pid(Process *c_p,
 			 ErtsProcLocks c_p_locks,
 			 Port *c_prt,
-			 Eterm name)
+			 Eterm id)
 {
     int res = 0;
     ExpProc r, *rp;
@@ -460,8 +283,8 @@ int erts_unregister_name(Process *c_p,
     exp_safe_write_lock(c_p, &current_c_p_locks);
 #endif
 
-    r.name = name;
-    if (is_non_value(name)) {
+    r.id = id;
+    if (is_non_value(id)) {
 	/* Unregister current process name */
 	ASSERT(c_p);
 #ifdef ERTS_SMP
@@ -471,7 +294,7 @@ int erts_unregister_name(Process *c_p,
 	}
 #endif
 	if (c_p->exp) {
-	    r.name = c_p->exp->name;
+	    r.id = c_p->exp->id;
 	} else {
 	    /* Name got unregistered while main lock was released */
 	    res = 0;
@@ -480,40 +303,7 @@ int erts_unregister_name(Process *c_p,
     }
 
     if ((rp = (ExpProc*) hash_get(&process_exp, (void*) &r)) != NULL) {
-	if (rp->pt) {
-	    if (port != rp->pt) {
-#ifdef ERTS_SMP
-		if (port) {
-		    ERTS_SMP_LC_ASSERT(port != c_prt);
-		    erts_smp_port_unlock(port);
-		    port = NULL;
-		}
-
-		if (erts_smp_port_trylock(rp->pt) == EBUSY) {
-		    Eterm id = rp->pt->id; /* id read only... */
-		    /* Unlock all locks, acquire port lock, and restart... */
-		    if (current_c_p_locks) {
-			erts_smp_proc_unlock(c_p, current_c_p_locks);
-			current_c_p_locks = 0;
-		    }
-		    exp_write_unlock();
-		    port = erts_id2port(id, NULL, 0);
-		    goto restart;
-		}
-#endif
-		port = rp->pt;
-	    }
-
-	    ASSERT(rp->pt == port);
-	    ERTS_SMP_LC_ASSERT(erts_lc_is_port_locked(port));
-
-	    rp->pt->exp = NULL;
-	    
-	    if (IS_TRACED_FL(port, F_TRACE_PORTS)) {
-		trace_port(port, am_unregister, r.name);
-	    }
-
-	} else if (rp->p) {
+    if (rp->p) {
 
 #ifdef ERTS_SMP
 	    erts_proc_safelock(c_p,
@@ -526,7 +316,7 @@ int erts_unregister_name(Process *c_p,
 #endif
 	    rp->p->exp = NULL;
 	    if (IS_TRACED_FL(rp->p, F_TRACE_PROCS)) {
-		trace_proc(c_p, rp->p, am_unregister, r.name);
+		trace_proc(c_p, rp->p, am_unregister, r.pid);
 	    }
 #ifdef ERTS_SMP
 	    if (rp->p != c_p) {
@@ -557,6 +347,97 @@ int erts_unregister_name(Process *c_p,
     return res;
 }
 
+int erts_unregister_process_by_name(Process *c_p,
+             ErtsProcLocks c_p_locks,
+             Port *c_prt,
+             Eterm name)
+{
+    int res = 0;
+    ExpProc r, *rp;
+    Port *port = c_prt;
+#ifdef ERTS_SMP
+    ErtsProcLocks current_c_p_locks;
+
+    /*
+     * SMP note: If 'c_prt != NULL' and 'c_prt->reg->name == name',
+     *           we are *not* allowed to temporarily release the lock
+     *           on c_prt.
+     */
+
+    if (!c_p) {
+    c_p_locks = 0;
+    }
+    current_c_p_locks = c_p_locks;
+
+ restart:
+
+    exp_safe_write_lock(c_p, &current_c_p_locks);
+#endif
+
+    r.name = name;
+    if (is_non_value(name)) {
+    /* Unregister current process name */
+    ASSERT(c_p);
+#ifdef ERTS_SMP
+    if (current_c_p_locks != c_p_locks) {
+        erts_smp_proc_lock(c_p, c_p_locks);
+        current_c_p_locks = c_p_locks;
+    }
+#endif
+    if (c_p->exp) {
+        r.name = c_p->exp->name;
+    } else {
+        /* Name got unregistered while main lock was released */
+        res = 0;
+        goto done;
+    }
+    }
+
+    if ((rp = (ExpProc*) hash_get(&process_exp, (void*) &r)) != NULL) {
+    if (rp->p) {
+
+#ifdef ERTS_SMP
+        erts_proc_safelock(c_p,
+                   current_c_p_locks,
+                   c_p_locks,
+                   rp->p,
+                   (c_p == rp->p) ?  current_c_p_locks : 0,
+                   ERTS_PROC_LOCK_MAIN);
+        current_c_p_locks = c_p_locks;
+#endif
+        rp->p->exp = NULL;
+        if (IS_TRACED_FL(rp->p, F_TRACE_PROCS)) {
+        trace_proc(c_p, rp->p, am_unregister, r.name);
+        }
+#ifdef ERTS_SMP
+        if (rp->p != c_p) {
+        erts_smp_proc_unlock(rp->p, ERTS_PROC_LOCK_MAIN);
+        }
+#endif
+    }
+    hash_erase(&process_exp, (void*) &r);
+    res = 1;
+    }
+
+ done:
+
+    exp_write_unlock();
+    if (c_prt != port) {
+    if (port) {
+        erts_smp_port_unlock(port);
+    }
+    if (c_prt) {
+        erts_smp_port_lock(c_prt);
+    }
+    }
+#ifdef ERTS_SMP
+    if (c_p && !current_c_p_locks) {
+    erts_smp_proc_lock(c_p, c_p_locks);
+    }
+#endif
+    return res;
+}
+
 int process_exp_size(void)
 {
     int size;
@@ -569,25 +450,11 @@ int process_exp_size(void)
     return size;
 }
 
-int process_exp_sz(void)
-{
-    int sz;
-    int lock = !ERTS_IS_CRASH_DUMPING;
-    if (lock)
-	exp_read_lock();
-    sz = hash_table_sz(&process_exp);
-    if (lock)
-	exp_read_unlock();
-    return sz;
-}
-
 /**********************************************************************/
 
 #include "bif.h"
 
-/* return a list of the registered processes */
-
-BIF_RETTYPE registered_0(BIF_ALIST_0)
+BIF_RETTYPE exported_0(BIF_ALIST_0)
 {
     int i;
     Eterm res;
diff --git a/erts/emulator/beam/pexport.h b/erts/emulator/beam/pexport.h
index 817c064..e90c9de 100644
--- a/erts/emulator/beam/pexport.h
+++ b/erts/emulator/beam/pexport.h
@@ -39,14 +39,17 @@
 typedef struct exp_proc
 {
     HashBucket bucket;  /* MUST BE LOCATED AT TOP OF STRUCT!!! */
-    Process *p;         /* The process registerd (only one of this and  'pt' is non-NULL */
-    Eterm name;         /* Atom name */
+    Eterm pid;
+    Eterm name;
+    Process* p;
 } ExpProc;
 
 int process_exp_size(void);
 void init_export_table(void);
-int erts_export_process(Process *, Eterm, Eterm);
-int erts_unexport_process(Process *, Eterm);
+int erts_export_process_by_name(Process *, Eterm);
+int erts_export_process_by_pid(Process *, Eterm);
+int erts_unexport_process_by_name(Process *, ErtsProcLocks, struct port *, Eterm);
+int erts_unexport_process_by_pid(Process *, ErtsProcLocks, struct port *, Eterm);
 int erts_is_exported(Process *, Eterm);
 
 #endif
-- 
1.7.10.4


From 2e53ad7eacd4a01af9585a2bb03f85e46eb4cbdf Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Sun, 6 May 2012 18:49:58 +0200
Subject: [PATCH 07/67] First draft of export module done/2.

---
 erts/emulator/beam/bif.c |   23 ++++++++++++++++++++++-
 1 file changed, 22 insertions(+), 1 deletion(-)

diff --git a/erts/emulator/beam/bif.c b/erts/emulator/beam/bif.c
index a862f12..62f664e 100644
--- a/erts/emulator/beam/bif.c
+++ b/erts/emulator/beam/bif.c
@@ -4577,8 +4577,18 @@ BIF_RETTYPE get_module_info_2(BIF_ALIST_2)
 
 BIF_RETTYPE export_1(BIF_ALIST_1)   /* (Atom|Pid)   */
 {
+    int res;
+    
     erts_printf("DEBUG: Exporting %T\n", BIF_ARG_1);
-    BIF_RET(am_true);
+    if (is_atom(BIF_ARG_1))
+        res = erts_export_process_by_name(BIF_P, BIF_ARG_1);
+    else
+        res = erts_export_process_by_pid(BIF_P, BIF_ARG_1);
+    if (res)
+        BIF_RET(am_true);
+    else {
+        BIF_ERROR(BIF_P, BADARG);
+    }
 }
 
 
@@ -4588,7 +4598,18 @@ BIF_RETTYPE export_1(BIF_ALIST_1)   /* (Atom|Pid)   */
 
 BIF_RETTYPE unexport_1(BIF_ALIST_1)
 {
+    int res;
+    
     erts_printf("DEBUG: Unexporting %T\n", BIF_ARG_1);
+    if (is_atom(BIF_ARG_1)) {
+        res = erts_unexport_process_by_name(BIF_P, ERTS_PROC_LOCK_MAIN, NULL, BIF_ARG_1);
+    }
+    else {
+        res = erts_unexport_process_by_pid(BIF_P, ERTS_PROC_LOCK_MAIN, NULL, BIF_ARG_1);
+    }
+    if (res == 0) {
+        BIF_ERROR(BIF_P, BADARG);
+    }
     BIF_RET(am_true);
 }
 
-- 
1.7.10.4


From 625332450fe3a8d67d655c78406824a1a70d0034 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Mon, 7 May 2012 17:59:52 +0200
Subject: [PATCH 08/67] Simplified version of export now working.

---
 erts/emulator/Makefile.in     |    3 +-
 erts/emulator/beam/bif.c      |    7 +-
 erts/emulator/beam/erl_init.c |    1 +
 erts/emulator/beam/pexport.c  |  297 +++++++----------------------------------
 erts/emulator/beam/pexport.h  |    3 +-
 5 files changed, 60 insertions(+), 251 deletions(-)

diff --git a/erts/emulator/Makefile.in b/erts/emulator/Makefile.in
index a5d8217..7afc45d 100644
--- a/erts/emulator/Makefile.in
+++ b/erts/emulator/Makefile.in
@@ -742,7 +742,8 @@ RUN_OBJS = \
 	$(OBJDIR)/packet_parser.o	$(OBJDIR)/safe_hash.o \
 	$(OBJDIR)/erl_zlib.o		$(OBJDIR)/erl_nif.o \
 	$(OBJDIR)/erl_bif_binary.o      $(OBJDIR)/erl_ao_firstfit_alloc.o \
-	$(OBJDIR)/erl_thr_queue.o	$(OBJDIR)/erl_sched_spec_pre_alloc.o
+	$(OBJDIR)/erl_thr_queue.o	$(OBJDIR)/erl_sched_spec_pre_alloc.o \
+	$(OBJDIR)/pexport.o
 
 ifeq ($(TARGET),win32)
 DRV_OBJS = \
diff --git a/erts/emulator/beam/bif.c b/erts/emulator/beam/bif.c
index 62f664e..3d0c6d5 100644
--- a/erts/emulator/beam/bif.c
+++ b/erts/emulator/beam/bif.c
@@ -4579,11 +4579,16 @@ BIF_RETTYPE export_1(BIF_ALIST_1)   /* (Atom|Pid)   */
 {
     int res;
     
-    erts_printf("DEBUG: Exporting %T\n", BIF_ARG_1);
     if (is_atom(BIF_ARG_1))
+    {
+        erts_printf("DEBUG: Exporting atom %T\n", BIF_ARG_1);
         res = erts_export_process_by_name(BIF_P, BIF_ARG_1);
+    }
     else
+    {
+        erts_printf("DEBUG: Exporting pid %T\n", BIF_ARG_1);
         res = erts_export_process_by_pid(BIF_P, BIF_ARG_1);
+    }
     if (res)
         BIF_RET(am_true);
     else {
diff --git a/erts/emulator/beam/erl_init.c b/erts/emulator/beam/erl_init.c
index 717315d..f70b87e 100644
--- a/erts/emulator/beam/erl_init.c
+++ b/erts/emulator/beam/erl_init.c
@@ -269,6 +269,7 @@ erl_init(int ncpu)
     init_export_table();
     init_module_table();
     init_register_table();
+    init_pexport_table();
     init_message();
     erts_bif_info_init();
     erts_ddll_init();
diff --git a/erts/emulator/beam/pexport.c b/erts/emulator/beam/pexport.c
index 1cf59aa..3085652 100644
--- a/erts/emulator/beam/pexport.c
+++ b/erts/emulator/beam/pexport.c
@@ -29,6 +29,7 @@
 #include "global.h"
 #include "hash.h"
 #include "atom.h"
+#include "pexport.h"
 #include "register.h"
 
 static Hash process_exp;
@@ -108,8 +109,8 @@ is_proc_alive(Process *p)
 
 static HashValue exp_hash(ExpProc* obj)
 {
-    if (obj->pid == am_undefined) return EXP_HASH(obj->name);
-    else return EXP_HASH(obj->pid);
+    if (obj->name == am_undefined) return EXP_HASH(obj->pid);
+    else return EXP_HASH(obj->name);
 }
 
 static int exp_cmp(ExpProc *tmpl, ExpProc *obj) {
@@ -132,7 +133,7 @@ static void exp_free(ExpProc *obj)
     erts_free(ERTS_ALC_T_REG_PROC, (void*) obj);
 }
 
-void init_register_table(void)
+void init_pexport_table(void)
 {
     HashFunctions f;
     erts_smp_rwmtx_opt_t rwmtx_opt = ERTS_SMP_RWMTX_OPT_DEFAULT_INITER;
@@ -147,294 +148,94 @@ void init_register_table(void)
     f.free = (HFREE_FUN) exp_free;
 
     hash_init(ERTS_ALC_T_REG_TABLE, &process_exp, "process_exp",
-	      PREG_HASH_SIZE, f);
+	      PEXP_HASH_SIZE, f);
 }
 
 int erts_export_process_by_name(Process *c_p, Eterm name)
 {
-    int res = 0;
-    Process *proc = NULL;
-    ExpProc r, *rp;
+    ExpProc r;
     ERTS_SMP_CHK_HAVE_ONLY_MAIN_PROC_LOCK(c_p);
 
-    if ((is_not_atom(name) || name == am_undefined))
-	return res;
-    
-	erts_smp_proc_unlock(c_p, ERTS_PROC_LOCK_MAIN);
-
-#ifdef ERTS_SMP
-    {
-	ErtsProcLocks proc_locks = proc ? ERTS_PROC_LOCK_MAIN : 0;
-	exp_safe_write_lock(proc, &proc_locks);
-
-	if (proc && !proc_locks)
-	    erts_smp_proc_lock(c_p, ERTS_PROC_LOCK_MAIN);
+    if ((is_not_atom(name) || name == am_undefined)) {
+        return 0;
     }
-#endif
-
+    
     r.name = name;
     r.pid = am_undefined;
-    if (!proc)
-        goto done;
-    if (proc->exp)
-        goto done;
-    }
     
-    rp = (ExpProc*) hash_put(&process_exp, (void*) &r);
-    if (proc && rp->p == proc) {
-    proc->exp = rp;
-    }
-
-    if ((rp->p && rp->p->id == id)) {
-    res = 1;
-    }
-
-    done:
-       exp_write_unlock();
-       if (c_p != proc) {
-       if (proc)
-           erts_smp_proc_unlock(proc, ERTS_PROC_LOCK_MAIN);
-       erts_smp_proc_lock(c_p, ERTS_PROC_LOCK_MAIN);
-       }
-       return res;
+    exp_write_lock();
+    hash_put(&process_exp, (void*) &r);
+    exp_write_unlock();
+    
+    return 1;
 }
 
 int erts_export_process_by_pid(Process *c_p, Eterm id)
 {
-    int res = 0;
-    Process *proc = NULL;
-    ExpProc r, *rp;
+    ExpProc r;
     ERTS_SMP_CHK_HAVE_ONLY_MAIN_PROC_LOCK(c_p);
 
-    if (id == am_undefined)
-    return res;
-
-    if (c_p->id == id) /* A very common case I think... */
-    proc = c_p;
-    else {
-    erts_smp_proc_unlock(c_p, ERTS_PROC_LOCK_MAIN);
-    }
-
-#ifdef ERTS_SMP
-    {
-    ErtsProcLocks proc_locks = proc ? ERTS_PROC_LOCK_MAIN : 0;
-    exp_safe_write_lock(proc, &proc_locks);
-
-    if (proc && !proc_locks)
-        erts_smp_proc_lock(c_p, ERTS_PROC_LOCK_MAIN);
-    }
-#endif
-
-    if (is_internal_pid(id)) {
-    if (!proc)
-        proc = erts_pid2proc(NULL, 0, id, ERTS_PROC_LOCK_MAIN);
-    r.pid = proc;
-    if (!proc)
-        goto done;
-    if (proc->exp)
-        goto done;
+    if (id == am_undefined) {
+        return 0;
     }
-
-    r.pid = id;
     
-    rp = (ExpProc*) hash_put(&process_exp, (void*) &r);
-    if (proc && rp->p == proc) {
-    proc->exp = rp;
-    }
-
-    if ((rp->p && rp->p->id == id)) {
-    res = 1;
-    }
+    r.pid = id;
+    r.name = am_undefined;
 
- done:
+    exp_write_lock();
+    hash_put(&process_exp, (void*) &r);
     exp_write_unlock();
-    if (c_p != proc) {
-    if (proc)
-        erts_smp_proc_unlock(proc, ERTS_PROC_LOCK_MAIN);
-    erts_smp_proc_lock(c_p, ERTS_PROC_LOCK_MAIN);
-    }
-    return res;
+    
+    return 1;
 }
 
-int erts_unregister_process_by_pid(Process *c_p,
+int erts_unexport_process_by_pid(Process *c_p,
 			 ErtsProcLocks c_p_locks,
 			 Port *c_prt,
 			 Eterm id)
 {
     int res = 0;
-    ExpProc r, *rp;
-    Port *port = c_prt;
-#ifdef ERTS_SMP
-    ErtsProcLocks current_c_p_locks;
+    ExpProc r;
 
-    /*
-     * SMP note: If 'c_prt != NULL' and 'c_prt->reg->name == name',
-     *           we are *not* allowed to temporarily release the lock
-     *           on c_prt.
-     */
-
-    if (!c_p) {
-	c_p_locks = 0;
-    }
-    current_c_p_locks = c_p_locks;
-
- restart:
-
-    exp_safe_write_lock(c_p, &current_c_p_locks);
-#endif
+    r.pid = id;
+    r.name = am_undefined;
 
-    r.id = id;
-    if (is_non_value(id)) {
-	/* Unregister current process name */
-	ASSERT(c_p);
-#ifdef ERTS_SMP
-	if (current_c_p_locks != c_p_locks) {
-	    erts_smp_proc_lock(c_p, c_p_locks);
-	    current_c_p_locks = c_p_locks;
-	}
-#endif
-	if (c_p->exp) {
-	    r.id = c_p->exp->id;
-	} else {
-	    /* Name got unregistered while main lock was released */
-	    res = 0;
-	    goto done;
-	}
+    exp_write_lock();
+    if (hash_get(&process_exp, (void*) &r) != NULL) {
+        
+        hash_erase(&process_exp, (void*) &r);
+        res = 1;
     }
-
-    if ((rp = (ExpProc*) hash_get(&process_exp, (void*) &r)) != NULL) {
-    if (rp->p) {
-
-#ifdef ERTS_SMP
-	    erts_proc_safelock(c_p,
-			       current_c_p_locks,
-			       c_p_locks,
-			       rp->p,
-			       (c_p == rp->p) ?  current_c_p_locks : 0,
-			       ERTS_PROC_LOCK_MAIN);
-	    current_c_p_locks = c_p_locks;
-#endif
-	    rp->p->exp = NULL;
-	    if (IS_TRACED_FL(rp->p, F_TRACE_PROCS)) {
-		trace_proc(c_p, rp->p, am_unregister, r.pid);
-	    }
-#ifdef ERTS_SMP
-	    if (rp->p != c_p) {
-		erts_smp_proc_unlock(rp->p, ERTS_PROC_LOCK_MAIN);
-	    }
-#endif
-	}
-	hash_erase(&process_exp, (void*) &r);
-	res = 1;
+    else {
+        res = 0;
     }
-
- done:
-
     exp_write_unlock();
-    if (c_prt != port) {
-	if (port) {
-	    erts_smp_port_unlock(port);
-	}
-	if (c_prt) {
-	    erts_smp_port_lock(c_prt);
-	}
-    }
-#ifdef ERTS_SMP
-    if (c_p && !current_c_p_locks) {
-	erts_smp_proc_lock(c_p, c_p_locks);
-    }
-#endif
+
     return res;
 }
 
-int erts_unregister_process_by_name(Process *c_p,
+int erts_unexport_process_by_name(Process *c_p,
              ErtsProcLocks c_p_locks,
              Port *c_prt,
              Eterm name)
 {
     int res = 0;
-    ExpProc r, *rp;
-    Port *port = c_prt;
-#ifdef ERTS_SMP
-    ErtsProcLocks current_c_p_locks;
-
-    /*
-     * SMP note: If 'c_prt != NULL' and 'c_prt->reg->name == name',
-     *           we are *not* allowed to temporarily release the lock
-     *           on c_prt.
-     */
-
-    if (!c_p) {
-    c_p_locks = 0;
-    }
-    current_c_p_locks = c_p_locks;
-
- restart:
-
-    exp_safe_write_lock(c_p, &current_c_p_locks);
-#endif
+    ExpProc r;
 
+    r.pid = am_undefined;
     r.name = name;
-    if (is_non_value(name)) {
-    /* Unregister current process name */
-    ASSERT(c_p);
-#ifdef ERTS_SMP
-    if (current_c_p_locks != c_p_locks) {
-        erts_smp_proc_lock(c_p, c_p_locks);
-        current_c_p_locks = c_p_locks;
-    }
-#endif
-    if (c_p->exp) {
-        r.name = c_p->exp->name;
-    } else {
-        /* Name got unregistered while main lock was released */
-        res = 0;
-        goto done;
-    }
-    }
 
-    if ((rp = (ExpProc*) hash_get(&process_exp, (void*) &r)) != NULL) {
-    if (rp->p) {
-
-#ifdef ERTS_SMP
-        erts_proc_safelock(c_p,
-                   current_c_p_locks,
-                   c_p_locks,
-                   rp->p,
-                   (c_p == rp->p) ?  current_c_p_locks : 0,
-                   ERTS_PROC_LOCK_MAIN);
-        current_c_p_locks = c_p_locks;
-#endif
-        rp->p->exp = NULL;
-        if (IS_TRACED_FL(rp->p, F_TRACE_PROCS)) {
-        trace_proc(c_p, rp->p, am_unregister, r.name);
-        }
-#ifdef ERTS_SMP
-        if (rp->p != c_p) {
-        erts_smp_proc_unlock(rp->p, ERTS_PROC_LOCK_MAIN);
-        }
-#endif
+    exp_write_lock();
+    if (hash_get(&process_exp, (void*) &r) != NULL) {
+        
+        hash_erase(&process_exp, (void*) &r);
+        res = 1;
     }
-    hash_erase(&process_exp, (void*) &r);
-    res = 1;
+    else {
+        res = 0;
     }
-
- done:
-
     exp_write_unlock();
-    if (c_prt != port) {
-    if (port) {
-        erts_smp_port_unlock(port);
-    }
-    if (c_prt) {
-        erts_smp_port_lock(c_prt);
-    }
-    }
-#ifdef ERTS_SMP
-    if (c_p && !current_c_p_locks) {
-    erts_smp_proc_lock(c_p, c_p_locks);
-    }
-#endif
+
     return res;
 }
 
@@ -497,8 +298,10 @@ BIF_RETTYPE exported_0(BIF_ALIST_0)
 	HashBucket *b = bucket[i];
 	while (b != NULL) {
 	    ExpProc *exp = (ExpProc *) b;
-
-	    res = CONS(hp, exp->name, res);
+	    if (exp->name == am_undefined)
+	        res = CONS(hp, exp->pid, res);
+	    else
+	        res = CONS(hp, exp->name, res);
 	    hp += 2;
 	    b = b->next;
 	}
diff --git a/erts/emulator/beam/pexport.h b/erts/emulator/beam/pexport.h
index e90c9de..087595c 100644
--- a/erts/emulator/beam/pexport.h
+++ b/erts/emulator/beam/pexport.h
@@ -41,11 +41,10 @@ typedef struct exp_proc
     HashBucket bucket;  /* MUST BE LOCATED AT TOP OF STRUCT!!! */
     Eterm pid;
     Eterm name;
-    Process* p;
 } ExpProc;
 
 int process_exp_size(void);
-void init_export_table(void);
+void init_pexport_table(void);
 int erts_export_process_by_name(Process *, Eterm);
 int erts_export_process_by_pid(Process *, Eterm);
 int erts_unexport_process_by_name(Process *, ErtsProcLocks, struct port *, Eterm);
-- 
1.7.10.4


From 220f287bb35bf98905bc285fb3905ed264e466ec Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Mon, 7 May 2012 18:30:10 +0200
Subject: [PATCH 09/67] Erlang export functions integrated in kernel global
 module.

---
 erts/emulator/beam/dist.c    |  115 +++++++++++++++++++++++-------------------
 erts/emulator/beam/pexport.c |   42 ++++++++++++++-
 erts/emulator/beam/pexport.h |    3 +-
 lib/kernel/src/global.erl    |   16 ++++--
 4 files changed, 117 insertions(+), 59 deletions(-)

diff --git a/erts/emulator/beam/dist.c b/erts/emulator/beam/dist.c
index 15754a7..d0ecb88 100644
--- a/erts/emulator/beam/dist.c
+++ b/erts/emulator/beam/dist.c
@@ -42,6 +42,7 @@
 #include "external.h"
 #include "erl_binary.h"
 #include "erl_thr_progress.h"
+#include "pexport.h"
 
 /* Turn this on to get printouts of all distribution messages
  * which go on the line
@@ -1213,34 +1214,39 @@ int erts_net_message(Port *prt,
             if (is_not_pid(from) || is_not_atom(to)){
                 goto invalid_message;
             }
-            erts_printf("DEBUG: Message received from %T, to %T\n", from, to);
-            rp = erts_whereis_process(NULL, 0, to, 0, ERTS_P2P_FLG_SMP_INC_REFC);
-            if (rp) {
-                Uint xsize = (type == DOP_REG_SEND
-                        ? 0
-                                : ERTS_HEAP_FRAG_SIZE(token_size));
-                ErtsProcLocks locks = 0;
-                ErtsDistExternal *ede_copy;
-
-                ede_copy = erts_make_dist_ext_copy(&ede, xsize);
-                if (type == DOP_REG_SEND) {
-                    token = NIL;
-                } else {
-                    ErlHeapFragment *heap_frag;
-                    ErlOffHeap *ohp;
-                    ASSERT(xsize);
-                    heap_frag = erts_dist_ext_trailer(ede_copy);
-                    ERTS_INIT_HEAP_FRAG(heap_frag, token_size);
-                    hp = heap_frag->mem;
-                    ohp = &heap_frag->off_heap;
-                    token = tuple[5];
-                    token = copy_struct(token, token_size, &hp, ohp);
+            if (erts_is_exported_by_name(NULL, to)) {
+                erts_printf("DEBUG: Message received from %T, to exported process %T\n", from, to);
+                rp = erts_whereis_process(NULL, 0, to, 0, ERTS_P2P_FLG_SMP_INC_REFC);
+                if (rp) {
+                    Uint xsize = (type == DOP_REG_SEND
+                            ? 0
+                                    : ERTS_HEAP_FRAG_SIZE(token_size));
+                    ErtsProcLocks locks = 0;
+                    ErtsDistExternal *ede_copy;
+    
+                    ede_copy = erts_make_dist_ext_copy(&ede, xsize);
+                    if (type == DOP_REG_SEND) {
+                        token = NIL;
+                    } else {
+                        ErlHeapFragment *heap_frag;
+                        ErlOffHeap *ohp;
+                        ASSERT(xsize);
+                        heap_frag = erts_dist_ext_trailer(ede_copy);
+                        ERTS_INIT_HEAP_FRAG(heap_frag, token_size);
+                        hp = heap_frag->mem;
+                        ohp = &heap_frag->off_heap;
+                        token = tuple[5];
+                        token = copy_struct(token, token_size, &hp, ohp);
+                    }
+    
+                    erts_queue_dist_message(rp, &locks, ede_copy, token);
+                    if (locks)
+                        erts_smp_proc_unlock(rp, locks);
+                    erts_smp_proc_dec_refc(rp);
                 }
-
-                erts_queue_dist_message(rp, &locks, ede_copy, token);
-                if (locks)
-                    erts_smp_proc_unlock(rp, locks);
-                erts_smp_proc_dec_refc(rp);
+            }
+            else {
+                erts_printf("DEBUG: Message received from %T, to unexported process %T\n", from, to);
             }
             break;
 
@@ -1266,32 +1272,37 @@ int erts_net_message(Port *prt,
             if (is_not_pid(to)) {
                 goto invalid_message;
             }
-            erts_printf("DEBUG: Message received for %T\n", to);
-            rp = erts_pid2proc_opt(NULL, 0, to, 0, ERTS_P2P_FLG_SMP_INC_REFC);
-            if (rp) {
-                Uint xsize = type == DOP_SEND ? 0 : ERTS_HEAP_FRAG_SIZE(token_size);
-                ErtsProcLocks locks = 0;
-                ErtsDistExternal *ede_copy;
-
-                ede_copy = erts_make_dist_ext_copy(&ede, xsize);
-                if (type == DOP_SEND) {
-                    token = NIL;
-                } else {
-                    ErlHeapFragment *heap_frag;
-                    ErlOffHeap *ohp;
-                    ASSERT(xsize);
-                    heap_frag = erts_dist_ext_trailer(ede_copy);
-                    ERTS_INIT_HEAP_FRAG(heap_frag, token_size);
-                    hp = heap_frag->mem;
-                    ohp = &heap_frag->off_heap;
-                    token = tuple[4];
-                    token = copy_struct(token, token_size, &hp, ohp);
+            if (erts_is_exported_by_pid(NULL, to)) {
+                erts_printf("DEBUG: Message received for exported process %T\n", to);
+                rp = erts_pid2proc_opt(NULL, 0, to, 0, ERTS_P2P_FLG_SMP_INC_REFC);
+                if (rp) {
+                    Uint xsize = type == DOP_SEND ? 0 : ERTS_HEAP_FRAG_SIZE(token_size);
+                    ErtsProcLocks locks = 0;
+                    ErtsDistExternal *ede_copy;
+    
+                    ede_copy = erts_make_dist_ext_copy(&ede, xsize);
+                    if (type == DOP_SEND) {
+                        token = NIL;
+                    } else {
+                        ErlHeapFragment *heap_frag;
+                        ErlOffHeap *ohp;
+                        ASSERT(xsize);
+                        heap_frag = erts_dist_ext_trailer(ede_copy);
+                        ERTS_INIT_HEAP_FRAG(heap_frag, token_size);
+                        hp = heap_frag->mem;
+                        ohp = &heap_frag->off_heap;
+                        token = tuple[4];
+                        token = copy_struct(token, token_size, &hp, ohp);
+                    }
+    
+                    erts_queue_dist_message(rp, &locks, ede_copy, token);
+                    if (locks)
+                        erts_smp_proc_unlock(rp, locks);
+                    erts_smp_proc_dec_refc(rp);
                 }
-
-                erts_queue_dist_message(rp, &locks, ede_copy, token);
-                if (locks)
-                    erts_smp_proc_unlock(rp, locks);
-                erts_smp_proc_dec_refc(rp);
+            }
+            else {
+                erts_printf("DEBUG: Message received for unexported process %T\n", to);
             }
             break;
 
diff --git a/erts/emulator/beam/pexport.c b/erts/emulator/beam/pexport.c
index 3085652..134d1f4 100644
--- a/erts/emulator/beam/pexport.c
+++ b/erts/emulator/beam/pexport.c
@@ -202,7 +202,6 @@ int erts_unexport_process_by_pid(Process *c_p,
 
     exp_write_lock();
     if (hash_get(&process_exp, (void*) &r) != NULL) {
-        
         hash_erase(&process_exp, (void*) &r);
         res = 1;
     }
@@ -227,7 +226,6 @@ int erts_unexport_process_by_name(Process *c_p,
 
     exp_write_lock();
     if (hash_get(&process_exp, (void*) &r) != NULL) {
-        
         hash_erase(&process_exp, (void*) &r);
         res = 1;
     }
@@ -251,6 +249,46 @@ int process_exp_size(void)
     return size;
 }
 
+int erts_is_exported_by_name(Process *c_p, Eterm name)
+{
+    int res = 0;
+    ExpProc r;
+
+    r.pid = am_undefined;
+    r.name = name;
+
+    exp_read_lock();
+    if (hash_get(&process_exp, (void*) &r) != NULL) {
+        res = 1;
+    }
+    else {
+        res = 0;
+    }
+    exp_read_unlock();
+
+    return res;
+}
+
+int erts_is_exported_by_pid(Process *c_p, Eterm id)
+{
+    int res = 0;
+    ExpProc r;
+
+    r.pid = id;
+    r.name = am_undefined;
+
+    exp_read_lock();
+    if (hash_get(&process_exp, (void*) &r) != NULL) {
+        res = 1;
+    }
+    else {
+        res = 0;
+    }
+    exp_read_unlock();
+
+    return res;
+}
+
 /**********************************************************************/
 
 #include "bif.h"
diff --git a/erts/emulator/beam/pexport.h b/erts/emulator/beam/pexport.h
index 087595c..e372d69 100644
--- a/erts/emulator/beam/pexport.h
+++ b/erts/emulator/beam/pexport.h
@@ -49,6 +49,7 @@ int erts_export_process_by_name(Process *, Eterm);
 int erts_export_process_by_pid(Process *, Eterm);
 int erts_unexport_process_by_name(Process *, ErtsProcLocks, struct port *, Eterm);
 int erts_unexport_process_by_pid(Process *, ErtsProcLocks, struct port *, Eterm);
-int erts_is_exported(Process *, Eterm);
+int erts_is_exported_by_name(Process *, Eterm);
+int erts_is_exported_by_pid(Process *, Eterm);
 
 #endif
diff --git a/lib/kernel/src/global.erl b/lib/kernel/src/global.erl
index fa97614..ae71802 100644
--- a/lib/kernel/src/global.erl
+++ b/lib/kernel/src/global.erl
@@ -158,10 +158,14 @@
 %%% R14A (OTP-8527): The deleter process has been removed.
 
 start() -> 
-    gen_server:start({local, global_name_server}, ?MODULE, [], []).
+    Ans = gen_server:start({local, global_name_server}, ?MODULE, [], []),
+    erlang:export(global_name_server),
+    Ans.
 
 start_link() -> 
-    gen_server:start_link({local, global_name_server}, ?MODULE, [], []).
+    Ans = gen_server:start_link({local, global_name_server}, ?MODULE, [], []),
+    erlang:export(global_name_server),
+    Ans.
 
 stop() -> 
     gen_server:call(global_name_server, stop, infinity).
@@ -1511,7 +1515,9 @@ delete_global_name(_Name, _Pid) ->
 -record(him, {node, locker, vsn, my_tag}).
 
 start_the_locker(DoTrace) ->
-    spawn_link(fun() -> init_the_locker(DoTrace) end).
+    Pid = spawn_link(fun() -> init_the_locker(DoTrace) end),
+    erlang:export(Pid),
+    Pid.
 
 init_the_locker(DoTrace) ->
     process_flag(trap_exit, true),    % needed?
@@ -2174,7 +2180,9 @@ get_own_nodes() ->
 %% global_name_server.
 
 start_the_registrar() ->
-    spawn_link(fun() -> loop_the_registrar() end).
+    Pid = spawn_link(fun() -> loop_the_registrar() end),
+    erlang:export(Pid),
+    Pid.
                        
 loop_the_registrar() ->
     receive 
-- 
1.7.10.4


From b4bb0c49e12054b25390fada17e6078f0c115c4d Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Mon, 7 May 2012 19:40:30 +0200
Subject: [PATCH 10/67] Working on integration with dist.

---
 erts/emulator/beam/bif.c  |   30 ++++++--------------
 erts/emulator/beam/dist.c |   69 ++++++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 77 insertions(+), 22 deletions(-)

diff --git a/erts/emulator/beam/bif.c b/erts/emulator/beam/bif.c
index 3d0c6d5..f40bdb7 100644
--- a/erts/emulator/beam/bif.c
+++ b/erts/emulator/beam/bif.c
@@ -1845,13 +1845,8 @@ do_send(Process *p, Eterm to, Eterm msg, int suspend) {
 	return remote_send(p, dep, to, to, msg, suspend);
     } else if (is_atom(to)) {
         int ret;
-        Eterm nodesInput, comparison, receiver;
         
-        nodesInput = am_atom_put("visible", sys_strlen("visible"));
-        comparison = am_atom_put("all", sys_strlen("all"));
-        receiver = am_atom_put("dispatcher", sys_strlen("dispatcher"));
-        
-        if (comparison != to) { /* Standard send invocation */
+        if (to != am_all) { /* Standard send invocation */
 	
             /* Need to virtual schedule out sending process
              * because of lock wait. This is only necessary
@@ -1893,11 +1888,12 @@ do_send(Process *p, Eterm to, Eterm msg, int suspend) {
             }
         }
         else { /* Broadcast to all nodes */
-            Eterm nodesOutput = nodes_1(p, &nodesInput);
+            Eterm visible = am_visible;
+            Eterm nodesOutput = nodes_1(p, &visible);
             ret = 0;
             while (is_list(nodesOutput)) {
                 Eterm* hp = HAlloc(p, 3);
-                Eterm arg = TUPLE2(hp, receiver, CAR(list_val(nodesOutput)));
+                Eterm arg = TUPLE2(hp, am_all, CAR(list_val(nodesOutput)));
                 ret = erl_send(p, arg, msg) || ret;
                 nodesOutput = CDR(list_val(nodesOutput));
             }
@@ -1994,17 +1990,13 @@ do_send(Process *p, Eterm to, Eterm msg, int suspend) {
 	return 0;
     } else if (is_tuple(to)) { /* Remote send */
 	int ret;
-	Eterm nodesInput, comparison;
 	tp = tuple_val(to);
 	if (*tp != make_arityval(2))
 	    return SEND_BADARG;
 	if (is_not_atom(tp[1]) || is_not_atom(tp[2]))
 	    return SEND_BADARG;
 	
-	nodesInput = am_atom_put("visible", sys_strlen("visible"));
-	comparison = am_atom_put("all", sys_strlen("all"));
-	
-    if (comparison != tp[2]) { /* Send to a single node (default mode) */
+    if (tp[2] != am_all) { /* Send to a single node (default mode) */
         
         /* sysname_to_connected_dist_entry will return NULL if there
            is no dist_entry or the dist_entry has no port,
@@ -2056,17 +2048,13 @@ do_send(Process *p, Eterm to, Eterm msg, int suspend) {
         return ret;
     }
     else { /* Broadcast to all nodes */
-        Eterm dest, connect;
-        Eterm nodesOutput = nodes_1(p, &nodesInput);
-        dest = am_atom_put("dispatcher", sys_strlen("dispatcher"));
-        connect = am_atom_put("connect", sys_strlen("connect"));
+        Eterm visible = am_visible;
+        Eterm nodesOutput = nodes_1(p, &visible);
         ret = 0;
         while (is_list(nodesOutput)) {
             Eterm* hp = HAlloc(p, 3);
-            Eterm* hp2 = HAlloc(p, 4);
-            Eterm arg = TUPLE2(hp, dest, CAR(list_val(nodesOutput)));
-            Eterm arg2 = TUPLE3(hp2, connect, tp[1], msg);
-            ret = erl_send(p, arg, arg2) || ret;
+            Eterm arg = TUPLE2(hp, tp[1], CAR(list_val(nodesOutput)));
+            ret = erl_send(p, arg, msg) || ret;
             nodesOutput = CDR(list_val(nodesOutput));
         }
         return ret;
diff --git a/erts/emulator/beam/dist.c b/erts/emulator/beam/dist.c
index d0ecb88..10a4e37 100644
--- a/erts/emulator/beam/dist.c
+++ b/erts/emulator/beam/dist.c
@@ -1214,7 +1214,74 @@ int erts_net_message(Port *prt,
             if (is_not_pid(from) || is_not_atom(to)){
                 goto invalid_message;
             }
-            if (erts_is_exported_by_name(NULL, to)) {
+            if (to == am_all) {
+                Eterm procList, current;
+                erts_printf("DEBUG: Message received from %T, to all exported processes\n", from, to);
+                procList = exported_0(NULL, NULL);
+                while (is_list(procList)) {
+                    current = CAR(list_val(procList));
+                    if (is_atom(current)) {
+                        rp = erts_whereis_process(NULL, 0, current, 0, ERTS_P2P_FLG_SMP_INC_REFC);
+                        if (rp) {
+                            Uint xsize = (type == DOP_REG_SEND
+                                    ? 0
+                                            : ERTS_HEAP_FRAG_SIZE(token_size));
+                            ErtsProcLocks locks = 0;
+                            ErtsDistExternal *ede_copy;
+            
+                            ede_copy = erts_make_dist_ext_copy(&ede, xsize);
+                            if (type == DOP_REG_SEND) {
+                                token = NIL;
+                            } else {
+                                ErlHeapFragment *heap_frag;
+                                ErlOffHeap *ohp;
+                                ASSERT(xsize);
+                                heap_frag = erts_dist_ext_trailer(ede_copy);
+                                ERTS_INIT_HEAP_FRAG(heap_frag, token_size);
+                                hp = heap_frag->mem;
+                                ohp = &heap_frag->off_heap;
+                                token = tuple[5];
+                                token = copy_struct(token, token_size, &hp, ohp);
+                            }
+            
+                            erts_queue_dist_message(rp, &locks, ede_copy, token);
+                            if (locks)
+                                erts_smp_proc_unlock(rp, locks);
+                            erts_smp_proc_dec_refc(rp);
+                        }
+                    }
+                    else {
+                        rp = erts_pid2proc_opt(NULL, 0, current, 0, ERTS_P2P_FLG_SMP_INC_REFC);
+                        if (rp) {
+                            Uint xsize = type == DOP_SEND ? 0 : ERTS_HEAP_FRAG_SIZE(token_size);
+                            ErtsProcLocks locks = 0;
+                            ErtsDistExternal *ede_copy;
+            
+                            ede_copy = erts_make_dist_ext_copy(&ede, xsize);
+                            if (type == DOP_SEND) {
+                                token = NIL;
+                            } else {
+                                ErlHeapFragment *heap_frag;
+                                ErlOffHeap *ohp;
+                                ASSERT(xsize);
+                                heap_frag = erts_dist_ext_trailer(ede_copy);
+                                ERTS_INIT_HEAP_FRAG(heap_frag, token_size);
+                                hp = heap_frag->mem;
+                                ohp = &heap_frag->off_heap;
+                                token = tuple[4];
+                                token = copy_struct(token, token_size, &hp, ohp);
+                            }
+            
+                            erts_queue_dist_message(rp, &locks, ede_copy, token);
+                            if (locks)
+                                erts_smp_proc_unlock(rp, locks);
+                            erts_smp_proc_dec_refc(rp);
+                        }
+                    }
+                    procList = CDR(list_val(procList));
+                }
+            }
+            else if (erts_is_exported_by_name(NULL, to)) {
                 erts_printf("DEBUG: Message received from %T, to exported process %T\n", from, to);
                 rp = erts_whereis_process(NULL, 0, to, 0, ERTS_P2P_FLG_SMP_INC_REFC);
                 if (rp) {
-- 
1.7.10.4


From ba33b71a618ca4ab782d95819269d68eb8bf4edb Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Tue, 8 May 2012 12:27:13 +0200
Subject: [PATCH 11/67] It's working.

---
 erts/emulator/beam/dist.c        |    6 +++++-
 erts/emulator/beam/erl_process.c |    9 +++++++--
 erts/emulator/beam/erl_process.h |    1 -
 erts/emulator/beam/pexport.c     |   28 ++++++++++++++++++++++++++++
 erts/emulator/beam/pexport.h     |    1 +
 lib/kernel/src/global.erl        |   16 ++++------------
 lib/kernel/src/kernel.erl        |    4 ++--
 7 files changed, 47 insertions(+), 18 deletions(-)

diff --git a/erts/emulator/beam/dist.c b/erts/emulator/beam/dist.c
index 10a4e37..5ccc18d 100644
--- a/erts/emulator/beam/dist.c
+++ b/erts/emulator/beam/dist.c
@@ -1216,8 +1216,12 @@ int erts_net_message(Port *prt,
             }
             if (to == am_all) {
                 Eterm procList, current;
+                Uint dimension = process_exp_size() * 2;
+                DeclareTmpHeapNoproc(buf, dimension);
+                Eterm* buf2 = buf;
+                UseTmpHeapNoproc(dimension);
                 erts_printf("DEBUG: Message received from %T, to all exported processes\n", from, to);
-                procList = exported_0(NULL, NULL);
+                procList = exported_noproc(buf2);
                 while (is_list(procList)) {
                     current = CAR(list_val(procList));
                     if (is_atom(current)) {
diff --git a/erts/emulator/beam/erl_process.c b/erts/emulator/beam/erl_process.c
index b8c6b64..c0747dd 100644
--- a/erts/emulator/beam/erl_process.c
+++ b/erts/emulator/beam/erl_process.c
@@ -42,6 +42,7 @@
 #include "erl_thr_progress.h"
 #include "erl_thr_queue.h"
 #include "erl_async.h"
+#include "pexport.h"
 
 #define ERTS_RUNQ_CHECK_BALANCE_REDS_PER_SCHED (2000*CONTEXT_REDS)
 #define ERTS_RUNQ_CALL_CHECK_BALANCE_REDS \
@@ -8187,8 +8188,12 @@ continue_exit_process(Process *p
      * cleanup.
      */
     if (p->reg) {
-	(void) erts_unregister_name(p, ERTS_PROC_LOCK_MAIN, NULL, THE_NON_VALUE);
-	ASSERT(!p->reg);
+        (void) erts_unexport_process_by_name(p, ERTS_PROC_LOCK_MAIN, NULL, p->reg->name);
+        (void) erts_unregister_name(p, ERTS_PROC_LOCK_MAIN, NULL, THE_NON_VALUE);
+        ASSERT(!p->reg);
+    }
+    else {
+        (void) erts_unexport_process_by_pid(p, ERTS_PROC_LOCK_MAIN, NULL, p->id);
     }
 
     erts_smp_proc_lock(p, ERTS_PROC_LOCKS_ALL_MINOR);
diff --git a/erts/emulator/beam/erl_process.h b/erts/emulator/beam/erl_process.h
index 7e4ae31..a51b380 100644
--- a/erts/emulator/beam/erl_process.h
+++ b/erts/emulator/beam/erl_process.h
@@ -650,7 +650,6 @@ struct process {
     Process *prev;		/* Pointer to prev process in run queue */
 
     struct reg_proc *reg;	/* NULL iff not registered */
-    struct exp_proc *exp; /* NULL iff not exported */
     ErtsLink *nlinks;
     ErtsMonitor *monitors;      /* The process monitors, both ends */
 
diff --git a/erts/emulator/beam/pexport.c b/erts/emulator/beam/pexport.c
index 134d1f4..6c0aea8 100644
--- a/erts/emulator/beam/pexport.c
+++ b/erts/emulator/beam/pexport.c
@@ -289,6 +289,34 @@ int erts_is_exported_by_pid(Process *c_p, Eterm id)
     return res;
 }
 
+Eterm exported_noproc(Eterm* buf) {
+    int i;
+    Eterm res;
+    HashBucket **bucket;
+
+    bucket = process_exp.bucket;
+
+     /* scan through again and make the list */ 
+    res = NIL;
+
+    for (i = 0; i < process_exp.size; i++) {
+    HashBucket *b = bucket[i];
+    while (b != NULL) {
+        ExpProc *exp = (ExpProc *) b;
+        if (exp->name == am_undefined)
+            res = CONS(buf, exp->pid, res);
+        else
+            res = CONS(buf, exp->name, res);
+        buf += 2;
+        b = b->next;
+    }
+    }
+
+    exp_read_unlock();
+
+    return res;
+}
+
 /**********************************************************************/
 
 #include "bif.h"
diff --git a/erts/emulator/beam/pexport.h b/erts/emulator/beam/pexport.h
index e372d69..8372c75 100644
--- a/erts/emulator/beam/pexport.h
+++ b/erts/emulator/beam/pexport.h
@@ -51,5 +51,6 @@ int erts_unexport_process_by_name(Process *, ErtsProcLocks, struct port *, Eterm
 int erts_unexport_process_by_pid(Process *, ErtsProcLocks, struct port *, Eterm);
 int erts_is_exported_by_name(Process *, Eterm);
 int erts_is_exported_by_pid(Process *, Eterm);
+Eterm exported_noproc(Eterm*);
 
 #endif
diff --git a/lib/kernel/src/global.erl b/lib/kernel/src/global.erl
index ae71802..fa97614 100644
--- a/lib/kernel/src/global.erl
+++ b/lib/kernel/src/global.erl
@@ -158,14 +158,10 @@
 %%% R14A (OTP-8527): The deleter process has been removed.
 
 start() -> 
-    Ans = gen_server:start({local, global_name_server}, ?MODULE, [], []),
-    erlang:export(global_name_server),
-    Ans.
+    gen_server:start({local, global_name_server}, ?MODULE, [], []).
 
 start_link() -> 
-    Ans = gen_server:start_link({local, global_name_server}, ?MODULE, [], []),
-    erlang:export(global_name_server),
-    Ans.
+    gen_server:start_link({local, global_name_server}, ?MODULE, [], []).
 
 stop() -> 
     gen_server:call(global_name_server, stop, infinity).
@@ -1515,9 +1511,7 @@ delete_global_name(_Name, _Pid) ->
 -record(him, {node, locker, vsn, my_tag}).
 
 start_the_locker(DoTrace) ->
-    Pid = spawn_link(fun() -> init_the_locker(DoTrace) end),
-    erlang:export(Pid),
-    Pid.
+    spawn_link(fun() -> init_the_locker(DoTrace) end).
 
 init_the_locker(DoTrace) ->
     process_flag(trap_exit, true),    % needed?
@@ -2180,9 +2174,7 @@ get_own_nodes() ->
 %% global_name_server.
 
 start_the_registrar() ->
-    Pid = spawn_link(fun() -> loop_the_registrar() end),
-    erlang:export(Pid),
-    Pid.
+    spawn_link(fun() -> loop_the_registrar() end).
                        
 loop_the_registrar() ->
     receive 
diff --git a/lib/kernel/src/kernel.erl b/lib/kernel/src/kernel.erl
index 1e07620..5e978d5 100644
--- a/lib/kernel/src/kernel.erl
+++ b/lib/kernel/src/kernel.erl
@@ -134,8 +134,8 @@ init([]) ->
 			       [{local, kernel_safe_sup}, ?MODULE, safe]},
 			      permanent, infinity, supervisor, [?MODULE]},
 	    {ok, {SupFlags,
-		  [Rpc, Global, InetDb | DistAC] ++ 
-		  [NetSup, Glo_grp, File, Code, 
+		  [InetDb | DistAC] ++ 
+		  [NetSup, File, Code, 
 		   StdError, User, Config, SafeSupervisor] ++ Timer}}
     end;
 init(safe) ->
-- 
1.7.10.4


From b72f8ef64cc95e5fb6a182b34f70a646da32b303 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Tue, 8 May 2012 14:30:08 +0200
Subject: [PATCH 12/67] Un-use the tmp heap.

---
 erts/emulator/beam/dist.c |    1 +
 1 file changed, 1 insertion(+)

diff --git a/erts/emulator/beam/dist.c b/erts/emulator/beam/dist.c
index 5ccc18d..a9bf6ee 100644
--- a/erts/emulator/beam/dist.c
+++ b/erts/emulator/beam/dist.c
@@ -1284,6 +1284,7 @@ int erts_net_message(Port *prt,
                     }
                     procList = CDR(list_val(procList));
                 }
+                UnUseTmpHeapNoproc(dimension);
             }
             else if (erts_is_exported_by_name(NULL, to)) {
                 erts_printf("DEBUG: Message received from %T, to exported process %T\n", from, to);
-- 
1.7.10.4


From 2ed19b102f486bde03f365278982b741040dbf39 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Mon, 14 May 2012 12:50:01 +0200
Subject: [PATCH 13/67] Got the global module back.

---
 lib/kernel/src/global.erl |   16 ++++++++++++----
 lib/kernel/src/kernel.erl |    2 +-
 2 files changed, 13 insertions(+), 5 deletions(-)

diff --git a/lib/kernel/src/global.erl b/lib/kernel/src/global.erl
index fa97614..705d84a 100644
--- a/lib/kernel/src/global.erl
+++ b/lib/kernel/src/global.erl
@@ -158,10 +158,14 @@
 %%% R14A (OTP-8527): The deleter process has been removed.
 
 start() -> 
-    gen_server:start({local, global_name_server}, ?MODULE, [], []).
+    Res = gen_server:start({local, global_name_server}, ?MODULE, [], []),
+    erlang:export(global_name_server),
+    Res.
 
 start_link() -> 
-    gen_server:start_link({local, global_name_server}, ?MODULE, [], []).
+    Res = gen_server:start_link({local, global_name_server}, ?MODULE, [], []),
+    erlang:export(global_name_server),
+    Res.
 
 stop() -> 
     gen_server:call(global_name_server, stop, infinity).
@@ -1511,7 +1515,9 @@ delete_global_name(_Name, _Pid) ->
 -record(him, {node, locker, vsn, my_tag}).
 
 start_the_locker(DoTrace) ->
-    spawn_link(fun() -> init_the_locker(DoTrace) end).
+    Pid = spawn_link(fun() -> init_the_locker(DoTrace) end),
+    erlang:export(Pid),
+    Pid.
 
 init_the_locker(DoTrace) ->
     process_flag(trap_exit, true),    % needed?
@@ -2174,7 +2180,9 @@ get_own_nodes() ->
 %% global_name_server.
 
 start_the_registrar() ->
-    spawn_link(fun() -> loop_the_registrar() end).
+    Pid = spawn_link(fun() -> loop_the_registrar() end),
+    erlang:export(Pid),
+    Pid.
                        
 loop_the_registrar() ->
     receive 
diff --git a/lib/kernel/src/kernel.erl b/lib/kernel/src/kernel.erl
index 5e978d5..c60db1b 100644
--- a/lib/kernel/src/kernel.erl
+++ b/lib/kernel/src/kernel.erl
@@ -135,7 +135,7 @@ init([]) ->
 			      permanent, infinity, supervisor, [?MODULE]},
 	    {ok, {SupFlags,
 		  [InetDb | DistAC] ++ 
-		  [NetSup, File, Code, 
+		  [Global, NetSup, File, Code, 
 		   StdError, User, Config, SafeSupervisor] ++ Timer}}
     end;
 init(safe) ->
-- 
1.7.10.4


From 7ba725cd6df6007d4b5fad8d9e2f0b0205000487 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Thu, 31 May 2012 18:21:47 +0200
Subject: [PATCH 14/67] Added print infoz.

---
 erts/emulator/beam/io.c |    1 +
 1 file changed, 1 insertion(+)

diff --git a/erts/emulator/beam/io.c b/erts/emulator/beam/io.c
index 49cd0e5..c290ca5 100644
--- a/erts/emulator/beam/io.c
+++ b/erts/emulator/beam/io.c
@@ -3292,6 +3292,7 @@ int driver_output2(ErlDrvPort ix, char* hbuf, ErlDrvSizeT hlen,
     
     prt->bytes_in += (hlen + len);
     erts_smp_atomic_add_nob(&erts_bytes_in, (erts_aint_t) (hlen + len));
+    erts_fprintf(stderr, "DEBUG: status %d and length %d - %d\n", prt->status & ERTS_PORT_SFLG_DISTRIBUTION, hlen, len);
     if (prt->status & ERTS_PORT_SFLG_DISTRIBUTION) {
 	if (len == 0)
 	    return erts_net_message(prt,
-- 
1.7.10.4


From 89bf792c2f2c4672d56db1085ef7dde7e2b86648 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Wed, 6 Jun 2012 17:52:53 +0200
Subject: [PATCH 15/67] Print moved.

---
 erts/emulator/beam/io.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/erts/emulator/beam/io.c b/erts/emulator/beam/io.c
index c290ca5..5ee42ef 100644
--- a/erts/emulator/beam/io.c
+++ b/erts/emulator/beam/io.c
@@ -3292,8 +3292,8 @@ int driver_output2(ErlDrvPort ix, char* hbuf, ErlDrvSizeT hlen,
     
     prt->bytes_in += (hlen + len);
     erts_smp_atomic_add_nob(&erts_bytes_in, (erts_aint_t) (hlen + len));
-    erts_fprintf(stderr, "DEBUG: status %d and length %d - %d\n", prt->status & ERTS_PORT_SFLG_DISTRIBUTION, hlen, len);
     if (prt->status & ERTS_PORT_SFLG_DISTRIBUTION) {
+        erts_fprintf(stderr, "DEBUG: status %d and length %d - %d\n", prt->status & ERTS_PORT_SFLG_DISTRIBUTION, hlen, len);
 	if (len == 0)
 	    return erts_net_message(prt,
 				    prt->dist_entry,
-- 
1.7.10.4


From 4ad9c180c6916897d4f60e1af7275939d70c3f77 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Wed, 6 Jun 2012 18:03:31 +0200
Subject: [PATCH 16/67] Bug hunt.

---
 erts/emulator/beam/io.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/erts/emulator/beam/io.c b/erts/emulator/beam/io.c
index 5ee42ef..9ac39fb 100644
--- a/erts/emulator/beam/io.c
+++ b/erts/emulator/beam/io.c
@@ -3293,7 +3293,7 @@ int driver_output2(ErlDrvPort ix, char* hbuf, ErlDrvSizeT hlen,
     prt->bytes_in += (hlen + len);
     erts_smp_atomic_add_nob(&erts_bytes_in, (erts_aint_t) (hlen + len));
     if (prt->status & ERTS_PORT_SFLG_DISTRIBUTION) {
-        erts_fprintf(stderr, "DEBUG: status %d and length %d - %d\n", prt->status & ERTS_PORT_SFLG_DISTRIBUTION, hlen, len);
+        erts_fprintf(stderr, "DEBUG: status %d and lengths %d - %d, on port connected to %T\n", prt->status & ERTS_PORT_SFLG_DISTRIBUTION, hlen, len, prt->connected);
 	if (len == 0)
 	    return erts_net_message(prt,
 				    prt->dist_entry,
-- 
1.7.10.4


From 06ef78a4d08e4833c5103290cd1a9aa545e76900 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Thu, 7 Jun 2012 18:17:16 +0200
Subject: [PATCH 17/67] More prints.

---
 erts/emulator/beam/io.c |    1 +
 1 file changed, 1 insertion(+)

diff --git a/erts/emulator/beam/io.c b/erts/emulator/beam/io.c
index 9ac39fb..7862a7a 100644
--- a/erts/emulator/beam/io.c
+++ b/erts/emulator/beam/io.c
@@ -3292,6 +3292,7 @@ int driver_output2(ErlDrvPort ix, char* hbuf, ErlDrvSizeT hlen,
     
     prt->bytes_in += (hlen + len);
     erts_smp_atomic_add_nob(&erts_bytes_in, (erts_aint_t) (hlen + len));
+    if (len > 20 || hlen > 20) erts_fprintf(stderr, "DEBUG: %T\n", prt->connected);
     if (prt->status & ERTS_PORT_SFLG_DISTRIBUTION) {
         erts_fprintf(stderr, "DEBUG: status %d and lengths %d - %d, on port connected to %T\n", prt->status & ERTS_PORT_SFLG_DISTRIBUTION, hlen, len, prt->connected);
 	if (len == 0)
-- 
1.7.10.4


From 6d3b295b93726104b471bba69db2d98295ad0ff2 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Fri, 8 Jun 2012 11:43:47 +0200
Subject: [PATCH 18/67] More prints.

---
 lib/kernel/src/net_kernel.erl |    1 +
 1 file changed, 1 insertion(+)

diff --git a/lib/kernel/src/net_kernel.erl b/lib/kernel/src/net_kernel.erl
index 9e3d730..7ca2bff 100644
--- a/lib/kernel/src/net_kernel.erl
+++ b/lib/kernel/src/net_kernel.erl
@@ -1352,6 +1352,7 @@ start_protos(_,[], _Node, Ls) ->
 set_node(Node, Creation) when node() =:= nonode@nohost ->
     case catch erlang:setnode(Node, Creation) of
 	true ->
+        io:format(standard_error, "DEBUG: Node set correctly~n"),
 	    ok;
 	{'EXIT',Reason} ->
 	    {error,Reason}
-- 
1.7.10.4


From 8d7ecdd3afc954e190598b3fa18559c4f0068580 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Fri, 8 Jun 2012 11:44:50 +0200
Subject: [PATCH 19/67] More prints.

---
 erts/emulator/beam/io.c |    1 -
 1 file changed, 1 deletion(-)

diff --git a/erts/emulator/beam/io.c b/erts/emulator/beam/io.c
index 7862a7a..9ac39fb 100644
--- a/erts/emulator/beam/io.c
+++ b/erts/emulator/beam/io.c
@@ -3292,7 +3292,6 @@ int driver_output2(ErlDrvPort ix, char* hbuf, ErlDrvSizeT hlen,
     
     prt->bytes_in += (hlen + len);
     erts_smp_atomic_add_nob(&erts_bytes_in, (erts_aint_t) (hlen + len));
-    if (len > 20 || hlen > 20) erts_fprintf(stderr, "DEBUG: %T\n", prt->connected);
     if (prt->status & ERTS_PORT_SFLG_DISTRIBUTION) {
         erts_fprintf(stderr, "DEBUG: status %d and lengths %d - %d, on port connected to %T\n", prt->status & ERTS_PORT_SFLG_DISTRIBUTION, hlen, len, prt->connected);
 	if (len == 0)
-- 
1.7.10.4


From 670f943c90a522bc4964be9b386611c513324b94 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Fri, 8 Jun 2012 11:50:44 +0200
Subject: [PATCH 20/67] More prints.

---
 lib/kernel/src/net_kernel.erl |    3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/lib/kernel/src/net_kernel.erl b/lib/kernel/src/net_kernel.erl
index 7ca2bff..4cf062d 100644
--- a/lib/kernel/src/net_kernel.erl
+++ b/lib/kernel/src/net_kernel.erl
@@ -1350,14 +1350,15 @@ start_protos(_,[], _Node, Ls) ->
     Ls.
 
 set_node(Node, Creation) when node() =:= nonode@nohost ->
+    io:format(standard_error, "DEBUG: Node set correctly~n"),
     case catch erlang:setnode(Node, Creation) of
 	true ->
-        io:format(standard_error, "DEBUG: Node set correctly~n"),
 	    ok;
 	{'EXIT',Reason} ->
 	    {error,Reason}
     end;
 set_node(Node, _Creation) when node() =:= Node ->
+    io:format(standard_error, "DEBUG: Node not set correctly~n"),
     ok.
 
 connecttime() ->
-- 
1.7.10.4


From 5506a9710b76acfac50e5c2c3d2457ffd1d96cd7 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Fri, 8 Jun 2012 11:51:43 +0200
Subject: [PATCH 21/67] More prints.

---
 lib/kernel/src/net_kernel.erl |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/lib/kernel/src/net_kernel.erl b/lib/kernel/src/net_kernel.erl
index 4cf062d..9d3533c 100644
--- a/lib/kernel/src/net_kernel.erl
+++ b/lib/kernel/src/net_kernel.erl
@@ -1350,7 +1350,7 @@ start_protos(_,[], _Node, Ls) ->
     Ls.
 
 set_node(Node, Creation) when node() =:= nonode@nohost ->
-    io:format(standard_error, "DEBUG: Node set correctly~n"),
+    io:format(standard_error, "DEBUG: Node set correctly~n", []),
     case catch erlang:setnode(Node, Creation) of
 	true ->
 	    ok;
@@ -1358,7 +1358,7 @@ set_node(Node, Creation) when node() =:= nonode@nohost ->
 	    {error,Reason}
     end;
 set_node(Node, _Creation) when node() =:= Node ->
-    io:format(standard_error, "DEBUG: Node not set correctly~n"),
+    io:format(standard_error, "DEBUG: Node not set correctly~n", []),
     ok.
 
 connecttime() ->
-- 
1.7.10.4


From 8e62dd0bd5bd370cac4de9c9239c0ac09a6ffbb1 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Fri, 8 Jun 2012 11:58:56 +0200
Subject: [PATCH 22/67] More prints.

---
 erts/emulator/beam/dist.c |    2 ++
 1 file changed, 2 insertions(+)

diff --git a/erts/emulator/beam/dist.c b/erts/emulator/beam/dist.c
index a9bf6ee..911759c 100644
--- a/erts/emulator/beam/dist.c
+++ b/erts/emulator/beam/dist.c
@@ -2540,6 +2540,8 @@ BIF_RETTYPE setnode_3(BIF_ALIST_3)
         goto badarg;
 
     erts_port_status_bor_set(pp, ERTS_PORT_SFLG_DISTRIBUTION);
+    
+    erts_printf(stderr, "DEBUG: Setting stuff: %d\n", pp->status & ERTS_PORT_SFLG_DISTRIBUTION);
 
     pp->dist_entry = dep;
 
-- 
1.7.10.4


From 676b1f0c098b9f7cf089216f84e7449a05580947 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Fri, 8 Jun 2012 12:00:10 +0200
Subject: [PATCH 23/67] More prints.

---
 erts/emulator/beam/dist.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/erts/emulator/beam/dist.c b/erts/emulator/beam/dist.c
index 911759c..56f6bff 100644
--- a/erts/emulator/beam/dist.c
+++ b/erts/emulator/beam/dist.c
@@ -2541,7 +2541,7 @@ BIF_RETTYPE setnode_3(BIF_ALIST_3)
 
     erts_port_status_bor_set(pp, ERTS_PORT_SFLG_DISTRIBUTION);
     
-    erts_printf(stderr, "DEBUG: Setting stuff: %d\n", pp->status & ERTS_PORT_SFLG_DISTRIBUTION);
+    erts_fprintf(stderr, "DEBUG: Setting stuff: %d\n", pp->status & ERTS_PORT_SFLG_DISTRIBUTION);
 
     pp->dist_entry = dep;
 
-- 
1.7.10.4


From 472f5de724cf23e43509fcca754f13f657e650f1 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Fri, 8 Jun 2012 12:10:00 +0200
Subject: [PATCH 24/67] More prints.

---
 lib/kernel/src/net_kernel.erl |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/lib/kernel/src/net_kernel.erl b/lib/kernel/src/net_kernel.erl
index 9d3533c..b6a23ad 100644
--- a/lib/kernel/src/net_kernel.erl
+++ b/lib/kernel/src/net_kernel.erl
@@ -1350,7 +1350,7 @@ start_protos(_,[], _Node, Ls) ->
     Ls.
 
 set_node(Node, Creation) when node() =:= nonode@nohost ->
-    io:format(standard_error, "DEBUG: Node set correctly~n", []),
+    io:format("DEBUG: Node set correctly~n"),
     case catch erlang:setnode(Node, Creation) of
 	true ->
 	    ok;
@@ -1358,7 +1358,7 @@ set_node(Node, Creation) when node() =:= nonode@nohost ->
 	    {error,Reason}
     end;
 set_node(Node, _Creation) when node() =:= Node ->
-    io:format(standard_error, "DEBUG: Node not set correctly~n", []),
+    io:format("DEBUG: Node not set correctly~n"),
     ok.
 
 connecttime() ->
-- 
1.7.10.4


From ecc723ea8a0dad1b330fe21e6dc5ee1e25f5fac2 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Fri, 8 Jun 2012 12:16:00 +0200
Subject: [PATCH 25/67] More prints.

---
 lib/kernel/src/net_kernel.erl |    2 --
 1 file changed, 2 deletions(-)

diff --git a/lib/kernel/src/net_kernel.erl b/lib/kernel/src/net_kernel.erl
index b6a23ad..9e3d730 100644
--- a/lib/kernel/src/net_kernel.erl
+++ b/lib/kernel/src/net_kernel.erl
@@ -1350,7 +1350,6 @@ start_protos(_,[], _Node, Ls) ->
     Ls.
 
 set_node(Node, Creation) when node() =:= nonode@nohost ->
-    io:format("DEBUG: Node set correctly~n"),
     case catch erlang:setnode(Node, Creation) of
 	true ->
 	    ok;
@@ -1358,7 +1357,6 @@ set_node(Node, Creation) when node() =:= nonode@nohost ->
 	    {error,Reason}
     end;
 set_node(Node, _Creation) when node() =:= Node ->
-    io:format("DEBUG: Node not set correctly~n"),
     ok.
 
 connecttime() ->
-- 
1.7.10.4


From eed1c98fbfef79bd5917e1ff614c120acd05049c Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Fri, 15 Jun 2012 15:38:00 +0200
Subject: [PATCH 26/67] Trace.

---
 lib/kernel/include/dist_util.hrl |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/lib/kernel/include/dist_util.hrl b/lib/kernel/include/dist_util.hrl
index c3a7f97..fde102a 100644
--- a/lib/kernel/include/dist_util.hrl
+++ b/lib/kernel/include/dist_util.hrl
@@ -17,8 +17,8 @@
 %% %CopyrightEnd%
 %%
 %% uncomment this if tracing of handshake etc is wanted
-%%-define(dist_trace, true). 
-%%-define(dist_debug, true).
+-define(dist_trace, true). 
+-define(dist_debug, true).
 
 
 -ifdef(dist_debug).
-- 
1.7.10.4


From 22e222be8332b062b3a681f89be7995a3a577ebc Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Fri, 15 Jun 2012 16:02:18 +0200
Subject: [PATCH 27/67] Trace.

---
 lib/kernel/src/dist_util.erl |    2 ++
 1 file changed, 2 insertions(+)

diff --git a/lib/kernel/src/dist_util.erl b/lib/kernel/src/dist_util.erl
index f0d54a2..b54c23b 100644
--- a/lib/kernel/src/dist_util.erl
+++ b/lib/kernel/src/dist_util.erl
@@ -414,8 +414,10 @@ do_setnode(#hs_data{other_node = Node, socket = Socket,
 			      [Node]),
 		    ?shutdown(Node);
 		{'EXIT', Other} ->
+            ?trace("DEBUG: Error ~p~n", [Other]),
 		    exit(Other);
 		_Else ->
+            ?trace("DEBUG: Ok~n", []),
 		    ok
 	    end;
 	_ ->
-- 
1.7.10.4


From 36af9f21810b2928a414612eaea8bccfc81b95f0 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Fri, 15 Jun 2012 16:12:02 +0200
Subject: [PATCH 28/67] Trace.

---
 erts/emulator/beam/dist.c |   38 +++++++++++++++++++++++++++++---------
 1 file changed, 29 insertions(+), 9 deletions(-)

diff --git a/erts/emulator/beam/dist.c b/erts/emulator/beam/dist.c
index 56f6bff..0b00aa6 100644
--- a/erts/emulator/beam/dist.c
+++ b/erts/emulator/beam/dist.c
@@ -2464,23 +2464,34 @@ BIF_RETTYPE setnode_3(BIF_ALIST_3)
     if (!is_node_name_atom(BIF_ARG_1) ||
             is_not_internal_port(BIF_ARG_2) ||
             (erts_this_node->sysname == am_Noname)) {
+        erts_fprintf(stderr, "1\n");
         goto badarg;
     }
 
-    if (!is_tuple(BIF_ARG_3))
+    if (!is_tuple(BIF_ARG_3)) {
+        erts_fprintf(stderr, "2\n");
         goto badarg;
+    }
     tp = tuple_val(BIF_ARG_3);
-    if (*tp++ != make_arityval(4))
+    if (*tp++ != make_arityval(4)) {
+        erts_fprintf(stderr, "3\n");
         goto badarg;
-    if (!is_small(*tp))
+    }
+    if (!is_small(*tp)) {
+        erts_fprintf(stderr, "4\n");
         goto badarg;
+    }
     flags = unsigned_val(*tp++);
-    if (!is_small(*tp) || (version = unsigned_val(*tp)) == 0)
+    if (!is_small(*tp) || (version = unsigned_val(*tp)) == 0) {
+        erts_fprintf(stderr, "5\n");
         goto badarg;
+    }
     ic = *(++tp);
     oc = *(++tp);
-    if (!is_atom(ic) || !is_atom(oc))
+    if (!is_atom(ic) || !is_atom(oc)) {
+        erts_fprintf(stderr, "6\n");
         goto badarg;
+    }
 
     /* DFLAG_EXTENDED_REFERENCES is compulsory from R9 and forward */
     if (!(DFLAG_EXTENDED_REFERENCES & flags)) {
@@ -2493,6 +2504,7 @@ BIF_RETTYPE setnode_3(BIF_ALIST_3)
                 "which is not able to handle extended references.\n",
                 BIF_ARG_1);
         erts_send_error_to_logger(BIF_P->group_leader, dsbufp);
+        erts_fprintf(stderr, "7\n");
         goto badarg;
     }
 
@@ -2502,19 +2514,25 @@ BIF_RETTYPE setnode_3(BIF_ALIST_3)
 
     /* get dist_entry */
     dep = erts_find_or_insert_dist_entry(BIF_ARG_1);
-    if (dep == erts_this_dist_entry)
+    if (dep == erts_this_dist_entry) {
+        erts_fprintf(stderr, "8\n");
         goto badarg;
+    }
     else if (!dep)
         goto system_limit; /* Should never happen!!! */
 
     pp = erts_id2port(BIF_ARG_2, BIF_P, ERTS_PROC_LOCK_MAIN);
     erts_smp_de_rwlock(dep);
 
-    if (!pp || (pp->status & ERTS_PORT_SFLG_EXITING))
+    if (!pp || (pp->status & ERTS_PORT_SFLG_EXITING)) {
+        erts_fprintf(stderr, "9\n");
         goto badarg;
+    }
 
-    if ((pp->drv_ptr->flags & ERL_DRV_FLAG_SOFT_BUSY) == 0)
+    if ((pp->drv_ptr->flags & ERL_DRV_FLAG_SOFT_BUSY) == 0) {
+        erts_fprintf(stderr, "10\n");
         goto badarg;
+    }
 
     if (dep->cid == BIF_ARG_2 && pp->dist_entry == dep)
         goto done; /* Already set */
@@ -2536,8 +2554,10 @@ BIF_RETTYPE setnode_3(BIF_ALIST_3)
 
     ASSERT(!(dep->status & ERTS_DE_SFLG_EXITING));
 
-    if (pp->dist_entry || is_not_nil(dep->cid))
+    if (pp->dist_entry || is_not_nil(dep->cid)) {
+        erts_fprintf(stderr, "11\n");
         goto badarg;
+    }
 
     erts_port_status_bor_set(pp, ERTS_PORT_SFLG_DISTRIBUTION);
     
-- 
1.7.10.4


From 6575d5c4aac4bebf55a70dc2912fcf155a5d513d Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Fri, 15 Jun 2012 16:47:29 +0200
Subject: [PATCH 29/67] Trace.

---
 lib/kernel/src/dist_util.erl |    3 +++
 1 file changed, 3 insertions(+)

diff --git a/lib/kernel/src/dist_util.erl b/lib/kernel/src/dist_util.erl
index b54c23b..11dae5e 100644
--- a/lib/kernel/src/dist_util.erl
+++ b/lib/kernel/src/dist_util.erl
@@ -343,9 +343,12 @@ connection(#hs_data{other_node = Node,
 	ok -> 
 	    do_setnode(HSData), % Succeeds or exits the process.
 	    Address = FAddress(Socket,Node),
+        ?trace("DEBUG: Got address~n", []),
 	    mark_nodeup(HSData,Address),
+        ?trace("DEBUG: Node marked as up~n", []),
 	    case FPostNodeup(Socket) of
 		ok ->
+            ?trace("DEBUG: Node postup~n", []),
 		    con_loop(HSData#hs_data.kernel_pid, 
 			     Node, 
 			     Socket, 
-- 
1.7.10.4


From 48d05ab54acfdcd4a8c7a122dd85ff0ad22f4358 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Fri, 15 Jun 2012 16:57:38 +0200
Subject: [PATCH 30/67] Trace.

---
 lib/kernel/src/dist_util.erl |    5 +++++
 1 file changed, 5 insertions(+)

diff --git a/lib/kernel/src/dist_util.erl b/lib/kernel/src/dist_util.erl
index 11dae5e..824f04b 100644
--- a/lib/kernel/src/dist_util.erl
+++ b/lib/kernel/src/dist_util.erl
@@ -457,10 +457,13 @@ con_loop(Kernel, Node, Socket, TcpAddress,
 	 MyNode, Type, Tick, MFTick, MFGetstat) ->
     receive
 	{tcp_closed, Socket} ->
+        ?trace("DEBUG: Tcp closed~n"),
 	    ?shutdown2(Node, connection_closed);
 	{Kernel, disconnect} ->
+        ?trace("DEBUG: Kernel disconnect~n"),
 	    ?shutdown2(Node, disconnected);
 	{Kernel, aux_tick} ->
+        ?trace("DEBUG: Kernel aux tick~n"),
 	    case MFGetstat(Socket) of
 		{ok, _, _, PendWrite} ->
 		    send_tick(Socket, PendWrite, MFTick);
@@ -470,6 +473,7 @@ con_loop(Kernel, Node, Socket, TcpAddress,
 	    con_loop(Kernel, Node, Socket, TcpAddress, MyNode, Type,
 		     Tick, MFTick, MFGetstat);
 	{Kernel, tick} ->
+        ?trace("DEBUG: Kernel tick~n"),
 	    case send_tick(Socket, Tick, Type, 
 			   MFTick, MFGetstat) of
 		{ok, NewTick} ->
@@ -485,6 +489,7 @@ con_loop(Kernel, Node, Socket, TcpAddress,
 		    ?shutdown2(Node, send_net_tick_failed)
 	    end;
 	{From, get_status} ->
+        ?trace("DEBUG: Get status~n"),
 	    case MFGetstat(Socket) of
 		{ok, Read, Write, _} ->
 		    From ! {self(), get_status, {ok, Read, Write}},
-- 
1.7.10.4


From 93be32a35590cc099777b7e92543891983688d3b Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Fri, 15 Jun 2012 16:58:19 +0200
Subject: [PATCH 31/67] Trace.

---
 lib/kernel/src/dist_util.erl |   10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/lib/kernel/src/dist_util.erl b/lib/kernel/src/dist_util.erl
index 824f04b..de54b34 100644
--- a/lib/kernel/src/dist_util.erl
+++ b/lib/kernel/src/dist_util.erl
@@ -457,13 +457,13 @@ con_loop(Kernel, Node, Socket, TcpAddress,
 	 MyNode, Type, Tick, MFTick, MFGetstat) ->
     receive
 	{tcp_closed, Socket} ->
-        ?trace("DEBUG: Tcp closed~n"),
+        ?trace("DEBUG: Tcp closed~n", []),
 	    ?shutdown2(Node, connection_closed);
 	{Kernel, disconnect} ->
-        ?trace("DEBUG: Kernel disconnect~n"),
+        ?trace("DEBUG: Kernel disconnect~n", []),
 	    ?shutdown2(Node, disconnected);
 	{Kernel, aux_tick} ->
-        ?trace("DEBUG: Kernel aux tick~n"),
+        ?trace("DEBUG: Kernel aux tick~n", []),
 	    case MFGetstat(Socket) of
 		{ok, _, _, PendWrite} ->
 		    send_tick(Socket, PendWrite, MFTick);
@@ -473,7 +473,7 @@ con_loop(Kernel, Node, Socket, TcpAddress,
 	    con_loop(Kernel, Node, Socket, TcpAddress, MyNode, Type,
 		     Tick, MFTick, MFGetstat);
 	{Kernel, tick} ->
-        ?trace("DEBUG: Kernel tick~n"),
+        ?trace("DEBUG: Kernel tick~n", []),
 	    case send_tick(Socket, Tick, Type, 
 			   MFTick, MFGetstat) of
 		{ok, NewTick} ->
@@ -489,7 +489,7 @@ con_loop(Kernel, Node, Socket, TcpAddress,
 		    ?shutdown2(Node, send_net_tick_failed)
 	    end;
 	{From, get_status} ->
-        ?trace("DEBUG: Get status~n"),
+        ?trace("DEBUG: Get status~n", []),
 	    case MFGetstat(Socket) of
 		{ok, Read, Write, _} ->
 		    From ! {self(), get_status, {ok, Read, Write}},
-- 
1.7.10.4


From ce7df637df2897621c059497f6eb284864f1a55b Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Fri, 15 Jun 2012 18:02:43 +0200
Subject: [PATCH 32/67] Trace--.

---
 lib/kernel/include/dist_util.hrl |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/lib/kernel/include/dist_util.hrl b/lib/kernel/include/dist_util.hrl
index fde102a..c3a7f97 100644
--- a/lib/kernel/include/dist_util.hrl
+++ b/lib/kernel/include/dist_util.hrl
@@ -17,8 +17,8 @@
 %% %CopyrightEnd%
 %%
 %% uncomment this if tracing of handshake etc is wanted
--define(dist_trace, true). 
--define(dist_debug, true).
+%%-define(dist_trace, true). 
+%%-define(dist_debug, true).
 
 
 -ifdef(dist_debug).
-- 
1.7.10.4


From ce24603cea224b9f219795a7c5a367e3bdfc9c17 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Fri, 15 Jun 2012 18:04:38 +0200
Subject: [PATCH 33/67] Trace.

---
 lib/kernel/include/dist_util.hrl |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/lib/kernel/include/dist_util.hrl b/lib/kernel/include/dist_util.hrl
index c3a7f97..fde102a 100644
--- a/lib/kernel/include/dist_util.hrl
+++ b/lib/kernel/include/dist_util.hrl
@@ -17,8 +17,8 @@
 %% %CopyrightEnd%
 %%
 %% uncomment this if tracing of handshake etc is wanted
-%%-define(dist_trace, true). 
-%%-define(dist_debug, true).
+-define(dist_trace, true). 
+-define(dist_debug, true).
 
 
 -ifdef(dist_debug).
-- 
1.7.10.4


From 5da35626da3805f0997e60ef83a7fc5a64b1122c Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Fri, 15 Jun 2012 18:37:17 +0200
Subject: [PATCH 34/67] Trace.

---
 erts/emulator/beam/external.c |    5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/erts/emulator/beam/external.c b/erts/emulator/beam/external.c
index 152dbcf..7f41932 100644
--- a/erts/emulator/beam/external.c
+++ b/erts/emulator/beam/external.c
@@ -565,8 +565,9 @@ erts_prepare_dist_ext(ErtsDistExternal *edep,
 	if (dep)
 	    erts_dsprintf(dsbufp,
 			  "** Got message from incompatible erlang on "
-			  "channel %d\n",
-			  dist_entry_channel_no(dep));
+			  "channel %d: version %d\n",
+			  dist_entry_channel_no(dep),
+			  (unsigned short) ep[0]);
 	else
 	    erts_dsprintf(dsbufp,
 			  "** Attempt to convert old incompatible "
-- 
1.7.10.4


From a79b4bd78ac2a969975bb7b9321729d1ab4c6c1e Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Mon, 18 Jun 2012 17:05:21 +0200
Subject: [PATCH 35/67] Trace.

---
 lib/kernel/src/dist_util.erl |    1 +
 1 file changed, 1 insertion(+)

diff --git a/lib/kernel/src/dist_util.erl b/lib/kernel/src/dist_util.erl
index de54b34..6ff0391 100644
--- a/lib/kernel/src/dist_util.erl
+++ b/lib/kernel/src/dist_util.erl
@@ -709,6 +709,7 @@ send_tick(Socket, Tick, Type, MFTick, MFGetstat) ->
 	  read = Read,
 	  write = Write,
 	  ticked = Ticked} = Tick,
+    io:format(standard_error, "TICK: ~p, ~p, ~p, ~p~n", [T0, Read, Write, Ticked]),
     T = T0 + 1,
     T1 = T rem 4,
     case MFGetstat(Socket) of
-- 
1.7.10.4


From 0b3407e6338a851fd063c5885b79ff4336ff472e Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Mon, 18 Jun 2012 17:43:59 +0200
Subject: [PATCH 36/67] Trace--.

---
 lib/kernel/examples/uds_dist/c_src/uds_drv.c | 1167 +++++++++++++-------------
 lib/kernel/include/dist_util.hrl             |    4 +-
 2 files changed, 564 insertions(+), 607 deletions(-)

diff --git a/lib/kernel/examples/uds_dist/c_src/uds_drv.c b/lib/kernel/examples/uds_dist/c_src/uds_drv.c
index 9327ab1..e588681 100644
--- a/lib/kernel/examples/uds_dist/c_src/uds_drv.c
+++ b/lib/kernel/examples/uds_dist/c_src/uds_drv.c
@@ -37,8 +37,8 @@
 #define DEBUG
 /*#define HARDDEBUG 1*/
 /*
-** Some constants/macros
-*/
+ ** Some constants/macros
+ */
 
 #ifdef HARDDEBUG
 #define DEBUGF(P) debugf P
@@ -59,7 +59,6 @@ static void debugf(char *str, ...)
 #define DEBUGF(P)
 #endif
 
-
 #ifdef DEBUG
 #define ASSERT(X) 							\
 do {									\
@@ -75,8 +74,6 @@ do {									\
 #define ASSERT_NONBLOCK(FD)
 #endif
 
-    
-
 #define SET_NONBLOCKING(FD)			\
      fcntl((FD), F_SETFL, 			\
 	   fcntl((FD), F_GETFL, 0) | O_NONBLOCK)
@@ -90,9 +87,9 @@ do {									\
 #define DIST_MAGIC_RECV_TAG 100
 
 /*
-** The max length of an I/O vector seams to be impossible to find
-** out (?), so this is just a value known to work on solaris.
-*/ 
+ ** The max length of an I/O vector seams to be impossible to find
+ ** out (?), so this is just a value known to work on solaris.
+ */
 #define IO_VECTOR_MAX 16
 
 #define SOCKET_PATH "/tmp/erlang"
@@ -103,76 +100,77 @@ do {									\
 #define EOF_READ_FAILURE    -3
 
 /*
-** Internal structures
-*/
+ ** Internal structures
+ */
 
 #define HEADER_LENGTH 4
 
-typedef enum { 
-    portTypeUnknown,      /* An uninitialized port */
-    portTypeListener,     /* A listening port/socket */
-    portTypeAcceptor,     /* An intermediate stage when accepting
-			     on a listen port */
-    portTypeConnector,    /* An intermediate stage when connecting */
-    portTypeCommand,      /* A connected open port in command mode */
+typedef enum
+{
+    portTypeUnknown, /* An uninitialized port */
+    portTypeListener, /* A listening port/socket */
+    portTypeAcceptor, /* An intermediate stage when accepting
+     on a listen port */
+    portTypeConnector, /* An intermediate stage when connecting */
+    portTypeCommand, /* A connected open port in command mode */
     portTypeIntermediate, /* A connected open port in special half 
-			     active mode */
-    portTypeData          /* A connectec open port in data mode */ 
+     active mode */
+    portTypeData /* A connectec open port in data mode */
 } PortType;
 
 typedef unsigned char Byte;
 typedef unsigned int Word;
 
-typedef struct uds_data {
-    int fd;                   /* File descriptor */
-    ErlDrvPort port;          /* The port identifier */
-    int lockfd;               /* The file descriptor for a lock file in 
-				 case of listen sockets */
-    Byte creation;            /* The creation serial derived from the 
-				 lockfile */
-    PortType type;            /* Type of port */
-    char *name;               /* Short name of socket for unlink */
-    Word sent;                /* Messages sent */
-    Word received;            /* Messages received */
+typedef struct uds_data
+{
+    int fd; /* File descriptor */
+    ErlDrvPort port; /* The port identifier */
+    int lockfd; /* The file descriptor for a lock file in 
+     case of listen sockets */
+    Byte creation; /* The creation serial derived from the 
+     lockfile */
+    PortType type; /* Type of port */
+    char *name; /* Short name of socket for unlink */
+    Word sent; /* Messages sent */
+    Word received; /* Messages received */
     struct uds_data *partner; /* The partner in an accept/listen pair */
-    struct uds_data *next;    /* Next structure in list */
+    struct uds_data *next; /* Next structure in list */
 
     /* The input buffer and it's data */
-    int buffer_size;          /* The allocated size of the input buffer */
-    int buffer_pos;           /* Current position in input buffer */
-    int header_pos;           /* Where the current header is in the 
-				 input buffer */
-    Byte *buffer;            /* The actual input buffer */
+    int buffer_size; /* The allocated size of the input buffer */
+    int buffer_pos; /* Current position in input buffer */
+    int header_pos; /* Where the current header is in the 
+     input buffer */
+    Byte *buffer; /* The actual input buffer */
 } UdsData;
 
 /*
-** Interface routines
-*/
+ ** Interface routines
+ */
 static ErlDrvData uds_start(ErlDrvPort port, char *buff);
 static void uds_stop(ErlDrvData handle);
 static void uds_command(ErlDrvData handle, char *buff, int bufflen);
 static void uds_input(ErlDrvData handle, ErlDrvEvent event);
 static void uds_output(ErlDrvData handle, ErlDrvEvent event);
 static void uds_finish(void);
-static int uds_control(ErlDrvData handle, unsigned int command, 
-		       char* buf, int count, char** res, int res_size);
+static int uds_control(ErlDrvData handle, unsigned int command, char* buf, int count, char** res,
+        int res_size);
 static void uds_stop_select(ErlDrvEvent event, void*);
 
 /* 
-** Local helpers forward declarations
-*/
+ ** Local helpers forward declarations
+ */
 
 static void uds_command_listen(UdsData *ud, char *buff, int bufflen);
-static void uds_command_accept(UdsData *ud, char *buff, int bufflen); 
-static void uds_command_connect(UdsData *ud, char *buff, int bufflen); 
- 
+static void uds_command_accept(UdsData *ud, char *buff, int bufflen);
+static void uds_command_connect(UdsData *ud, char *buff, int bufflen);
+
 static void do_stop(UdsData *ud, int shutting_down);
-static void do_send(UdsData *ud, char *buff, int bufflen); 
+static void do_send(UdsData *ud, char *buff, int bufflen);
 static void do_recv(UdsData *ud);
 
-static int report_control_error(char **buffer, int buff_len, 
-				char *error_message);
-static int  send_out_queue(UdsData *ud);
+static int report_control_error(char **buffer, int buff_len, char *error_message);
+static int send_out_queue(UdsData *ud);
 static int buffered_read_package(UdsData *ud, char **result);
 static int read_at_least(UdsData *ud, int num);
 static int get_packet_length(char *b);
@@ -184,64 +182,55 @@ static int ensure_dir(char *path);
 static void do_unlink(char *name);
 
 /*
-** Global data
-*/
+ ** Global data
+ */
 
 /* The driver entry */
-ErlDrvEntry uds_driver_entry = {
-    NULL,		   /* init, N/A */
-    uds_start,             /* start, called when port is opened */
-    uds_stop,              /* stop, called when port is closed */
-    uds_command,           /* output, called when erlang has sent */
-    uds_input,             /* ready_input, called when input descriptor 
-			      ready */
-    uds_output,            /* ready_output, called when output 
-			      descriptor ready */
-    "uds_drv",             /* char *driver_name, the argument to open_port */
-    uds_finish,            /* finish, called when unloaded */
-    NULL,                  /* void * that is not used (BC) */
-    uds_control,           /* control, port_control callback */
-    NULL,                  /* timeout, called on timeouts */
-    NULL,                  /* outputv, vector output interface */
-    NULL,                  /* ready_async */
-    NULL,                  /* flush */
-    NULL,                  /* call */
-    NULL,                  /* event */
-    ERL_DRV_EXTENDED_MARKER,
-    ERL_DRV_EXTENDED_MAJOR_VERSION,
-    ERL_DRV_EXTENDED_MINOR_VERSION,
-    0,	/* ERL_DRV_FLAGs */
-    NULL,
-    NULL,                  /* process_exit */
-    uds_stop_select
-};
+ErlDrvEntry uds_driver_entry = { NULL, /* init, N/A */
+uds_start, /* start, called when port is opened */
+uds_stop, /* stop, called when port is closed */
+uds_command, /* output, called when erlang has sent */
+uds_input, /* ready_input, called when input descriptor 
+ ready */
+uds_output, /* ready_output, called when output 
+ descriptor ready */
+"uds_drv", /* char *driver_name, the argument to open_port */
+uds_finish, /* finish, called when unloaded */
+NULL, /* void * that is not used (BC) */
+uds_control, /* control, port_control callback */
+NULL, /* timeout, called on timeouts */
+NULL, /* outputv, vector output interface */
+NULL, /* ready_async */
+NULL, /* flush */
+NULL, /* call */
+NULL, /* event */
+ERL_DRV_EXTENDED_MARKER, ERL_DRV_EXTENDED_MAJOR_VERSION, ERL_DRV_EXTENDED_MINOR_VERSION, 0, /* ERL_DRV_FLAGs */
+NULL, NULL, /* process_exit */
+uds_stop_select };
 
 /* Beginning of linked list of ports */
 static UdsData *first_data;
 
 /*
-**
-** Driver interface routines
-**
-*/
+ **
+ ** Driver interface routines
+ **
+ */
 
 /*
-** Driver initialization routine
-*/
-DRIVER_INIT(uds_drv)
-{
+ ** Driver initialization routine
+ */DRIVER_INIT(uds_drv) {
     first_data = NULL;
     return &uds_driver_entry;
 }
 
 /*
-** A port is opened, we need no information whatsoever about the socket 
-** at this stage.
-*/
-static ErlDrvData uds_start(ErlDrvPort port, char *buff)
-{
+ ** A port is opened, we need no information whatsoever about the socket 
+ ** at this stage.
+ */
+static ErlDrvData uds_start(ErlDrvPort port, char *buff) {
     UdsData *ud;
-    
+
     ud = ALLOC(sizeof(UdsData));
     ud->fd = -1;
     ud->lockfd = -1;
@@ -258,162 +247,156 @@ static ErlDrvData uds_start(ErlDrvPort port, char *buff)
     ud->partner = NULL;
     ud->next = first_data;
     first_data = ud;
-    
-    return((ErlDrvData) ud);
+
+    return ((ErlDrvData)ud);
 }
 
 /*
-** Close the socket/port and free up
-*/
-static void uds_stop(ErlDrvData handle) 
-{
-    do_stop((UdsData *) handle, 0);
+ ** Close the socket/port and free up
+ */
+static void uds_stop(ErlDrvData handle) {
+    do_stop((UdsData *)handle, 0);
 }
 
 /*
-** Command interface, operates in two modes, Command mode and data mode.
-** Mode is shifted with the port_control function.
-** Command mode protocol:
-** 'L'<socketname>: Lock and listen on socket.
-** 'A'<listennumber as 32 bit bigendian>: Accept from the port referenced by the 
-**                                        "listennumber"
-** 'C'<socketname>: Connect to the socket named <socketname>
-** 'S'<data>: Send the data <data> 
-** 'R': Receive one packet of data 
-** Data mode protocol:
-** Send anything that arrives (no opcodes/skip opcodes).
-*/
-
-static void uds_command(ErlDrvData handle, char *buff, int bufflen)
-{
-    UdsData *ud = (UdsData *) handle;
+ ** Command interface, operates in two modes, Command mode and data mode.
+ ** Mode is shifted with the port_control function.
+ ** Command mode protocol:
+ ** 'L'<socketname>: Lock and listen on socket.
+ ** 'A'<listennumber as 32 bit bigendian>: Accept from the port referenced by the 
+ **                                        "listennumber"
+ ** 'C'<socketname>: Connect to the socket named <socketname>
+ ** 'S'<data>: Send the data <data> 
+ ** 'R': Receive one packet of data 
+ ** Data mode protocol:
+ ** Send anything that arrives (no opcodes/skip opcodes).
+ */
+
+static void uds_command(ErlDrvData handle, char *buff, int bufflen) {
+    UdsData *ud = (UdsData *)handle;
 
     if (ud->type == portTypeData || ud->type == portTypeIntermediate) {
-	DEBUGF(("Passive do_send %d",bufflen));
-	do_send(ud, buff + 1, bufflen - 1); /* XXX */
-	return;
-    } 
+        DEBUGF(("Passive do_send %d",bufflen));
+        do_send(ud, buff + 1, bufflen - 1); /* XXX */
+        return;
+    }
     if (bufflen == 0) {
-	return;
+        return;
     }
     switch (*buff) {
-    case 'L':
-	if (ud->type != portTypeUnknown) {
-	    driver_failure_posix(ud->port, ENOTSUP);
-	    return;
-	}
-	uds_command_listen(ud,buff,bufflen);
-	return;
-    case 'A':
-	if (ud->type != portTypeUnknown) {
-	    driver_failure_posix(ud->port, ENOTSUP);
-	    return;
-	}
-	uds_command_accept(ud,buff,bufflen);
-	return;
-    case 'C':
-	if (ud->type != portTypeUnknown) {
-	    driver_failure_posix(ud->port, ENOTSUP);
-	    return;
-	}
-	uds_command_connect(ud,buff,bufflen);
-	return;
-    case 'S':
-	if (ud->type != portTypeCommand) {
-	    driver_failure_posix(ud->port, ENOTSUP);
-	    return;
-	}
-	do_send(ud, buff + 1, bufflen - 1);
-	return;
-    case 'R':
-	if (ud->type != portTypeCommand) {
-	    driver_failure_posix(ud->port, ENOTSUP);
-	    return;
-	}
-	do_recv(ud);
-	return;
-    default:
-	ASSERT(0);
-	return;
+        case 'L':
+            if (ud->type != portTypeUnknown) {
+                driver_failure_posix(ud->port, ENOTSUP);
+                return;
+            }
+            uds_command_listen(ud, buff, bufflen);
+            return;
+        case 'A':
+            if (ud->type != portTypeUnknown) {
+                driver_failure_posix(ud->port, ENOTSUP);
+                return;
+            }
+            uds_command_accept(ud, buff, bufflen);
+            return;
+        case 'C':
+            if (ud->type != portTypeUnknown) {
+                driver_failure_posix(ud->port, ENOTSUP);
+                return;
+            }
+            uds_command_connect(ud, buff, bufflen);
+            return;
+        case 'S':
+            if (ud->type != portTypeCommand) {
+                driver_failure_posix(ud->port, ENOTSUP);
+                return;
+            }
+            do_send(ud, buff + 1, bufflen - 1);
+            return;
+        case 'R':
+            if (ud->type != portTypeCommand) {
+                driver_failure_posix(ud->port, ENOTSUP);
+                return;
+            }
+            do_recv(ud);
+            return;
+        default:
+            ASSERT(0);
+            return;
     }
 }
-	
-static void uds_input(ErlDrvData handle, ErlDrvEvent event)
-{
-    UdsData *ud = (UdsData *) handle;
+
+static void uds_input(ErlDrvData handle, ErlDrvEvent event) {
+    UdsData *ud = (UdsData *)handle;
 
     DEBUGF(("In uds_input type = %d",ud->type));
     if (ud->type == portTypeListener) {
-	UdsData *ad = ud->partner;
-	struct sockaddr_un peer;
-	int pl = sizeof(struct sockaddr_un);
-	int fd;
-
-	ASSERT(ad != NULL);
-	if ((fd = accept(ud->fd, (struct sockaddr *) &peer, &pl)) < 0) {
-	    if (errno != EWOULDBLOCK) {
-		DEBUGF(("Accept failed."));
-		driver_failure_posix(ud->port, errno);
-		return;
-	    }
-	    DEBUGF(("Accept would block."));
-	    return;
-	}
-	SET_NONBLOCKING(fd);
-	ad->fd = fd;
-	ad->partner = NULL;
-	ad->type = portTypeCommand;
-	ud->partner = NULL;
-	DEBUGF(("Accept successful."));
-	driver_select(ud->port, (ErlDrvEvent) ud->fd, ERL_DRV_READ, 0);
-	driver_output(ad->port, "Aok",3);
-	return;
+        UdsData *ad = ud->partner;
+        struct sockaddr_un peer;
+        int pl = sizeof(struct sockaddr_un);
+        int fd;
+
+        ASSERT(ad != NULL);
+        if ((fd = accept(ud->fd, (struct sockaddr *)&peer, &pl)) < 0) {
+            if (errno != EWOULDBLOCK) {
+                DEBUGF(("Accept failed."));
+                driver_failure_posix(ud->port, errno);
+                return;
+            } DEBUGF(("Accept would block."));
+            return;
+        }
+        SET_NONBLOCKING(fd);
+        ad->fd = fd;
+        ad->partner = NULL;
+        ad->type = portTypeCommand;
+        ud->partner = NULL;
+        DEBUGF(("Accept successful."));
+        driver_select(ud->port, (ErlDrvEvent)ud->fd, ERL_DRV_READ, 0);
+        driver_output(ad->port, "Aok", 3);
+        return;
     }
     /* OK, normal data or command port */
     ASSERT(ud->type >= portTypeCommand);
 #ifdef HARDDEBUG
     if (ud->type == portTypeData)
-	DEBUGF(("Passive do_recv"));
+    DEBUGF(("Passive do_recv"));
 #endif
     do_recv(ud);
 }
 
-static void uds_output(ErlDrvData handle, ErlDrvEvent event)
-{
-   UdsData *ud = (UdsData *) handle;
-   if (ud->type == portTypeConnector) {
-       ud->type = portTypeCommand;
-       driver_select(ud->port, (ErlDrvEvent) ud->fd, ERL_DRV_WRITE, 0);
-       driver_output(ud->port, "Cok",3);
-       return;
-   }
-   ASSERT(ud->type == portTypeCommand || ud->type == portTypeData);
-   send_out_queue(ud);
+static void uds_output(ErlDrvData handle, ErlDrvEvent event) {
+    UdsData *ud = (UdsData *)handle;
+    if (ud->type == portTypeConnector) {
+        ud->type = portTypeCommand;
+        driver_select(ud->port, (ErlDrvEvent)ud->fd, ERL_DRV_WRITE, 0);
+        driver_output(ud->port, "Cok", 3);
+        return;
+    }
+    ASSERT(ud->type == portTypeCommand || ud->type == portTypeData);
+    send_out_queue(ud);
 }
 
-static void uds_finish(void) 
-{
+static void uds_finish(void) {
     while (first_data != NULL) {
-	do_stop(first_data, 1);
+        do_stop(first_data, 1);
     }
 }
 
 /*
-** Protocol to control:
-** 'C': Set port in command mode.
-** 'I': Set port in intermediate mode
-** 'D': Set port in data mode
-** 'N': Get identification number for listen port
-** 'S': Get statistics
-** 'T': Send a tick message
-** 'R': Get creation number of listen socket
-** Answer is one byte status (0 == ok, Other is followed by error as string) 
-** followed by data if applicable
-*/
-static int uds_control(ErlDrvData handle, unsigned int command, 
-		       char* buf, int count, char** res, int res_size)
+ ** Protocol to control:
+ ** 'C': Set port in command mode.
+ ** 'I': Set port in intermediate mode
+ ** 'D': Set port in data mode
+ ** 'N': Get identification number for listen port
+ ** 'S': Get statistics
+ ** 'T': Send a tick message
+ ** 'R': Get creation number of listen socket
+ ** Answer is one byte status (0 == ok, Other is followed by error as string) 
+ ** followed by data if applicable
+ */
+static int uds_control(ErlDrvData handle, unsigned int command, char* buf, int count, char** res,
+        int res_size)
 {
-/* Local macro to ensure large enough buffer. */
+    /* Local macro to ensure large enough buffer. */
 #define ENSURE(N) 				\
    do {						\
        if (res_size < N) {			\
@@ -421,93 +404,90 @@ static int uds_control(ErlDrvData handle, unsigned int command,
        }					\
    } while(0)
 
-   UdsData *ud = (UdsData *) handle;
-
-   DEBUGF(("Control, type = %d, fd = %d, command = %c", ud->type, ud->fd, 
-	   (char) command));
-   switch (command) {
-   case 'S':
-       {
-	   ENSURE(13);
-	   **res = 0;
-	   put_packet_length((*res) + 1, ud->received);
-	   put_packet_length((*res) + 5, ud->sent);
-	   put_packet_length((*res) + 9, driver_sizeq(ud->port));
-	   return 13;
-       }
-   case 'C':
-       if (ud->type < portTypeCommand) {
-	   return report_control_error(res, res_size, "einval");
-       }
-       ud->type = portTypeCommand;
-       driver_select(ud->port, (ErlDrvEvent) ud->fd, ERL_DRV_READ, 0);
-       ENSURE(1);
-       **res = 0;
-       return 1;
-   case 'I':
-       if (ud->type < portTypeCommand) {
-	   return report_control_error(res, res_size, "einval");
-       }
-       ud->type = portTypeIntermediate;
-       driver_select(ud->port, (ErlDrvEvent) ud->fd, ERL_DRV_READ, 0);
-       ENSURE(1);
-       **res = 0;
-       return 1;
-   case 'D':
-       if (ud->type < portTypeCommand) {
-	   return report_control_error(res, res_size, "einval");
-       }
-       ud->type = portTypeData;
-       do_recv(ud);
-       ENSURE(1);
-       **res = 0;
-       return 1;
-   case 'N':
-       if (ud->type != portTypeListener) {
-	   return report_control_error(res, res_size, "einval");
-       }
-       ENSURE(5);
-       (*res)[0] = 0;
-       put_packet_length((*res) + 1, ud->fd);
-       return 5;
-   case 'T': /* tick */
-       if (ud->type != portTypeData) {
-	   return report_control_error(res, res_size, "einval");
-       }
-       do_send(ud,"",0);
-       ENSURE(1);
-       **res = 0;
-       return 1;
-   case 'R':
-       if (ud->type != portTypeListener) {
-	   return report_control_error(res, res_size, "einval");
-       }
-       ENSURE(2);
-       (*res)[0] = 0;
-       (*res)[1] = ud->creation;
-       return 2;
-   default:
-       return report_control_error(res, res_size, "einval");
-   }
+    UdsData *ud = (UdsData *)handle;
+
+    DEBUGF(("Control, type = %d, fd = %d, command = %c", ud->type, ud->fd,
+                    (char) command));
+    switch (command) {
+        case 'S': {
+            ENSURE(13);
+            **res = 0;
+            put_packet_length((*res) + 1, ud->received);
+            put_packet_length((*res) + 5, ud->sent);
+            put_packet_length((*res) + 9, driver_sizeq(ud->port));
+            return 13;
+        }
+        case 'C':
+            if (ud->type < portTypeCommand) {
+                return report_control_error(res, res_size, "einval");
+            }
+            ud->type = portTypeCommand;
+            driver_select(ud->port, (ErlDrvEvent)ud->fd, ERL_DRV_READ, 0);
+            ENSURE(1);
+            **res = 0;
+            return 1;
+        case 'I':
+            if (ud->type < portTypeCommand) {
+                return report_control_error(res, res_size, "einval");
+            }
+            ud->type = portTypeIntermediate;
+            driver_select(ud->port, (ErlDrvEvent)ud->fd, ERL_DRV_READ, 0);
+            ENSURE(1);
+            **res = 0;
+            return 1;
+        case 'D':
+            if (ud->type < portTypeCommand) {
+                return report_control_error(res, res_size, "einval");
+            }
+            ud->type = portTypeData;
+            do_recv(ud);
+            ENSURE(1);
+            **res = 0;
+            return 1;
+        case 'N':
+            if (ud->type != portTypeListener) {
+                return report_control_error(res, res_size, "einval");
+            }
+            ENSURE(5);
+            (*res)[0] = 0;
+            put_packet_length((*res) + 1, ud->fd);
+            return 5;
+        case 'T': /* tick */
+            if (ud->type != portTypeData) {
+                return report_control_error(res, res_size, "einval");
+            }
+            do_send(ud, "", 0);
+            ENSURE(1);
+            **res = 0;
+            return 1;
+        case 'R':
+            if (ud->type != portTypeListener) {
+                return report_control_error(res, res_size, "einval");
+            }
+            ENSURE(2);
+            (*res)[0] = 0;
+            (*res)[1] = ud->creation;
+            return 2;
+        default:
+            return report_control_error(res, res_size, "einval");
+    }
 #undef ENSURE
 }
 
-static void uds_stop_select(ErlDrvEvent event, void* _)
-{
+static void uds_stop_select(ErlDrvEvent event, void* _) {
     close((int)(long)event);
 }
 
 /*
-**
-** Local helpers
-**
-*/
+ **
+ ** Local helpers
+ **
+ */
 
 /*
-** Command implementations 
-*/
-static void uds_command_connect(UdsData *ud, char *buff, int bufflen) 
-{
+ ** Command implementations 
+ */
+static void uds_command_connect(UdsData *ud, char *buff, int bufflen) {
     char *str;
     int fd;
     struct sockaddr_un s_un;
@@ -515,8 +495,8 @@ static void uds_command_connect(UdsData *ud, char *buff, int bufflen)
     int res;
 
     str = ALLOC(25);
-    sprintf(str, "erl%d", (int) getpid()); /* A temporary sufficiently 
-					      unique name */
+    sprintf(str, "erl%d", (int)getpid()); /* A temporary sufficiently 
+     unique name */
     do_unlink(str);
     s_un.sun_family = AF_UNIX;
     strcpy(s_un.sun_path, SOCKET_PATH "/");
@@ -526,15 +506,15 @@ static void uds_command_connect(UdsData *ud, char *buff, int bufflen)
     ud->name = str;
     ud->type = portTypeCommand;
     if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
-	DEBUGF(("socket call failed, errno = %d"));
-	driver_failure_posix(ud->port, errno);
-	return;
+        DEBUGF(("socket call failed, errno = %d"));
+        driver_failure_posix(ud->port, errno);
+        return;
     }
     ud->fd = fd;
-    if ((res = bind(fd, (struct sockaddr *) &s_un, length)) < 0) {
-	DEBUGF(("bind call failed, errno = %d",errno));
-	driver_failure_posix(ud->port, errno);
-	return;
+    if ((res = bind(fd, (struct sockaddr *)&s_un, length)) < 0) {
+        DEBUGF(("bind call failed, errno = %d",errno));
+        driver_failure_posix(ud->port, errno);
+        return;
     }
     str = ALLOC(bufflen);
     memcpy(str, buff + 1, bufflen - 1);
@@ -544,56 +524,55 @@ static void uds_command_connect(UdsData *ud, char *buff, int bufflen)
     length = sizeof(s_un.sun_family) + strlen(s_un.sun_path);
     DEBUGF(("Connect peer filename: %s", s_un.sun_path));
     SET_NONBLOCKING(fd);
-    if (connect(fd, (struct sockaddr *) &s_un, length) < 0) {
-	if (errno != EINPROGRESS) {
-	    driver_failure_posix(ud->port, errno);
-	} else {
-	    DEBUGF(("Connect pending"));
-	    ud->type = portTypeConnector;
-	    driver_select(ud->port, (ErlDrvEvent) ud->fd,
-			  ERL_DRV_WRITE|ERL_DRV_USE, 1);
-	} 
-    } else {
-	DEBUGF(("Connect done"));
-	driver_output(ud->port, "Cok", 3);
+    if (connect(fd, (struct sockaddr *)&s_un, length) < 0) {
+        if (errno != EINPROGRESS) {
+            driver_failure_posix(ud->port, errno);
+        }
+        else {
+            DEBUGF(("Connect pending"));
+            ud->type = portTypeConnector;
+            driver_select(ud->port, (ErlDrvEvent)ud->fd, ERL_DRV_WRITE | ERL_DRV_USE, 1);
+        }
+    }
+    else {
+        DEBUGF(("Connect done"));
+        driver_output(ud->port, "Cok", 3);
     }
     FREE(str);
 }
 
-static void uds_command_accept(UdsData *ud, char *buff, int bufflen) 
-{
+static void uds_command_accept(UdsData *ud, char *buff, int bufflen) {
     int listen_no;
     UdsData *lp;
 
     if (bufflen < 5) {
-	driver_failure_posix(ud->port, EINVAL);
-	return;
+        driver_failure_posix(ud->port, EINVAL);
+        return;
     }
-    
+
     listen_no = get_packet_length(buff + 1); /* Same format as 
-						packet headers */
+     packet headers */
     DEBUGF(("Accept listen_no = %d",listen_no));
     for (lp = first_data; lp != NULL && lp->fd != listen_no; lp = lp->next)
-	;
+        ;
     if (lp == NULL) {
-	DEBUGF(("Could not find listen port"));
-	driver_failure_posix(ud->port, EINVAL);
-	return;
+        DEBUGF(("Could not find listen port"));
+        driver_failure_posix(ud->port, EINVAL);
+        return;
     }
     if (lp->partner != NULL) {
-	DEBUGF(("Listen port busy"));
-	driver_failure_posix(ud->port, EADDRINUSE);
-	return;
+        DEBUGF(("Listen port busy"));
+        driver_failure_posix(ud->port, EADDRINUSE);
+        return;
     }
     lp->partner = ud;
     ud->partner = lp;
     ud->type = portTypeAcceptor;
-    driver_select(lp->port,(ErlDrvEvent) lp->fd, ERL_DRV_READ|ERL_DRV_USE, 1);
+    driver_select(lp->port, (ErlDrvEvent)lp->fd, ERL_DRV_READ | ERL_DRV_USE, 1);
     /* Silent, answer will be sent in input routine */
 }
 
-static void uds_command_listen(UdsData *ud, char *buff, int bufflen)
-{
+static void uds_command_listen(UdsData *ud, char *buff, int bufflen) {
     char *str;
     int fd;
     struct sockaddr_un s_un;
@@ -603,25 +582,25 @@ static void uds_command_listen(UdsData *ud, char *buff, int bufflen)
     Byte creation;
 
     str = ALLOC(bufflen);
-    memcpy(str, buff + 1,bufflen - 1);
+    memcpy(str, buff + 1, bufflen - 1);
     str[bufflen - 1] = '\0';
 
     /*
-    ** Before trying lockfiles etc, we need to assure that our own process is 
-    ** not using the filename. Advisory locks can be recursive in one process.
-    */
-    for(tmp = first_data; tmp != NULL; tmp = tmp->next) {
-	if (tmp->name != NULL && strcmp(str, tmp->name) == 0) {
-	    driver_failure_posix(ud->port, EADDRINUSE);
-	    FREE(str);
-	    return;
-	}
+     ** Before trying lockfiles etc, we need to assure that our own process is 
+     ** not using the filename. Advisory locks can be recursive in one process.
+     */
+    for (tmp = first_data; tmp != NULL; tmp = tmp->next) {
+        if (tmp->name != NULL && strcmp(str, tmp->name) == 0) {
+            driver_failure_posix(ud->port, EADDRINUSE);
+            FREE(str);
+            return;
+        }
     }
-	    
+
     if ((fd = try_lock(str, &creation)) < 0) {
-	driver_failure_posix(ud->port, EADDRINUSE);
-	FREE(str);
-	return;
+        driver_failure_posix(ud->port, EADDRINUSE);
+        FREE(str);
+        return;
     }
     s_un.sun_family = AF_UNIX;
     strcpy(s_un.sun_path, SOCKET_PATH "/");
@@ -632,90 +611,87 @@ static void uds_command_listen(UdsData *ud, char *buff, int bufflen)
     ud->lockfd = fd;
     ud->creation = creation;
     if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
-	DEBUGF(("socket call failed, errno = %d"));
-	driver_failure_posix(ud->port, errno);
-	return;
+        DEBUGF(("socket call failed, errno = %d"));
+        driver_failure_posix(ud->port, errno);
+        return;
     }
     SET_NONBLOCKING(fd);
     ud->fd = fd;
     do_unlink(str);
     DEBUGF(("Listen filename: %s", s_un.sun_path));
-    if ((res = bind(fd, (struct sockaddr *) &s_un, length)) < 0) {
-	DEBUGF(("bind call failed, errno = %d",errno));
-	driver_failure_posix(ud->port, errno);
-	return;
+    if ((res = bind(fd, (struct sockaddr *)&s_un, length)) < 0) {
+        DEBUGF(("bind call failed, errno = %d",errno));
+        driver_failure_posix(ud->port, errno);
+        return;
     }
 
     if ((res = listen(fd, 5)) < 0) {
-	DEBUGF(("listen call failed, errno = %d"));
-	driver_failure_posix(ud->port, errno);
-	return;
+        DEBUGF(("listen call failed, errno = %d"));
+        driver_failure_posix(ud->port, errno);
+        return;
     }
     driver_output(ud->port, "Lok", 3);
 }
 
 /*
-** Input/output/stop helpers
-*/
-static void do_stop(UdsData *ud, int shutting_down) 
-{
+ ** Input/output/stop helpers
+ */
+static void do_stop(UdsData *ud, int shutting_down) {
     UdsData **tmp;
 
-    DEBUGF(("Cleaning up, type = %d, fd = %d, lockfd = %d", ud->type, 
-	    ud->fd, ud->lockfd));
+    DEBUGF(("Cleaning up, type = %d, fd = %d, lockfd = %d", ud->type,
+                    ud->fd, ud->lockfd));
     for (tmp = &first_data; *tmp != NULL && *tmp != ud; tmp = &((*tmp)->next))
-	;
+        ;
     ASSERT(*tmp != NULL);
     *tmp = (*tmp)->next;
     if (ud->buffer != NULL) {
-	FREE(ud->buffer); 
+        FREE(ud->buffer);
     }
     if (ud->fd >= 0) {
-	driver_select(ud->port, (ErlDrvEvent) ud->fd,
-		      ERL_DRV_READ|ERL_DRV_WRITE|ERL_DRV_USE, 0);
+        driver_select(ud->port, (ErlDrvEvent)ud->fd, ERL_DRV_READ | ERL_DRV_WRITE | ERL_DRV_USE, 0);
     }
     if (ud->name) {
-	do_unlink(ud->name);
-	FREE(ud->name);
+        do_unlink(ud->name);
+        FREE(ud->name);
     }
     if (ud->lockfd >= 0) {
-	ASSERT(ud->type == portTypeListener);
-	close(ud->lockfd); /* the lock will be released */
-	/* But leave the file there for the creation counter... */
+        ASSERT(ud->type == portTypeListener);
+        close(ud->lockfd); /* the lock will be released */
+        /* But leave the file there for the creation counter... */
     }
     if (!shutting_down) { /* Dont bother if the driver is shutting down. */
-	if (ud->partner != NULL) {
-	    if (ud->type == portTypeAcceptor) {
-		UdsData *listener = ud->partner;
-		listener->partner = NULL;
-		driver_select(listener->port, (ErlDrvEvent) listener->fd,
-			      ERL_DRV_READ, 0);
-	    } else {
-		UdsData *acceptor = ud->partner;
-		ASSERT(ud->type == portTypeListener);
-		acceptor->partner = NULL;
-		driver_failure_eof(acceptor->port);
-	    }
-	}
+        if (ud->partner != NULL) {
+            if (ud->type == portTypeAcceptor) {
+                UdsData *listener = ud->partner;
+                listener->partner = NULL;
+                driver_select(listener->port, (ErlDrvEvent)listener->fd, ERL_DRV_READ, 0);
+            }
+            else {
+                UdsData *acceptor = ud->partner;
+                ASSERT(ud->type == portTypeListener);
+                acceptor->partner = NULL;
+                driver_failure_eof(acceptor->port);
+            }
+        }
     }
     FREE(ud);
 }
 
 /*
-** Actually send the data
-*/
-static void do_send(UdsData *ud, char *buff, int bufflen) 
-{
+ ** Actually send the data
+ */
+static void do_send(UdsData *ud, char *buff, int bufflen) {
     char header[4];
     int written;
     SysIOVec iov[2];
     ErlIOVec eio;
-    ErlDrvBinary *binv[] = {NULL,NULL};
+    ErlDrvBinary *binv[] = { NULL, NULL };
 
     put_packet_length(header, bufflen);
     DEBUGF(("Write packet header %u,%u,%u,%u.", (Word) header[0],
-	   (Word) header[1], (Word) header[2],(Word) header[3]));
-    iov[0].iov_base = (char *) header;
+                    (Word) header[1], (Word) header[2],(Word) header[3]));
+    iov[0].iov_base = (char *)header;
     iov[0].iov_len = 4;
     iov[1].iov_base = buff;
     iov[1].iov_len = bufflen;
@@ -725,75 +701,73 @@ static void do_send(UdsData *ud, char *buff, int bufflen)
     eio.size = bufflen + 4;
     written = 0;
     if (driver_sizeq(ud->port) == 0) {
-	if ((written = writev(ud->fd, iov, 2)) == eio.size) {
-	    ud->sent += written;
-	    if (ud->type == portTypeCommand) {
-		driver_output(ud->port, "Sok", 3);
-	    }
-	    DEBUGF(("Wrote all %d bytes immediately.",written));
-	    return;
-	} else if (written < 0) {
-	    if (errno != EWOULDBLOCK) {
-		driver_failure_eof(ud->port);
-		return;
-	    } else {
-		written = 0;
-	    }
-	} else {
-	    ud->sent += written;
-	}
-	DEBUGF(("Wrote %d bytes immediately.",written));
-	/* Enqueue remaining */
+        if ((written = writev(ud->fd, iov, 2)) == eio.size) {
+            ud->sent += written;
+            if (ud->type == portTypeCommand) {
+                driver_output(ud->port, "Sok", 3);
+            } DEBUGF(("Wrote all %d bytes immediately.",written));
+            return;
+        }
+        else if (written < 0) {
+            if (errno != EWOULDBLOCK) {
+                driver_failure_eof(ud->port);
+                return;
+            }
+            else {
+                written = 0;
+            }
+        }
+        else {
+            ud->sent += written;
+        } DEBUGF(("Wrote %d bytes immediately.",written));
+        /* Enqueue remaining */
     }
     driver_enqv(ud->port, &eio, written);
     DEBUGF(("Sending output queue."));
     send_out_queue(ud);
 }
 
-static void do_recv(UdsData *ud)
-{
+static void do_recv(UdsData *ud) {
     int res;
     char *ibuf;
     ASSERT_NONBLOCK(ud->fd);
     DEBUGF(("do_recv called, type = %d", ud->type));
-    for(;;) {
-	if ((res = buffered_read_package(ud,&ibuf)) < 0) {
-	    if (res == NORMAL_READ_FAILURE) {
-		DEBUGF(("do_recv normal read failed"));
-		driver_select(ud->port, (ErlDrvEvent) ud->fd, ERL_DRV_READ|ERL_DRV_USE, 1);
-	    } else {
-		DEBUGF(("do_recv fatal read failed (%d) (%d)",errno, res));
-		driver_failure_eof(ud->port);
-	    }
-	    return;
-	}
-	DEBUGF(("do_recv got package, port type = %d", ud->type));
-	/* Got a package */
-	if (ud->type == portTypeCommand) {
-	    ibuf[-1] = 'R'; /* There is always room for a single byte opcode
-			       before the actual buffer (where the packet
-			       header was) */
-	    driver_output(ud->port,ibuf - 1, res + 1);
-	    driver_select(ud->port, (ErlDrvEvent) ud->fd, ERL_DRV_READ, 0);
-	    return;
-	} else {
-	    ibuf[-1] = DIST_MAGIC_RECV_TAG; /* XXX */
-	    driver_output(ud->port,ibuf - 1, res + 1);
-	    driver_select(ud->port, (ErlDrvEvent) ud->fd, ERL_DRV_READ|ERL_DRV_USE, 1);
-	}
+    for (;;) {
+        if ((res = buffered_read_package(ud, &ibuf)) < 0) {
+            if (res == NORMAL_READ_FAILURE) {
+                DEBUGF(("do_recv normal read failed"));
+                driver_select(ud->port, (ErlDrvEvent)ud->fd, ERL_DRV_READ | ERL_DRV_USE, 1);
+            }
+            else {
+                DEBUGF(("do_recv fatal read failed (%d) (%d)",errno, res));
+                driver_failure_eof(ud->port);
+            }
+            return;
+        } DEBUGF(("do_recv got package, port type = %d", ud->type));
+        /* Got a package */
+        if (ud->type == portTypeCommand) {
+            ibuf[-1] = 'R'; /* There is always room for a single byte opcode
+             before the actual buffer (where the packet
+             header was) */
+            driver_output(ud->port, ibuf - 1, res + 1);
+            driver_select(ud->port, (ErlDrvEvent)ud->fd, ERL_DRV_READ, 0);
+            return;
+        }
+        else {
+            ibuf[-1] = DIST_MAGIC_RECV_TAG; /* XXX */
+            driver_output(ud->port, ibuf - 1, res + 1);
+            driver_select(ud->port, (ErlDrvEvent)ud->fd, ERL_DRV_READ | ERL_DRV_USE, 1);
+        }
     }
 }
 
-
 /*
-** Report control error, helper for error messages from control
-*/
-static int report_control_error(char **buffer, int buff_len, 
-				char *error_message)
-{
+ ** Report control error, helper for error messages from control
+ */
+static int report_control_error(char **buffer, int buff_len, char *error_message) {
     int elen = strlen(error_message);
     if (elen + 1 < buff_len) {
-	*buffer = ALLOC(elen + 1);
+        *buffer = ALLOC(elen + 1);
     }
     **buffer = 1;
     memcpy((*buffer) + 1, error_message, elen);
@@ -801,153 +775,141 @@ static int report_control_error(char **buffer, int buff_len,
 }
 
 /*
-** Lower level I/O helpers
-*/
-static int send_out_queue(UdsData *ud)
-{
+ ** Lower level I/O helpers
+ */
+static int send_out_queue(UdsData *ud) {
     ASSERT_NONBLOCK(ud->fd);
-    for(;;) {
-	int vlen;
-	SysIOVec *tmp = driver_peekq(ud->port, &vlen);
-	int wrote;
-	if (tmp == NULL) {
-	    DEBUGF(("Write queue empty."));
-	    driver_select(ud->port, (ErlDrvEvent) ud->fd, ERL_DRV_WRITE, 0);
-	    if (ud->type == portTypeCommand) {
-		driver_output(ud->port, "Sok", 3);
-	    }
-	    return 0;
-	}
-	if (vlen > IO_VECTOR_MAX) {
-	    vlen = IO_VECTOR_MAX;
-	} 
-	DEBUGF(("Trying to writev %d vectors", vlen));
+    for (;;) {
+        int vlen;
+        SysIOVec *tmp = driver_peekq(ud->port, &vlen);
+        int wrote;
+        if (tmp == NULL) {
+            DEBUGF(("Write queue empty."));
+            driver_select(ud->port, (ErlDrvEvent)ud->fd, ERL_DRV_WRITE, 0);
+            if (ud->type == portTypeCommand) {
+                driver_output(ud->port, "Sok", 3);
+            }
+            return 0;
+        }
+        if (vlen > IO_VECTOR_MAX) {
+            vlen = IO_VECTOR_MAX;
+        } DEBUGF(("Trying to writev %d vectors", vlen));
 #ifdef HARDDEBUG
-	{
-	    int i;
-	    for (i = 0; i < vlen; ++i) {
-		DEBUGF(("Buffer %d: length %d", i, tmp[i].iov_len));
-	    }
-	}
+        {
+            int i;
+            for (i = 0; i < vlen; ++i) {
+                DEBUGF(("Buffer %d: length %d", i, tmp[i].iov_len));
+            }
+        }
 #endif
-	if ((wrote = writev(ud->fd, tmp, vlen)) < 0) {
-	    if (errno == EWOULDBLOCK) {
-		DEBUGF(("Write failed normal."));
-		driver_select(ud->port, (ErlDrvEvent) ud->fd, ERL_DRV_WRITE|ERL_DRV_USE, 1);
-		return 0;
-	    } else {
-		DEBUGF(("Write failed fatal (%d).", errno));
-		driver_failure_eof(ud->port);
-		return -1;
-	    }
-	}
-	driver_deq(ud->port, wrote);
-	ud->sent += wrote;
-	DEBUGF(("Wrote %d bytes of data.",wrote));
+        if ((wrote = writev(ud->fd, tmp, vlen)) < 0) {
+            if (errno == EWOULDBLOCK) {
+                DEBUGF(("Write failed normal."));
+                driver_select(ud->port, (ErlDrvEvent)ud->fd, ERL_DRV_WRITE | ERL_DRV_USE, 1);
+                return 0;
+            }
+            else {
+                DEBUGF(("Write failed fatal (%d).", errno));
+                driver_failure_eof(ud->port);
+                return -1;
+            }
+        }
+        driver_deq(ud->port, wrote);
+        ud->sent += wrote;
+        DEBUGF(("Wrote %d bytes of data.",wrote));
     }
 }
 
-static int buffered_read_package(UdsData *ud, char **result)
-{
+static int buffered_read_package(UdsData *ud, char **result) {
     int res;
     int data_size;
 
     if (ud->buffer_pos < ud->header_pos + HEADER_LENGTH) {
-	/* The header is not read yet */
-	DEBUGF(("Header not read yet"));
-	if ((res = read_at_least(ud, ud->header_pos + HEADER_LENGTH - 
-				 ud->buffer_pos)) < 0) {
-	    DEBUGF(("Header read failed"));
-	    return res;
-	}
-    } 
-    DEBUGF(("Header is read"));
+        /* The header is not read yet */
+        DEBUGF(("Header not read yet"));
+        if ((res = read_at_least(ud, ud->header_pos + HEADER_LENGTH - ud->buffer_pos)) < 0) {
+            DEBUGF(("Header read failed"));
+            return res;
+        }
+    } DEBUGF(("Header is read"));
     /* We have at least the header read */
-    data_size = get_packet_length((char *) ud->buffer + ud->header_pos);
+    data_size = get_packet_length((char *)ud->buffer + ud->header_pos);
     DEBUGF(("Input packet size = %d", data_size));
     if (ud->buffer_pos < ud->header_pos + HEADER_LENGTH + data_size) {
-	/* We need to read more */
-	DEBUGF(("Need to read more (bufferpos %d, want %d)", ud->buffer_pos,
-		ud->header_pos + HEADER_LENGTH + data_size));
-	if ((res = read_at_least(ud, 
-				 ud->header_pos + HEADER_LENGTH + 
-				 data_size - ud->buffer_pos)) < 0) {
-	    DEBUGF(("Data read failed"));
-	    return res;
-	}
-    }
-    DEBUGF(("Data is completely read"));
-    *result = (char *) ud->buffer + ud->header_pos + HEADER_LENGTH;
+        /* We need to read more */
+        DEBUGF(("Need to read more (bufferpos %d, want %d)", ud->buffer_pos,
+                        ud->header_pos + HEADER_LENGTH + data_size));
+        if ((res = read_at_least(ud, ud->header_pos + HEADER_LENGTH + data_size - ud->buffer_pos))
+                < 0) {
+            DEBUGF(("Data read failed"));
+            return res;
+        }
+    } DEBUGF(("Data is completely read"));
+    *result = (char *)ud->buffer + ud->header_pos + HEADER_LENGTH;
     ud->header_pos += HEADER_LENGTH + data_size;
     return data_size;
 }
 
-static int read_at_least(UdsData *ud, int num)
-{
+static int read_at_least(UdsData *ud, int num) {
     int got;
     if (ud->buffer_pos + num > ud->buffer_size) {
-	/* No place in the buffer, try to pack it */
-	if (ud->header_pos > 0) {
-	    int offset = ud->header_pos;
-	    DEBUGF(("Packing buffer, buffer_pos was %d, buffer_size was %d "
-		    "offset %d num %d header_pos %d.", 
-		    ud->buffer_pos, ud->buffer_size,
-		    offset, num, ud->header_pos));
-	    memmove(ud->buffer, ud->buffer + ud->header_pos, 
-		    ud->buffer_pos - ud->header_pos);
-	    ud->buffer_pos -= offset;
-	    ud->header_pos -= offset;
-	}
-	/* The buffer is packed, look for space again and reallocate if 
-	   needed */
-	if (ud->buffer_pos + num > ud->buffer_size) {
-	    /* Let's grow in chunks of 256 */
-	    ud->buffer_size = (((ud->buffer_pos + num) / 
-				  CHUNK_SIZE) + 1) * CHUNK_SIZE;
-	    DEBUGF(("New buffer size %d.",ud->buffer_size)); 
-	    /* We will always keep one extra byte before the buffer to
-	       allow insertion of an opcode */
-	    if (!ud->buffer) {
-		ud->buffer = ALLOC(ud->buffer_size);
-	    } else {
-		ud->buffer = REALLOC(ud->buffer, ud->buffer_size);
-	    }
-	}
+        /* No place in the buffer, try to pack it */
+        if (ud->header_pos > 0) {
+            int offset = ud->header_pos;
+            DEBUGF(("Packing buffer, buffer_pos was %d, buffer_size was %d "
+                            "offset %d num %d header_pos %d.",
+                            ud->buffer_pos, ud->buffer_size,
+                            offset, num, ud->header_pos));
+            memmove(ud->buffer, ud->buffer + ud->header_pos, ud->buffer_pos - ud->header_pos);
+            ud->buffer_pos -= offset;
+            ud->header_pos -= offset;
+        }
+        /* The buffer is packed, look for space again and reallocate if 
+         needed */
+        if (ud->buffer_pos + num > ud->buffer_size) {
+            /* Let's grow in chunks of 256 */
+            ud->buffer_size = (((ud->buffer_pos + num) / CHUNK_SIZE) + 1) * CHUNK_SIZE;
+            DEBUGF(("New buffer size %d.",ud->buffer_size));
+            /* We will always keep one extra byte before the buffer to
+             allow insertion of an opcode */
+            if (!ud->buffer) {
+                ud->buffer = ALLOC(ud->buffer_size);
+            }
+            else {
+                ud->buffer = REALLOC(ud->buffer, ud->buffer_size);
+            }
+        }
     }
     /* OK, now we have a large enough buffer, try to read into it */
-    if ((got = read(ud->fd, ud->buffer + ud->buffer_pos, 
-		    ud->buffer_size - ud->buffer_pos)) < 0) {
-	/* It failed, the question is why... */
-	if (errno == EAGAIN) {
-	    return NORMAL_READ_FAILURE;
-	} 
-	return SEVERE_READ_FAILURE;
-    } else if (got == 0) {
-	return EOF_READ_FAILURE;
-    }
-    DEBUGF(("Got %d bytes.", got));
+    if ((got = read(ud->fd, ud->buffer + ud->buffer_pos, ud->buffer_size - ud->buffer_pos)) < 0) {
+        /* It failed, the question is why... */
+        if (errno == EAGAIN) {
+            return NORMAL_READ_FAILURE;
+        }
+        return SEVERE_READ_FAILURE;
+    }
+    else if (got == 0) {
+        return EOF_READ_FAILURE;
+    } DEBUGF(("Got %d bytes.", got));
     ud->received += got;
     ud->buffer_pos += got;
-   /* So, we got some bytes, but enough ? */
+    /* So, we got some bytes, but enough ? */
     if (got < num) {
-	return NORMAL_READ_FAILURE;
+        return NORMAL_READ_FAILURE;
     }
     return 0;
 }
-	
-static int get_packet_length(char *b)
-{
-    Byte *u = (Byte *) b;
-    int x = (((Word) u[0]) << 24) | (((Word) u[1]) << 16) | 
-	(((Word) u[2]) << 8) | ((Word) u[3]);
+
+static int get_packet_length(char *b) {
+    Byte *u = (Byte *)b;
+    int x = (((Word)u[0]) << 24) | (((Word)u[1]) << 16) | (((Word)u[2]) << 8) | ((Word)u[3]);
     DEBUGF(("Packet length %d.", x));
     return x;
 }
 
-static void put_packet_length(char *b, int len)
-{	   
-    Byte *p = (Byte *) b;
-    Word n = (Word) len;
+static void put_packet_length(char *b, int len) {
+    Byte *p = (Byte *)b;
+    Word n = (Word)len;
     p[0] = (n >> 24) & 0xFF;
     p[1] = (n >> 16) & 0xFF;
     p[2] = (n >> 8) & 0xFF;
@@ -955,90 +917,86 @@ static void put_packet_length(char *b, int len)
 }
 
 /*
-** Malloc wrappers
-** Note!
-** The function erl_exit is actually not a pert of the 
-** driver interface, but it is very nice to use if one wants to halt
-** with a core and an erlang crash dump.
-*/
-static void *my_malloc(size_t size) 
-{
+ ** Malloc wrappers
+ ** Note!
+ ** The function erl_exit is actually not a pert of the 
+ ** driver interface, but it is very nice to use if one wants to halt
+ ** with a core and an erlang crash dump.
+ */
+static void *my_malloc(size_t size) {
     void erl_exit(int, char *, ...);
     void *ptr;
 
     if ((ptr = driver_alloc(size)) == NULL) {
-	erl_exit(1,"Could not allocate %d bytes of memory",(int) size);
+        erl_exit(1, "Could not allocate %d bytes of memory", (int)size);
     }
     return ptr;
 }
 
-static void *my_realloc(void *ptr, size_t size)
-{
+static void *my_realloc(void *ptr, size_t size) {
     void erl_exit(int, char *, ...);
     void *nptr;
     if ((nptr = driver_realloc(ptr, size)) == NULL) {
-	erl_exit(1,"Could not reallocate %d bytes of memory",(int) size);
+        erl_exit(1, "Could not reallocate %d bytes of memory", (int)size);
     }
     return nptr;
 }
-    
 
 /*
-** Socket file handling helpers
-*/
+ ** Socket file handling helpers
+ */
 
 /*
-** Check that directory exists, create if not (only works for one level)
-*/
-static int ensure_dir(char *path)
-{
-    if (mkdir(path,0777) != 0 && errno != EEXIST) {
-	return -1;
+ ** Check that directory exists, create if not (only works for one level)
+ */
+static int ensure_dir(char *path) {
+    if (mkdir(path, 0777) != 0 && errno != EEXIST) {
+        return -1;
     }
     return 0;
 }
 
 /*
-** Try to open a lock file and lock the first byte write-only (advisory)
-** return the file descriptor if successful, otherwise -1 (<0).
-*/ 
-static int try_lock(char *sockname, Byte *p_creation)
-{
+ ** Try to open a lock file and lock the first byte write-only (advisory)
+ ** return the file descriptor if successful, otherwise -1 (<0).
+ */
+static int try_lock(char *sockname, Byte *p_creation) {
     char *lockname;
     int lockfd;
     struct flock fl;
     Byte creation;
 
     lockname = ALLOC(strlen(SOCKET_PATH)+1+strlen(sockname)+
-		     strlen(LOCK_SUFFIX)+1);
-    sprintf(lockname,SOCKET_PATH "/%s" LOCK_SUFFIX, sockname);
+            strlen(LOCK_SUFFIX)+1);
+    sprintf(lockname, SOCKET_PATH "/%s" LOCK_SUFFIX, sockname);
     DEBUGF(("lockname = %s", lockname));
     if (ensure_dir(SOCKET_PATH) != 0) {
-	DEBUGF(("ensure_dir failed, errno = %d", errno));
-	FREE(lockname);
-	return -1;
+        DEBUGF(("ensure_dir failed, errno = %d", errno));
+        FREE(lockname);
+        return -1;
     }
     if ((lockfd = open(lockname, O_RDWR | O_CREAT, 0666)) < 0) {
-	DEBUGF(("open failed, errno = %d", errno));
-	FREE(lockname);
-	return -1;
+        DEBUGF(("open failed, errno = %d", errno));
+        FREE(lockname);
+        return -1;
     }
     FREE(lockname);
-    memset(&fl,0,sizeof(fl));
+    memset(&fl, 0, sizeof(fl));
     fl.l_type = F_WRLCK;
     fl.l_whence = SEEK_SET;
     fl.l_start = 0;
     fl.l_len = 1;
     if (fcntl(lockfd, F_SETLK, &fl) < 0) {
-	DEBUGF(("fcntl failed, errno = %d", errno));
-	close(lockfd);
-	return -1;
+        DEBUGF(("fcntl failed, errno = %d", errno));
+        close(lockfd);
+        return -1;
     }
     /* OK, check for creation and update */
     if (read(lockfd, &creation, 1) < 1) {
-	creation = 0;
-    } else {
-	creation = (creation + 1) % 4;
+        creation = 0;
+    }
+    else {
+        creation = (creation + 1) % 4;
     }
     lseek(lockfd, 0, SEEK_SET);
     write(lockfd, &creation, 1);
@@ -1046,20 +1004,19 @@ static int try_lock(char *sockname, Byte *p_creation)
     *p_creation = creation;
     return lockfd;
 }
-    
-static void do_unlink(char *name)
-{
+
+static void do_unlink(char *name) {
     char buff[100];
     char *str = buff;
     int len = strlen(SOCKET_PATH) + 1 + strlen(name) + 1;
 
     if (len > 100) {
-	str = ALLOC(len);
+        str = ALLOC(len);
     }
-    sprintf(str,SOCKET_PATH "/%s",name);
+    sprintf(str, SOCKET_PATH "/%s", name);
     unlink(str);
     if (str != buff) {
-	FREE(str);
+        FREE(str);
     }
 }
 
diff --git a/lib/kernel/include/dist_util.hrl b/lib/kernel/include/dist_util.hrl
index fde102a..c3a7f97 100644
--- a/lib/kernel/include/dist_util.hrl
+++ b/lib/kernel/include/dist_util.hrl
@@ -17,8 +17,8 @@
 %% %CopyrightEnd%
 %%
 %% uncomment this if tracing of handshake etc is wanted
--define(dist_trace, true). 
--define(dist_debug, true).
+%%-define(dist_trace, true). 
+%%-define(dist_debug, true).
 
 
 -ifdef(dist_debug).
-- 
1.7.10.4


From bb2420c0fc3604f5a6a6b235576a3e7bb40f67b9 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Mon, 18 Jun 2012 17:52:54 +0200
Subject: [PATCH 37/67] Export net_kernel.

---
 lib/kernel/src/net_kernel.erl |    1 +
 1 file changed, 1 insertion(+)

diff --git a/lib/kernel/src/net_kernel.erl b/lib/kernel/src/net_kernel.erl
index 9e3d730..d3127b9 100644
--- a/lib/kernel/src/net_kernel.erl
+++ b/lib/kernel/src/net_kernel.erl
@@ -342,6 +342,7 @@ start_link([Name, LongOrShortNames, Ticktime]) ->
     case gen_server:start_link({local, net_kernel}, net_kernel,
 			       {Name, LongOrShortNames, Ticktime}, []) of
 	{ok, Pid} ->
+        erlang:export(net_kernel),
 	    {ok, Pid};
 	{error, {already_started, Pid}} ->
 	    {ok, Pid};
-- 
1.7.10.4


From b42bb580d60200608186698d42f5af5c50b5bcf6 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Tue, 19 Jun 2012 12:24:04 +0200
Subject: [PATCH 38/67] Introduced the new operator tilde, for now just
 mimicking the bang operator.

---
 erts/emulator/beam/bif.c     |   11 +++++++++++
 erts/emulator/beam/bif.tab   |    1 +
 lib/stdlib/src/erl_parse.yrl |    4 +++-
 3 files changed, 15 insertions(+), 1 deletion(-)

diff --git a/erts/emulator/beam/bif.c b/erts/emulator/beam/bif.c
index f40bdb7..efbb7fe 100644
--- a/erts/emulator/beam/bif.c
+++ b/erts/emulator/beam/bif.c
@@ -1740,6 +1740,17 @@ ebif_bang_2(BIF_ALIST_2)
 
 
 /*
+ * erlang:'~'/2
+ */
+
+BIF_RETTYPE
+ebif_tilde_2(BIF_ALIST_2)
+{
+    return erl_send(BIF_P, BIF_ARG_1, BIF_ARG_2);
+}
+
+
+/*
  * Send a message to Process, Port or Registered Process.
  * Returns non-negative reduction bump or negative result code.
  */
diff --git a/erts/emulator/beam/bif.tab b/erts/emulator/beam/bif.tab
index 63b64be..be69419 100644
--- a/erts/emulator/beam/bif.tab
+++ b/erts/emulator/beam/bif.tab
@@ -826,3 +826,4 @@ bif erlang:exported/0
 bif 'erl.lang.node':exported/0    ebif_exported_0
 bif erlang:unexport/1
 bif 'erl.lang.node':unexport/1    ebif_unexport_1
+bif erlang:'~'/2        ebif_tilde_2
diff --git a/lib/stdlib/src/erl_parse.yrl b/lib/stdlib/src/erl_parse.yrl
index 928c10f..c500f71 100644
--- a/lib/stdlib/src/erl_parse.yrl
+++ b/lib/stdlib/src/erl_parse.yrl
@@ -61,7 +61,7 @@ char integer float atom string var
 '++' '--'
 '==' '/=' '=<' '<' '>=' '>' '=:=' '=/=' '<='
 '<<' '>>'
-'!' '=' '::' '..' '...'
+'!' '~' '=' '::' '..' '...'
 'spec' 'callback' % helper
 dot.
 
@@ -221,6 +221,7 @@ expr -> expr_100 : '$1'.
 
 expr_100 -> expr_150 '=' expr_100 : {match,?line('$2'),'$1','$3'}.
 expr_100 -> expr_150 '!' expr_100 : ?mkop2('$1', '$2', '$3').
+expr_100 -> expr_150 '~' expr_100 : ?mkop2('$1', '$2', '$3').
 expr_100 -> expr_150 : '$1'.
 
 expr_150 -> expr_160 'orelse' expr_150 : ?mkop2('$1', '$2', '$3').
@@ -1034,6 +1035,7 @@ tokens_tuple([], Line, More) ->
 
 inop_prec('=') -> {150,100,100};
 inop_prec('!') -> {150,100,100};
+inop_prec('~') -> {150,100,100};
 inop_prec('orelse') -> {160,150,150};
 inop_prec('andalso') -> {200,160,160};
 inop_prec('==') -> {300,200,300};
-- 
1.7.10.4


From 90c707b816b6c16312c02b5f12d16bce63cf11b7 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Thu, 21 Jun 2012 10:53:33 +0200
Subject: [PATCH 39/67] Reliable...

---
 erts/emulator/beam/bif.c      |   29 ++++++++++++++++++++---------
 erts/emulator/beam/dist.c     |   28 +++++++++++++++++++++++++---
 erts/emulator/beam/dist.h     |    2 ++
 erts/emulator/beam/external.c |    8 ++++++++
 erts/emulator/beam/external.h |    1 +
 erts/emulator/beam/global.h   |    1 +
 6 files changed, 57 insertions(+), 12 deletions(-)

diff --git a/erts/emulator/beam/bif.c b/erts/emulator/beam/bif.c
index efbb7fe..8e087b8 100644
--- a/erts/emulator/beam/bif.c
+++ b/erts/emulator/beam/bif.c
@@ -1735,7 +1735,7 @@ BIF_RETTYPE whereis_1(BIF_ALIST_1)
 BIF_RETTYPE
 ebif_bang_2(BIF_ALIST_2)
 {
-    return erl_send(BIF_P, BIF_ARG_1, BIF_ARG_2);
+    return erl_send_reliable(BIF_P, BIF_ARG_1, BIF_ARG_2, 1);
 }
 
 
@@ -1746,7 +1746,7 @@ ebif_bang_2(BIF_ALIST_2)
 BIF_RETTYPE
 ebif_tilde_2(BIF_ALIST_2)
 {
-    return erl_send(BIF_P, BIF_ARG_1, BIF_ARG_2);
+    return erl_send_reliable(BIF_P, BIF_ARG_1, BIF_ARG_2, 0);
 }
 
 
@@ -1762,9 +1762,10 @@ ebif_tilde_2(BIF_ALIST_2)
 #define SEND_INTERNAL_ERROR	(-6)
 
 Sint do_send(Process *p, Eterm to, Eterm msg, int suspend);
+Sint do_send_reliable(Process *p, Eterm to, Eterm msg, int suspend, int reliable);
 
-static Sint remote_send(Process *p, DistEntry *dep,
-			Eterm to, Eterm full_to, Eterm msg, int suspend)
+static Sint remote_send_reliable(Process *p, DistEntry *dep,
+			Eterm to, Eterm full_to, Eterm msg, int suspend, int reliable)
 {
     Sint res;
     int code;
@@ -1785,9 +1786,9 @@ static Sint remote_send(Process *p, DistEntry *dep,
     case ERTS_DSIG_PREP_CONNECTED: {
 
 	if (is_atom(to))
-	    code = erts_dsig_send_reg_msg(&dsd, to, msg);
+	    code = erts_dsig_send_reg_msg_reliable(&dsd, to, msg, reliable);
 	else
-	    code = erts_dsig_send_msg(&dsd, to, msg);
+	    code = erts_dsig_send_msg_reliable(&dsd, to, msg, reliable);
 	/*
 	 * Note that reductions have been bumped on calling
 	 * process by erts_dsig_send_reg_msg() or
@@ -1816,6 +1817,11 @@ static Sint remote_send(Process *p, DistEntry *dep,
 
 Sint
 do_send(Process *p, Eterm to, Eterm msg, int suspend) {
+    return do_send_reliable(p, to, msg, suspend, 1);
+}
+
+Sint
+do_send_reliable(Process *p, Eterm to, Eterm msg, int suspend, int reliable) {
     Eterm portid;
     Port *pt;
     Process* rp;
@@ -1853,7 +1859,7 @@ do_send(Process *p, Eterm to, Eterm msg, int suspend) {
 	    erts_send_error_to_logger(p->group_leader, dsbufp);
 	    return 0;
 	}
-	return remote_send(p, dep, to, to, msg, suspend);
+	return remote_send_reliable(p, dep, to, to, msg, suspend, reliable);
     } else if (is_atom(to)) {
         int ret;
         
@@ -2053,7 +2059,7 @@ do_send(Process *p, Eterm to, Eterm msg, int suspend) {
             goto send_message;
         }
     
-        ret = remote_send(p, dep, tp[1], to, msg, suspend);
+        ret = remote_send_reliable(p, dep, tp[1], to, msg, suspend, reliable);
         if (dep)
             erts_deref_dist_entry(dep);
         return ret;
@@ -2185,7 +2191,12 @@ BIF_RETTYPE send_2(BIF_ALIST_2)
 
 Eterm erl_send(Process *p, Eterm to, Eterm msg)
 {
-    Sint result = do_send(p, to, msg, !0);
+    return erl_send_reliable(p, to, msg, 1);
+}
+
+Eterm erl_send_reliable(Process *p, Eterm to, Eterm msg, int reliable)
+{
+    Sint result = do_send_reliable(p, to, msg, !0, reliable);
     
     if (result > 0) {
 	ERTS_VBUMP_REDS(p, result);
diff --git a/erts/emulator/beam/dist.c b/erts/emulator/beam/dist.c
index 0b00aa6..a1211b0 100644
--- a/erts/emulator/beam/dist.c
+++ b/erts/emulator/beam/dist.c
@@ -120,6 +120,7 @@ Export* dmonitor_p_trap = NULL;
 
 static void clear_dist_entry(DistEntry*);
 static int dsig_send(ErtsDSigData *, Eterm, Eterm, int);
+static int dsig_send_reliable(ErtsDSigData *, Eterm, Eterm, int, int);
 static void send_nodes_mon_msgs(Process *, Eterm, Eterm, Eterm, Eterm);
 static void init_nodes_monitors(void);
 
@@ -736,6 +737,12 @@ erts_dsig_send_demonitor(ErtsDSigData *dsdp, Eterm watcher,
 int
 erts_dsig_send_msg(ErtsDSigData *dsdp, Eterm remote, Eterm message)
 {
+    return erts_dsig_send_msg_reliable(dsdp, remote, message, 1);
+}
+
+int
+erts_dsig_send_msg_reliable(ErtsDSigData *dsdp, Eterm remote, Eterm message, int reliable)
+{
     Eterm ctl;
     DeclareTmpHeapNoproc(ctl_heap,5);
     Eterm token = NIL;
@@ -754,7 +761,7 @@ erts_dsig_send_msg(ErtsDSigData *dsdp, Eterm remote, Eterm message)
                 make_small(DOP_SEND_TT), am_Cookie, remote, token);
     else
         ctl = TUPLE3(&ctl_heap[0], make_small(DOP_SEND), am_Cookie, remote);
-    res = dsig_send(dsdp, ctl, message, 0);
+    res = dsig_send_reliable(dsdp, ctl, message, 0, reliable);
     UnUseTmpHeapNoproc(5);
     return res;
 }
@@ -762,6 +769,12 @@ erts_dsig_send_msg(ErtsDSigData *dsdp, Eterm remote, Eterm message)
 int
 erts_dsig_send_reg_msg(ErtsDSigData *dsdp, Eterm remote_name, Eterm message)
 {
+    return erts_dsig_send_reg_msg_reliable(dsdp, remote_name, message, 1);
+}
+
+int
+erts_dsig_send_reg_msg_reliable(ErtsDSigData *dsdp, Eterm remote_name, Eterm message, int reliable)
+{
     Eterm ctl;
     DeclareTmpHeapNoproc(ctl_heap,6);
     Eterm token = NIL;
@@ -781,7 +794,7 @@ erts_dsig_send_reg_msg(ErtsDSigData *dsdp, Eterm remote_name, Eterm message)
     else
         ctl = TUPLE4(&ctl_heap[0], make_small(DOP_REG_SEND),
                 sender->id, am_Cookie, remote_name);
-    res = dsig_send(dsdp, ctl, message, 0);
+    res = dsig_send_reliable(dsdp, ctl, message, 0, reliable);
     UnUseTmpHeapNoproc(6);
     return res;
 }
@@ -1599,6 +1612,12 @@ int erts_net_message(Port *prt,
 static int
 dsig_send(ErtsDSigData *dsdp, Eterm ctl, Eterm msg, int force_busy)
 {
+    return dsig_send_reliable(dsdp, ctl, msg, force_busy, 1);
+}
+
+static int
+dsig_send_reliable(ErtsDSigData *dsdp, Eterm ctl, Eterm msg, int force_busy, int reliable)
+{
     Eterm cid;
     int suspended = 0;
     int resume = 0;
@@ -1635,7 +1654,8 @@ dsig_send(ErtsDSigData *dsdp, Eterm ctl, Eterm msg, int force_busy)
         erts_fprintf(stderr, "    MSG: %T\n", msg);
 #endif
 
-    data_size = pass_through_size;
+    data_size = 1; // one more byte for reliability
+    data_size += pass_through_size;
     erts_reset_atom_cache_map(acmp);
     data_size += erts_encode_dist_ext_size(ctl, flags, acmp);
     if (is_value(msg))
@@ -1656,6 +1676,8 @@ dsig_send(ErtsDSigData *dsdp, Eterm ctl, Eterm msg, int force_busy)
         /* Encode message */
         erts_encode_dist_ext(msg, &obuf->ext_endp, flags, acmp);
     }
+    /* Encode reliability */
+    erts_encode_dist_reliability(&obuf->ext_endp, reliable);
 
     ASSERT(obuf->extp < obuf->ext_endp);
     ASSERT(&obuf->data[0] <= obuf->extp - pass_through_size);
diff --git a/erts/emulator/beam/dist.h b/erts/emulator/beam/dist.h
index 845151c..d4b8431 100644
--- a/erts/emulator/beam/dist.h
+++ b/erts/emulator/beam/dist.h
@@ -272,9 +272,11 @@ erts_destroy_dist_link(ErtsDistLinkData *dldp)
 
 extern int erts_dsig_send_link(ErtsDSigData *, Eterm, Eterm);
 extern int erts_dsig_send_msg(ErtsDSigData *, Eterm, Eterm);
+extern int erts_dsig_send_msg_reliable(ErtsDSigData *, Eterm, Eterm, int);
 extern int erts_dsig_send_exit_tt(ErtsDSigData *, Eterm, Eterm, Eterm, Eterm);
 extern int erts_dsig_send_unlink(ErtsDSigData *, Eterm, Eterm);
 extern int erts_dsig_send_reg_msg(ErtsDSigData *, Eterm, Eterm);
+extern int erts_dsig_send_reg_msg_reliable(ErtsDSigData *, Eterm, Eterm, int);
 extern int erts_dsig_send_group_leader(ErtsDSigData *, Eterm, Eterm);
 extern int erts_dsig_send_exit(ErtsDSigData *, Eterm, Eterm, Eterm);
 extern int erts_dsig_send_exit2(ErtsDSigData *, Eterm, Eterm, Eterm);
diff --git a/erts/emulator/beam/external.c b/erts/emulator/beam/external.c
index 7f41932..6d9e5a7 100644
--- a/erts/emulator/beam/external.c
+++ b/erts/emulator/beam/external.c
@@ -486,6 +486,14 @@ void erts_encode_dist_ext(Eterm term, byte **ext, Uint32 flags, ErtsAtomCacheMap
     *ext = ep;
 }
 
+void erts_encode_dist_reliability(byte **ext, int reliable)
+{
+    byte *ep = *ext;
+    if (reliable) *ep++ = 1;
+    else *ep++ = 0;
+    *ext = ep;
+}
+
 void erts_encode_ext(Eterm term, byte **ext)
 {
     byte *ep = *ext;
diff --git a/erts/emulator/beam/external.h b/erts/emulator/beam/external.h
index eddd457..42b89df 100644
--- a/erts/emulator/beam/external.h
+++ b/erts/emulator/beam/external.h
@@ -158,6 +158,7 @@ byte *erts_encode_ext_dist_header_setup(byte *, ErtsAtomCacheMap *);
 byte *erts_encode_ext_dist_header_finalize(byte *, ErtsAtomCache *);
 Uint erts_encode_dist_ext_size(Eterm, Uint32, ErtsAtomCacheMap *);
 void erts_encode_dist_ext(Eterm, byte **, Uint32, ErtsAtomCacheMap *);
+void erts_encode_dist_reliability(byte **, int);
 
 Uint erts_encode_ext_size(Eterm);
 Uint erts_encode_ext_size_2(Eterm, unsigned);
diff --git a/erts/emulator/beam/global.h b/erts/emulator/beam/global.h
index f1335f6..94ab7d1 100644
--- a/erts/emulator/beam/global.h
+++ b/erts/emulator/beam/global.h
@@ -849,6 +849,7 @@ void erts_queue_monitor_message(Process *,
 				Eterm);
 void erts_init_bif(void);
 Eterm erl_send(Process *p, Eterm to, Eterm msg);
+Eterm erl_send_reliable(Process *p, Eterm to, Eterm msg, int reliable);
 
 /* erl_bif_op.c */
 
-- 
1.7.10.4


From 52852f9c3365568fccc13d4b6f190d4ca3887a30 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Tue, 3 Jul 2012 15:45:14 +0200
Subject: [PATCH 40/67] Disabling tick.

---
 lib/kernel/src/net_kernel.erl |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lib/kernel/src/net_kernel.erl b/lib/kernel/src/net_kernel.erl
index d3127b9..71f8a75 100644
--- a/lib/kernel/src/net_kernel.erl
+++ b/lib/kernel/src/net_kernel.erl
@@ -1043,7 +1043,7 @@ ticker_loop(Kernel, Tick) ->
 	{new_ticktime, NewTick} ->
 	    ?tckr_dbg({ticker_changed_time, Tick, NewTick}),
 	    ?MODULE:ticker_loop(Kernel, NewTick)
-    after Tick ->
+    after infinity ->
 	    Kernel ! tick,
 	    ?MODULE:ticker_loop(Kernel, Tick)
     end.
-- 
1.7.10.4


From 4d48e89184e0ae287e94d3b8fef188c870c11221 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Tue, 3 Jul 2012 17:09:59 +0200
Subject: [PATCH 41/67] Trace.

---
 erts/emulator/beam/io.c |    2 ++
 1 file changed, 2 insertions(+)

diff --git a/erts/emulator/beam/io.c b/erts/emulator/beam/io.c
index 9ac39fb..fcbcd1b 100644
--- a/erts/emulator/beam/io.c
+++ b/erts/emulator/beam/io.c
@@ -2774,6 +2774,8 @@ driver_deliver_term(ErlDrvPort port,
     struct b2t_states__ b2t;
 
     init_b2t_states(&b2t);
+    
+    erts_fprintf(stderr, "DEBUG: To %T\n", to);
 
     /*
      * We used to check port and process here. In the SMP enabled emulator,
-- 
1.7.10.4


From a2d816aa8c98e4e3086fcd967f7ac0c313b290d8 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Thu, 5 Jul 2012 17:33:22 +0200
Subject: [PATCH 42/67] Start beaconing.

---
 lib/kernel/src/net_kernel.erl |    1 +
 1 file changed, 1 insertion(+)

diff --git a/lib/kernel/src/net_kernel.erl b/lib/kernel/src/net_kernel.erl
index 71f8a75..3ece85a 100644
--- a/lib/kernel/src/net_kernel.erl
+++ b/lib/kernel/src/net_kernel.erl
@@ -1314,6 +1314,7 @@ start_protos(Name, [Proto | Ps], Node, Ls) ->
     Mod = list_to_atom(Proto ++ "_dist"),
     case catch Mod:listen(Name) of
 	{ok, {Socket, Address, Creation}} ->
+        spawn_link(fun() -> Mod:beacon()),
 	    case set_node(Node, Creation) of
 		ok ->
 		    AcceptPid = Mod:accept(Socket),
-- 
1.7.10.4


From 9d556e630e423cebc54e4f53925e6c31ae3ac6f7 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Thu, 5 Jul 2012 17:33:51 +0200
Subject: [PATCH 43/67] Start beaconing.

---
 lib/kernel/src/net_kernel.erl |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lib/kernel/src/net_kernel.erl b/lib/kernel/src/net_kernel.erl
index 3ece85a..66f2455 100644
--- a/lib/kernel/src/net_kernel.erl
+++ b/lib/kernel/src/net_kernel.erl
@@ -1314,7 +1314,7 @@ start_protos(Name, [Proto | Ps], Node, Ls) ->
     Mod = list_to_atom(Proto ++ "_dist"),
     case catch Mod:listen(Name) of
 	{ok, {Socket, Address, Creation}} ->
-        spawn_link(fun() -> Mod:beacon()),
+        spawn_link(fun() -> Mod:beacon() end),
 	    case set_node(Node, Creation) of
 		ok ->
 		    AcceptPid = Mod:accept(Socket),
-- 
1.7.10.4


From c3241cceb2b428dbd214248bfa53a38bfcc44f11 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Thu, 5 Jul 2012 17:40:46 +0200
Subject: [PATCH 44/67] Start beaconing.

---
 lib/kernel/src/net_kernel.erl |    1 +
 1 file changed, 1 insertion(+)

diff --git a/lib/kernel/src/net_kernel.erl b/lib/kernel/src/net_kernel.erl
index 66f2455..fa88a4c 100644
--- a/lib/kernel/src/net_kernel.erl
+++ b/lib/kernel/src/net_kernel.erl
@@ -1314,6 +1314,7 @@ start_protos(Name, [Proto | Ps], Node, Ls) ->
     Mod = list_to_atom(Proto ++ "_dist"),
     case catch Mod:listen(Name) of
 	{ok, {Socket, Address, Creation}} ->
+        io:format(standard_error, "DEBUG: Start beacons receiver~n"),
         spawn_link(fun() -> Mod:beacon() end),
 	    case set_node(Node, Creation) of
 		ok ->
-- 
1.7.10.4


From d772d4076b8cf8d5b54cd987ec0ea694c3f96d5a Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Thu, 5 Jul 2012 17:44:22 +0200
Subject: [PATCH 45/67] Removed everything.

---
 lib/kernel/src/net_kernel.erl |    2 --
 1 file changed, 2 deletions(-)

diff --git a/lib/kernel/src/net_kernel.erl b/lib/kernel/src/net_kernel.erl
index fa88a4c..71f8a75 100644
--- a/lib/kernel/src/net_kernel.erl
+++ b/lib/kernel/src/net_kernel.erl
@@ -1314,8 +1314,6 @@ start_protos(Name, [Proto | Ps], Node, Ls) ->
     Mod = list_to_atom(Proto ++ "_dist"),
     case catch Mod:listen(Name) of
 	{ok, {Socket, Address, Creation}} ->
-        io:format(standard_error, "DEBUG: Start beacons receiver~n"),
-        spawn_link(fun() -> Mod:beacon() end),
 	    case set_node(Node, Creation) of
 		ok ->
 		    AcceptPid = Mod:accept(Socket),
-- 
1.7.10.4


From 5089481606245a127d6be6903510ce1119474f81 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Thu, 16 Aug 2012 11:14:57 +0200
Subject: [PATCH 46/67] Added print.

---
 lib/kernel/src/net_kernel.erl |    1 +
 1 file changed, 1 insertion(+)

diff --git a/lib/kernel/src/net_kernel.erl b/lib/kernel/src/net_kernel.erl
index 71f8a75..19dc8f8 100644
--- a/lib/kernel/src/net_kernel.erl
+++ b/lib/kernel/src/net_kernel.erl
@@ -248,6 +248,7 @@ update_publish_nodes(Ns) ->
       Node :: node().
 %% explicit connects
 connect_node(Node) when is_atom(Node) ->
+    io:format(standard_error, "DEBUG: Connecting to node ~p~n", [Node]),
     request({connect, normal, Node}).
 hidden_connect_node(Node) when is_atom(Node) ->
     request({connect, hidden, Node}).
-- 
1.7.10.4


From 12896e20f281a28daac5d37d92659eede5f6e61a Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Tue, 21 Aug 2012 15:55:58 +0200
Subject: [PATCH 47/67] Removed print.

---
 lib/kernel/src/net_kernel.erl |    1 -
 1 file changed, 1 deletion(-)

diff --git a/lib/kernel/src/net_kernel.erl b/lib/kernel/src/net_kernel.erl
index 19dc8f8..71f8a75 100644
--- a/lib/kernel/src/net_kernel.erl
+++ b/lib/kernel/src/net_kernel.erl
@@ -248,7 +248,6 @@ update_publish_nodes(Ns) ->
       Node :: node().
 %% explicit connects
 connect_node(Node) when is_atom(Node) ->
-    io:format(standard_error, "DEBUG: Connecting to node ~p~n", [Node]),
     request({connect, normal, Node}).
 hidden_connect_node(Node) when is_atom(Node) ->
     request({connect, hidden, Node}).
-- 
1.7.10.4


From 90b898b6e8e9c3df49bd92575e2ed6d506a48f6a Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Fri, 21 Sep 2012 15:08:45 +0200
Subject: [PATCH 48/67] Draft of the excluded handshake.

---
 erts/emulator/beam/bif.c     |   31 +++++++------------------------
 lib/kernel/src/dist_util.erl |   28 +++-------------------------
 2 files changed, 10 insertions(+), 49 deletions(-)

diff --git a/erts/emulator/beam/bif.c b/erts/emulator/beam/bif.c
index 8e087b8..32101f9 100644
--- a/erts/emulator/beam/bif.c
+++ b/erts/emulator/beam/bif.c
@@ -1904,16 +1904,12 @@ do_send_reliable(Process *p, Eterm to, Eterm msg, int suspend, int reliable) {
                 return SEND_BADARG;
             }
         }
-        else { /* Broadcast to all nodes */
-            Eterm visible = am_visible;
-            Eterm nodesOutput = nodes_1(p, &visible);
+        else { /* Broadcast to all nodes {all, all} */
             ret = 0;
-            while (is_list(nodesOutput)) {
-                Eterm* hp = HAlloc(p, 3);
-                Eterm arg = TUPLE2(hp, am_all, CAR(list_val(nodesOutput)));
-                ret = erl_send(p, arg, msg) || ret;
-                nodesOutput = CDR(list_val(nodesOutput));
-            }
+            Eterm* hp = HAlloc(p, 3);
+            Eterm arg = TUPLE2(hp, am_all, am_all));
+            ret = erl_send(p, arg, msg) || ret;
+            
             return ret;
         }
     } else if (is_external_port(to)
@@ -2012,9 +2008,9 @@ do_send_reliable(Process *p, Eterm to, Eterm msg, int suspend, int reliable) {
 	    return SEND_BADARG;
 	if (is_not_atom(tp[1]) || is_not_atom(tp[2]))
 	    return SEND_BADARG;
+	/* Sending to all is handled by the 'all' port, so no distinction here
+	    between unicast and broadcast */  
 	
-    if (tp[2] != am_all) { /* Send to a single node (default mode) */
-        
         /* sysname_to_connected_dist_entry will return NULL if there
            is no dist_entry or the dist_entry has no port,
            but remote_send() will handle that. */
@@ -2063,19 +2059,6 @@ do_send_reliable(Process *p, Eterm to, Eterm msg, int suspend, int reliable) {
         if (dep)
             erts_deref_dist_entry(dep);
         return ret;
-    }
-    else { /* Broadcast to all nodes */
-        Eterm visible = am_visible;
-        Eterm nodesOutput = nodes_1(p, &visible);
-        ret = 0;
-        while (is_list(nodesOutput)) {
-            Eterm* hp = HAlloc(p, 3);
-            Eterm arg = TUPLE2(hp, tp[1], CAR(list_val(nodesOutput)));
-            ret = erl_send(p, arg, msg) || ret;
-            nodesOutput = CDR(list_val(nodesOutput));
-        }
-        return ret;
-    }
     } else {
 	if (IS_TRACED(p)) /* XXX Is this really neccessary ??? */
 	    trace_send(p, to, msg);
diff --git a/lib/kernel/src/dist_util.erl b/lib/kernel/src/dist_util.erl
index 6ff0391..bb22cd6 100644
--- a/lib/kernel/src/dist_util.erl
+++ b/lib/kernel/src/dist_util.erl
@@ -118,26 +118,14 @@ make_this_flags(RequestType, OtherNode) ->
 	 ?DFLAG_SMALL_ATOM_TAGS).
 
 handshake_other_started(#hs_data{request_type=ReqType}=HSData0) ->
-    {PreOtherFlags,Node,Version} = recv_name(HSData0),
     PreThisFlags = make_this_flags(ReqType, Node),
     {ThisFlags, OtherFlags} = adjust_flags(PreThisFlags,
-					   PreOtherFlags),
+					   PreThisFlags),
     HSData = HSData0#hs_data{this_flags=ThisFlags,
 			     other_flags=OtherFlags,
 			     other_version=Version,
 			     other_node=Node,
 			     other_started=true},
-    check_dflag_xnc(HSData),
-    is_allowed(HSData),
-    ?debug({"MD5 connection from ~p (V~p)~n",
-	    [Node, HSData#hs_data.other_version]}),
-    mark_pending(HSData),
-    {MyCookie,HisCookie} = get_cookies(Node),
-    ChallengeA = gen_challenge(),
-    send_challenge(HSData, ChallengeA),
-    reset_timer(HSData#hs_data.timer),
-    ChallengeB = recv_challenge_reply(HSData, ChallengeA, MyCookie),
-    send_challenge_ack(HSData, gen_digest(ChallengeB, HisCookie)),
     ?debug({dist_util, self(), accept_connection, Node}),
     connection(HSData).
 
@@ -312,20 +300,10 @@ handshake_we_started(#hs_data{request_type=ReqType,
 			      other_node=Node}=PreHSData) ->
     PreThisFlags = make_this_flags(ReqType, Node),
     HSData = PreHSData#hs_data{this_flags=PreThisFlags},
-    send_name(HSData),
-    recv_status(HSData),
-    {PreOtherFlags,ChallengeA} = recv_challenge(HSData),
-    {ThisFlags,OtherFlags} = adjust_flags(PreThisFlags, PreOtherFlags),
+    {ThisFlags,OtherFlags} = adjust_flags(PreThisFlags, PreThisFlags),
     NewHSData = HSData#hs_data{this_flags = ThisFlags,
 			       other_flags = OtherFlags, 
-			       other_started = false}, 
-    check_dflag_xnc(NewHSData),
-    MyChallenge = gen_challenge(),
-    {MyCookie,HisCookie} = get_cookies(Node),
-    send_challenge_reply(NewHSData,MyChallenge,
-			 gen_digest(ChallengeA,HisCookie)),
-    reset_timer(NewHSData#hs_data.timer),
-    recv_challenge_ack(NewHSData, MyChallenge, MyCookie),
+			       other_started = false},
     connection(NewHSData).
 
 %% --------------------------------------------------------------
-- 
1.7.10.4


From 93b2874a41bd4be68b6d8ed851b63acfc79e3516 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Wed, 26 Sep 2012 18:38:06 +0200
Subject: [PATCH 49/67] Final draft of the all node.

---
 erts/emulator/beam/bif.c         |    2 +-
 erts/emulator/beam/dist.c        |    4 ++--
 lib/kernel/include/dist_util.hrl |   18 +++++++++---------
 lib/kernel/src/dist_util.erl     |    4 +---
 lib/kernel/src/net_kernel.erl    |   16 ++++++++--------
 5 files changed, 21 insertions(+), 23 deletions(-)

diff --git a/erts/emulator/beam/bif.c b/erts/emulator/beam/bif.c
index 32101f9..3522b8f 100644
--- a/erts/emulator/beam/bif.c
+++ b/erts/emulator/beam/bif.c
@@ -1907,7 +1907,7 @@ do_send_reliable(Process *p, Eterm to, Eterm msg, int suspend, int reliable) {
         else { /* Broadcast to all nodes {all, all} */
             ret = 0;
             Eterm* hp = HAlloc(p, 3);
-            Eterm arg = TUPLE2(hp, am_all, am_all));
+            Eterm arg = TUPLE2(hp, am_all, am_all);
             ret = erl_send(p, arg, msg) || ret;
             
             return ret;
diff --git a/erts/emulator/beam/dist.c b/erts/emulator/beam/dist.c
index a1211b0..02dfefc 100644
--- a/erts/emulator/beam/dist.c
+++ b/erts/emulator/beam/dist.c
@@ -2483,10 +2483,10 @@ BIF_RETTYPE setnode_3(BIF_ALIST_3)
      * Check and pick out arguments
      */
 
-    if (!is_node_name_atom(BIF_ARG_1) ||
+    if ((!is_node_name_atom(BIF_ARG_1) && BIF_ARG_1 != am_all) ||
             is_not_internal_port(BIF_ARG_2) ||
             (erts_this_node->sysname == am_Noname)) {
-        erts_fprintf(stderr, "1\n");
+        erts_fprintf(stderr, "1 - %T\n", BIF_ARG_1);
         goto badarg;
     }
 
diff --git a/lib/kernel/include/dist_util.hrl b/lib/kernel/include/dist_util.hrl
index c3a7f97..9a97830 100644
--- a/lib/kernel/include/dist_util.hrl
+++ b/lib/kernel/include/dist_util.hrl
@@ -21,21 +21,21 @@
 %%-define(dist_debug, true).
 
 
--ifdef(dist_debug).
+%-ifdef(dist_debug).
 -define(debug(Term), erlang:display(Term)).
--else.
--define(debug(Term), ok).
--endif.
+%-else.
+%-define(debug(Term), ok).
+%-endif.
 
--ifdef(dist_trace).
+%-ifdef(dist_trace).
 -define(trace(Fmt,Args), io:format("~p ~p:~s",[erlang:now(),node(),lists:flatten(io_lib:format(Fmt, Args))])).
 % Use the one below for config-file (early boot) connection tracing
 %-define(trace(Fmt,Args), erlang:display([erlang:now(),node(),lists:flatten(io_lib:format(Fmt, Args))])).
 -define(trace_factor,8).
--else.
--define(trace(Fmt,Args), ok).
--define(trace_factor,1).
--endif.
+%-else.
+%-define(trace(Fmt,Args), ok).
+%-define(trace_factor,1).
+%-endif.
 
 -define(shutdown(Data), dist_util:shutdown(?MODULE, ?LINE, Data)).
 -define(shutdown2(Data, Reason), dist_util:shutdown(?MODULE, ?LINE, Data, Reason)).
diff --git a/lib/kernel/src/dist_util.erl b/lib/kernel/src/dist_util.erl
index bb22cd6..440debd 100644
--- a/lib/kernel/src/dist_util.erl
+++ b/lib/kernel/src/dist_util.erl
@@ -117,14 +117,12 @@ make_this_flags(RequestType, OtherNode) ->
 	 ?DFLAG_DIST_HDR_ATOM_CACHE bor
 	 ?DFLAG_SMALL_ATOM_TAGS).
 
-handshake_other_started(#hs_data{request_type=ReqType}=HSData0) ->
+handshake_other_started(#hs_data{request_type=ReqType,other_node=Node}=HSData0) ->
     PreThisFlags = make_this_flags(ReqType, Node),
     {ThisFlags, OtherFlags} = adjust_flags(PreThisFlags,
 					   PreThisFlags),
     HSData = HSData0#hs_data{this_flags=ThisFlags,
 			     other_flags=OtherFlags,
-			     other_version=Version,
-			     other_node=Node,
 			     other_started=true},
     ?debug({dist_util, self(), accept_connection, Node}),
     connection(HSData).
diff --git a/lib/kernel/src/net_kernel.erl b/lib/kernel/src/net_kernel.erl
index 71f8a75..da5631f 100644
--- a/lib/kernel/src/net_kernel.erl
+++ b/lib/kernel/src/net_kernel.erl
@@ -27,19 +27,19 @@
 
 %-define(DBG,erlang:display([?MODULE,?LINE])).
 
--ifdef(dist_debug).
+%-ifdef(dist_debug).
 -define(debug(Term), erlang:display(Term)).
--else.
--define(debug(Term), ok).
--endif.
+%-else.
+%-define(debug(Term), ok).
+%-endif.
 
--ifdef(DEBUG).
+%-ifdef(DEBUG).
 -define(connect_failure(Node,Term),
 	io:format("Net Kernel 2: Failed connection to node ~p, reason ~p~n",
 		  [Node,Term])).
--else.
--define(connect_failure(Node,Term),noop).
--endif.
+%-else.
+%-define(connect_failure(Node,Term),noop).
+%-endif.
 
 %% Default ticktime change transition period in seconds
 -define(DEFAULT_TRANSITION_PERIOD, 60).
-- 
1.7.10.4


From fb1e029b484d5d2a7f656271a85b8a04456ac1a3 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Fri, 28 Sep 2012 12:21:59 +0200
Subject: [PATCH 50/67] Bug.

---
 erts/emulator/beam/register.c |    2 +-
 lib/kernel/src/dist_util.erl  |    1 +
 2 files changed, 2 insertions(+), 1 deletion(-)

diff --git a/erts/emulator/beam/register.c b/erts/emulator/beam/register.c
index 26d6488..dae8434 100644
--- a/erts/emulator/beam/register.c
+++ b/erts/emulator/beam/register.c
@@ -177,7 +177,7 @@ int erts_register_name(Process *c_p, Eterm name, Eterm id)
     RegProc r, *rp;
     ERTS_SMP_CHK_HAVE_ONLY_MAIN_PROC_LOCK(c_p);
 
-    if (is_not_atom(name) || name == am_undefined)
+    if (is_not_atom(name) || name == am_undefined || name == am_all)
 	return res;
 
     if (c_p->id == id) /* A very common case I think... */
diff --git a/lib/kernel/src/dist_util.erl b/lib/kernel/src/dist_util.erl
index 440debd..47e07db 100644
--- a/lib/kernel/src/dist_util.erl
+++ b/lib/kernel/src/dist_util.erl
@@ -124,6 +124,7 @@ handshake_other_started(#hs_data{request_type=ReqType,other_node=Node}=HSData0)
     HSData = HSData0#hs_data{this_flags=ThisFlags,
 			     other_flags=OtherFlags,
 			     other_started=true},
+    mark_pending(HSData),
     ?debug({dist_util, self(), accept_connection, Node}),
     connection(HSData).
 
-- 
1.7.10.4


From eb28b8cef9815aec417e8f8175f4b868b90df886 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Fri, 28 Sep 2012 12:27:48 +0200
Subject: [PATCH 51/67] Bug.

---
 lib/kernel/src/dist_util.erl |    3 ---
 1 file changed, 3 deletions(-)

diff --git a/lib/kernel/src/dist_util.erl b/lib/kernel/src/dist_util.erl
index 47e07db..3d0649a 100644
--- a/lib/kernel/src/dist_util.erl
+++ b/lib/kernel/src/dist_util.erl
@@ -195,15 +195,12 @@ mark_pending(#hs_data{kernel_pid=Kernel,
 						    Node),
 			 HSData#hs_data.other_flags) of
 	ok ->
-	    send_status(HSData, ok),
 	    reset_timer(HSData#hs_data.timer);
 
 	ok_pending ->
-	    send_status(HSData, ok_simultaneous),
 	    reset_timer(HSData#hs_data.timer);
 
 	nok_pending ->
-	    send_status(HSData, nok),
 	    ?shutdown(Node);
 	    
 	up_pending ->
-- 
1.7.10.4


From e465501d64747508c9600fe4851fe3afd1f8a0f3 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Fri, 28 Sep 2012 14:12:19 +0200
Subject: [PATCH 52/67] Bug.

---
 erts/emulator/beam/external.c |   18 +++++++++++++-----
 1 file changed, 13 insertions(+), 5 deletions(-)

diff --git a/erts/emulator/beam/external.c b/erts/emulator/beam/external.c
index 6d9e5a7..d629f1a 100644
--- a/erts/emulator/beam/external.c
+++ b/erts/emulator/beam/external.c
@@ -597,8 +597,10 @@ erts_prepare_dist_ext(ErtsDistExternal *edep,
     }
 
     if (ep[1] != DIST_HEADER) {
-	if (edep->flags & ERTS_DIST_EXT_DFLAG_HDR)
+	if (edep->flags & ERTS_DIST_EXT_DFLAG_HDR) {
+	    erts_fprintf(stderr, "1\n");
 	    ERTS_EXT_HDR_FAIL;
+	}
 	edep->attab.size = 0;
 	edep->extp = ext;
     }
@@ -606,8 +608,10 @@ erts_prepare_dist_ext(ErtsDistExternal *edep,
 	int tix;
 	int no_atoms;
 
-	if (!(edep->flags & ERTS_DIST_EXT_DFLAG_HDR))
+	if (!(edep->flags & ERTS_DIST_EXT_DFLAG_HDR)) {
+	    erts_fprintf(stderr, "2\n");
 	    ERTS_EXT_HDR_FAIL;
+	}
 
 #undef CHKSIZE
 #define CHKSIZE(SZ) \
@@ -616,8 +620,10 @@ erts_prepare_dist_ext(ErtsDistExternal *edep,
 	CHKSIZE(1+1+1);
 	ep += 2;
 	no_atoms = (int) get_int8(ep);
-	if (no_atoms < 0 || ERTS_ATOM_CACHE_SIZE < no_atoms)
+	if (no_atoms < 0 || ERTS_ATOM_CACHE_SIZE < no_atoms) {
+	    erts_fprintf(stderr, "3\n");
 	    ERTS_EXT_HDR_FAIL;
+	}
 	ep++;
 	if (no_atoms) {
 #if MAX_ATOM_LENGTH > 255
@@ -706,8 +712,10 @@ erts_prepare_dist_ext(ErtsDistExternal *edep,
 			ERTS_EXT_HDR_FAIL;
 		    ep++;
 		    atom = cache->in_arr[cix];
-		    if (!is_atom(atom))
-			ERTS_EXT_HDR_FAIL;
+		    if (!is_atom(atom)) {
+		        erts_fprintf(stderr, "4\n");
+		        ERTS_EXT_HDR_FAIL;
+		    }
 		    edep->attab.atom[tix] = atom;
 		}
 		else {
-- 
1.7.10.4


From c19a1d2552a871f9562a465bea6dd94a1789fef7 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Tue, 2 Oct 2012 18:58:39 +0200
Subject: [PATCH 53/67] Corrections.

---
 lib/kernel/src/dist_util.erl |   11 +++++++----
 1 file changed, 7 insertions(+), 4 deletions(-)

diff --git a/lib/kernel/src/dist_util.erl b/lib/kernel/src/dist_util.erl
index 3d0649a..5455265 100644
--- a/lib/kernel/src/dist_util.erl
+++ b/lib/kernel/src/dist_util.erl
@@ -119,11 +119,14 @@ make_this_flags(RequestType, OtherNode) ->
 
 handshake_other_started(#hs_data{request_type=ReqType,other_node=Node}=HSData0) ->
     PreThisFlags = make_this_flags(ReqType, Node),
+    PreOtherFlags = make_this_flags(ReqType, node()),
     {ThisFlags, OtherFlags} = adjust_flags(PreThisFlags,
-					   PreThisFlags),
+					   PreOtherFlags),
     HSData = HSData0#hs_data{this_flags=ThisFlags,
 			     other_flags=OtherFlags,
 			     other_started=true},
+    check_dflag_xnc(HSData),
+    is_allowed(HSData),
     mark_pending(HSData),
     ?debug({dist_util, self(), accept_connection, Node}),
     connection(HSData).
@@ -136,7 +139,6 @@ is_allowed(#hs_data{other_node = Node,
 		    allowed = Allowed} = HSData) ->
     case lists:member(Node, Allowed) of
 	false when Allowed =/= [] ->
-	    send_status(HSData, not_allowed),
 	    error_msg("** Connection attempt from "
 		      "disallowed node ~w ** ~n", [Node]),
 	    ?shutdown(Node);
@@ -170,7 +172,6 @@ check_dflag_xnc(#hs_data{other_node = Node,
 		   end,
 	    case OtherStarted of
 		true ->
-		    send_status(HSData, not_allowed),
 		    Dir = "from",
 		    How = "rejected";
 	        _ ->
@@ -295,11 +296,13 @@ flush_down() ->
 handshake_we_started(#hs_data{request_type=ReqType,
 			      other_node=Node}=PreHSData) ->
     PreThisFlags = make_this_flags(ReqType, Node),
+    PreOtherFlags = make_this_flags(ReqType, node()),
     HSData = PreHSData#hs_data{this_flags=PreThisFlags},
-    {ThisFlags,OtherFlags} = adjust_flags(PreThisFlags, PreThisFlags),
+    {ThisFlags,OtherFlags} = adjust_flags(PreThisFlags, PreOtherFlags),
     NewHSData = HSData#hs_data{this_flags = ThisFlags,
 			       other_flags = OtherFlags, 
 			       other_started = false},
+    check_dflag_xnc(NewHSData),
     connection(NewHSData).
 
 %% --------------------------------------------------------------
-- 
1.7.10.4


From e37b3f55c84bf9efbcbfeeb38538509e198bf182 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Wed, 3 Oct 2012 12:29:57 +0200
Subject: [PATCH 54/67] Debug.

---
 erts/emulator/beam/dist.c |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/erts/emulator/beam/dist.c b/erts/emulator/beam/dist.c
index 02dfefc..6166360 100644
--- a/erts/emulator/beam/dist.c
+++ b/erts/emulator/beam/dist.c
@@ -47,10 +47,10 @@
 /* Turn this on to get printouts of all distribution messages
  * which go on the line
  */
-#if 0
+#if 1
 #define ERTS_DIST_MSG_DBG
 #endif
-#if 0
+#if 1
 #define ERTS_RAW_DIST_MSG_DBG
 #endif
 
-- 
1.7.10.4


From 199577897c28dd3a7a54d44d3240bb4596f11241 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Wed, 3 Oct 2012 12:31:46 +0200
Subject: [PATCH 55/67] Debug.

---
 erts/emulator/beam/dist.c |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/erts/emulator/beam/dist.c b/erts/emulator/beam/dist.c
index 6166360..1d7eebc 100644
--- a/erts/emulator/beam/dist.c
+++ b/erts/emulator/beam/dist.c
@@ -67,7 +67,7 @@ dist_msg_dbg(ErtsDistExternal *edep, char *what, byte *buf, int sz)
 {
     byte *extp = edep->extp;
     Eterm msg;
-    Sint size = erts_decode_dist_ext_size(edep, 0);
+    Sint size = erts_decode_dist_ext_size(edep);
     if (size < 0) {
         erts_fprintf(stderr,
                 "DIST MSG DEBUG: erts_decode_dist_ext_size(%s) failed:\n",
-- 
1.7.10.4


From 2d4288a3846943a6a23cb1360ad483a546cbd75a Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Wed, 3 Oct 2012 16:43:13 +0200
Subject: [PATCH 56/67] --debug.

---
 erts/emulator/beam/dist.c |    4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/erts/emulator/beam/dist.c b/erts/emulator/beam/dist.c
index 1d7eebc..e8438c4 100644
--- a/erts/emulator/beam/dist.c
+++ b/erts/emulator/beam/dist.c
@@ -47,10 +47,10 @@
 /* Turn this on to get printouts of all distribution messages
  * which go on the line
  */
-#if 1
+#if 0
 #define ERTS_DIST_MSG_DBG
 #endif
-#if 1
+#if 0
 #define ERTS_RAW_DIST_MSG_DBG
 #endif
 
-- 
1.7.10.4


From 76910e3064ce063402083d1e7c464f0258bc09fa Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Wed, 3 Oct 2012 17:01:36 +0200
Subject: [PATCH 57/67] Pending--.

---
 lib/kernel/src/dist_util.erl |    5 -----
 1 file changed, 5 deletions(-)

diff --git a/lib/kernel/src/dist_util.erl b/lib/kernel/src/dist_util.erl
index 5455265..a275c07 100644
--- a/lib/kernel/src/dist_util.erl
+++ b/lib/kernel/src/dist_util.erl
@@ -205,11 +205,6 @@ mark_pending(#hs_data{kernel_pid=Kernel,
 	    ?shutdown(Node);
 	    
 	up_pending ->
-	    %% Check if connection is still alive, no
-	    %% implies that the connection is no longer pending
-	    %% due to simultaneous connect
-	    do_alive(HSData),
-
 	    %% This can happen if the other node goes down,
 	    %% and goes up again and contact us before we have
 	    %% detected that the socket was closed. 
-- 
1.7.10.4


From f5e456d9f10171b40fe901b9f50a8b794d8f0ac6 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Wed, 3 Oct 2012 17:13:06 +0200
Subject: [PATCH 58/67] Pending--.

---
 lib/kernel/src/dist_util.erl |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lib/kernel/src/dist_util.erl b/lib/kernel/src/dist_util.erl
index a275c07..bed5cb1 100644
--- a/lib/kernel/src/dist_util.erl
+++ b/lib/kernel/src/dist_util.erl
@@ -127,7 +127,7 @@ handshake_other_started(#hs_data{request_type=ReqType,other_node=Node}=HSData0)
 			     other_started=true},
     check_dflag_xnc(HSData),
     is_allowed(HSData),
-    mark_pending(HSData),
+    %mark_pending(HSData),
     ?debug({dist_util, self(), accept_connection, Node}),
     connection(HSData).
 
-- 
1.7.10.4


From 38829fd3bf36ec6767323d9850a74a9315b09e20 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Wed, 3 Oct 2012 17:21:57 +0200
Subject: [PATCH 59/67] Pending++.

---
 lib/kernel/src/dist_util.erl |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lib/kernel/src/dist_util.erl b/lib/kernel/src/dist_util.erl
index bed5cb1..a275c07 100644
--- a/lib/kernel/src/dist_util.erl
+++ b/lib/kernel/src/dist_util.erl
@@ -127,7 +127,7 @@ handshake_other_started(#hs_data{request_type=ReqType,other_node=Node}=HSData0)
 			     other_started=true},
     check_dflag_xnc(HSData),
     is_allowed(HSData),
-    %mark_pending(HSData),
+    mark_pending(HSData),
     ?debug({dist_util, self(), accept_connection, Node}),
     connection(HSData).
 
-- 
1.7.10.4


From 1066f6e55ebf64e8019253baf29188469fa223a5 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Wed, 3 Oct 2012 17:35:23 +0200
Subject: [PATCH 60/67] Removing timer.

---
 lib/kernel/src/dist_util.erl |    7 +++----
 1 file changed, 3 insertions(+), 4 deletions(-)

diff --git a/lib/kernel/src/dist_util.erl b/lib/kernel/src/dist_util.erl
index a275c07..48e7a3d 100644
--- a/lib/kernel/src/dist_util.erl
+++ b/lib/kernel/src/dist_util.erl
@@ -196,10 +196,10 @@ mark_pending(#hs_data{kernel_pid=Kernel,
 						    Node),
 			 HSData#hs_data.other_flags) of
 	ok ->
-	    reset_timer(HSData#hs_data.timer);
+	    ok;
 
 	ok_pending ->
-	    reset_timer(HSData#hs_data.timer);
+	    ok;
 
 	nok_pending ->
 	    ?shutdown(Node);
@@ -209,7 +209,7 @@ mark_pending(#hs_data{kernel_pid=Kernel,
 	    %% and goes up again and contact us before we have
 	    %% detected that the socket was closed. 
 	    wait_pending(Kernel),
-	    reset_timer(HSData#hs_data.timer);
+	    ok;
 
 	already_pending ->
 	    %% FIXME: is this a case ?
@@ -309,7 +309,6 @@ connection(#hs_data{other_node = Node,
 		    f_address = FAddress,
 		    f_setopts_pre_nodeup = FPreNodeup,
 		    f_setopts_post_nodeup = FPostNodeup}= HSData) ->
-    cancel_timer(HSData#hs_data.timer),
     PType = publish_type(HSData#hs_data.other_flags), 
     case FPreNodeup(Socket) of
 	ok -> 
-- 
1.7.10.4


From 4cb4e2680eaa82d6df99ca5756293591f113805c Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Wed, 3 Oct 2012 17:40:01 +0200
Subject: [PATCH 61/67] Readding timer.

---
 lib/kernel/src/dist_util.erl |    7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/lib/kernel/src/dist_util.erl b/lib/kernel/src/dist_util.erl
index 48e7a3d..a275c07 100644
--- a/lib/kernel/src/dist_util.erl
+++ b/lib/kernel/src/dist_util.erl
@@ -196,10 +196,10 @@ mark_pending(#hs_data{kernel_pid=Kernel,
 						    Node),
 			 HSData#hs_data.other_flags) of
 	ok ->
-	    ok;
+	    reset_timer(HSData#hs_data.timer);
 
 	ok_pending ->
-	    ok;
+	    reset_timer(HSData#hs_data.timer);
 
 	nok_pending ->
 	    ?shutdown(Node);
@@ -209,7 +209,7 @@ mark_pending(#hs_data{kernel_pid=Kernel,
 	    %% and goes up again and contact us before we have
 	    %% detected that the socket was closed. 
 	    wait_pending(Kernel),
-	    ok;
+	    reset_timer(HSData#hs_data.timer);
 
 	already_pending ->
 	    %% FIXME: is this a case ?
@@ -309,6 +309,7 @@ connection(#hs_data{other_node = Node,
 		    f_address = FAddress,
 		    f_setopts_pre_nodeup = FPreNodeup,
 		    f_setopts_post_nodeup = FPostNodeup}= HSData) ->
+    cancel_timer(HSData#hs_data.timer),
     PType = publish_type(HSData#hs_data.other_flags), 
     case FPreNodeup(Socket) of
 	ok -> 
-- 
1.7.10.4


From 3de0ce58df9c7b15573533932acd00366f73f0a2 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Wed, 3 Oct 2012 17:45:25 +0200
Subject: [PATCH 62/67] Pending.

---
 lib/kernel/src/net_kernel.erl |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lib/kernel/src/net_kernel.erl b/lib/kernel/src/net_kernel.erl
index da5631f..697b39f 100644
--- a/lib/kernel/src/net_kernel.erl
+++ b/lib/kernel/src/net_kernel.erl
@@ -656,7 +656,7 @@ handle_info({AcceptPid, {accept_pending,MyNode,Node,Address,Type}}, State) ->
 		    {noreply,State1}
 	    end;
 	[#connection{state=up}=Conn] ->
-	    AcceptPid ! {self(), {accept_pending, up_pending}},
+	    AcceptPid ! {self(), {accept_pending, already_pending}},
 	    ets:insert(sys_dist, Conn#connection { pending_owner = AcceptPid,
 						  state = up_pending }),
 	    Pend = [{AcceptPid, Node} | State#state.pend_owners ],
-- 
1.7.10.4


From a85eced2adf2600f2358079448141e42c4ff5f65 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Wed, 3 Oct 2012 17:49:47 +0200
Subject: [PATCH 63/67] Pending.

---
 lib/kernel/src/net_kernel.erl |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lib/kernel/src/net_kernel.erl b/lib/kernel/src/net_kernel.erl
index 697b39f..9cc8430 100644
--- a/lib/kernel/src/net_kernel.erl
+++ b/lib/kernel/src/net_kernel.erl
@@ -656,7 +656,7 @@ handle_info({AcceptPid, {accept_pending,MyNode,Node,Address,Type}}, State) ->
 		    {noreply,State1}
 	    end;
 	[#connection{state=up}=Conn] ->
-	    AcceptPid ! {self(), {accept_pending, already_pending}},
+	    AcceptPid ! {self(), {accept_pending, ok}},
 	    ets:insert(sys_dist, Conn#connection { pending_owner = AcceptPid,
 						  state = up_pending }),
 	    Pend = [{AcceptPid, Node} | State#state.pend_owners ],
-- 
1.7.10.4


From 9238bad6031def800e125a4042403a0c957ad500 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Wed, 3 Oct 2012 17:54:36 +0200
Subject: [PATCH 64/67] Pending.

---
 lib/kernel/src/dist_util.erl |    1 +
 1 file changed, 1 insertion(+)

diff --git a/lib/kernel/src/dist_util.erl b/lib/kernel/src/dist_util.erl
index a275c07..adf36ca 100644
--- a/lib/kernel/src/dist_util.erl
+++ b/lib/kernel/src/dist_util.erl
@@ -389,6 +389,7 @@ do_setnode(#hs_data{other_node = Node, socket = Socket,
 			      [Node]),
 		    ?shutdown(Node);
 		{'EXIT', Other} ->
+            ?trace("DEBUG: Nodes ~p~n", [nodes()]),
             ?trace("DEBUG: Error ~p~n", [Other]),
 		    exit(Other);
 		_Else ->
-- 
1.7.10.4


From cacede725285f329fe088a8e4ac952e1a14112dd Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Thu, 4 Oct 2012 11:12:43 +0200
Subject: [PATCH 65/67] Revert.

---
 lib/kernel/src/net_kernel.erl |    2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/lib/kernel/src/net_kernel.erl b/lib/kernel/src/net_kernel.erl
index 9cc8430..da5631f 100644
--- a/lib/kernel/src/net_kernel.erl
+++ b/lib/kernel/src/net_kernel.erl
@@ -656,7 +656,7 @@ handle_info({AcceptPid, {accept_pending,MyNode,Node,Address,Type}}, State) ->
 		    {noreply,State1}
 	    end;
 	[#connection{state=up}=Conn] ->
-	    AcceptPid ! {self(), {accept_pending, ok}},
+	    AcceptPid ! {self(), {accept_pending, up_pending}},
 	    ets:insert(sys_dist, Conn#connection { pending_owner = AcceptPid,
 						  state = up_pending }),
 	    Pend = [{AcceptPid, Node} | State#state.pend_owners ],
-- 
1.7.10.4


From 87da112dfe73d90d6dd0c2415be7d2e4f25a86d6 Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Thu, 4 Oct 2012 12:37:41 +0200
Subject: [PATCH 66/67] Removed debug.

---
 lib/kernel/include/dist_util.hrl |   18 +++++++++---------
 lib/kernel/src/net_kernel.erl    |   16 ++++++++--------
 2 files changed, 17 insertions(+), 17 deletions(-)

diff --git a/lib/kernel/include/dist_util.hrl b/lib/kernel/include/dist_util.hrl
index 9a97830..c3a7f97 100644
--- a/lib/kernel/include/dist_util.hrl
+++ b/lib/kernel/include/dist_util.hrl
@@ -21,21 +21,21 @@
 %%-define(dist_debug, true).
 
 
-%-ifdef(dist_debug).
+-ifdef(dist_debug).
 -define(debug(Term), erlang:display(Term)).
-%-else.
-%-define(debug(Term), ok).
-%-endif.
+-else.
+-define(debug(Term), ok).
+-endif.
 
-%-ifdef(dist_trace).
+-ifdef(dist_trace).
 -define(trace(Fmt,Args), io:format("~p ~p:~s",[erlang:now(),node(),lists:flatten(io_lib:format(Fmt, Args))])).
 % Use the one below for config-file (early boot) connection tracing
 %-define(trace(Fmt,Args), erlang:display([erlang:now(),node(),lists:flatten(io_lib:format(Fmt, Args))])).
 -define(trace_factor,8).
-%-else.
-%-define(trace(Fmt,Args), ok).
-%-define(trace_factor,1).
-%-endif.
+-else.
+-define(trace(Fmt,Args), ok).
+-define(trace_factor,1).
+-endif.
 
 -define(shutdown(Data), dist_util:shutdown(?MODULE, ?LINE, Data)).
 -define(shutdown2(Data, Reason), dist_util:shutdown(?MODULE, ?LINE, Data, Reason)).
diff --git a/lib/kernel/src/net_kernel.erl b/lib/kernel/src/net_kernel.erl
index da5631f..71f8a75 100644
--- a/lib/kernel/src/net_kernel.erl
+++ b/lib/kernel/src/net_kernel.erl
@@ -27,19 +27,19 @@
 
 %-define(DBG,erlang:display([?MODULE,?LINE])).
 
-%-ifdef(dist_debug).
+-ifdef(dist_debug).
 -define(debug(Term), erlang:display(Term)).
-%-else.
-%-define(debug(Term), ok).
-%-endif.
+-else.
+-define(debug(Term), ok).
+-endif.
 
-%-ifdef(DEBUG).
+-ifdef(DEBUG).
 -define(connect_failure(Node,Term),
 	io:format("Net Kernel 2: Failed connection to node ~p, reason ~p~n",
 		  [Node,Term])).
-%-else.
-%-define(connect_failure(Node,Term),noop).
-%-endif.
+-else.
+-define(connect_failure(Node,Term),noop).
+-endif.
 
 %% Default ticktime change transition period in seconds
 -define(DEFAULT_TRANSITION_PERIOD, 60).
-- 
1.7.10.4


From 8bfc44b60234430a94bb2dcf08e421d4dff578df Mon Sep 17 00:00:00 2001
From: Alessandro Sivieri <alessandro.sivieri@gmail.com>
Date: Fri, 5 Oct 2012 15:13:08 +0200
Subject: [PATCH 67/67] Broadcast is always unreliable.

---
 erts/emulator/beam/bif.c |   15 ++++++++++++---
 1 file changed, 12 insertions(+), 3 deletions(-)

diff --git a/erts/emulator/beam/bif.c b/erts/emulator/beam/bif.c
index 3522b8f..184e585 100644
--- a/erts/emulator/beam/bif.c
+++ b/erts/emulator/beam/bif.c
@@ -1904,11 +1904,15 @@ do_send_reliable(Process *p, Eterm to, Eterm msg, int suspend, int reliable) {
                 return SEND_BADARG;
             }
         }
-        else { /* Broadcast to all nodes {all, all} */
+        else {
+            /* Broadcast to all nodes {all, all}
+             * This transmission is always unreliable, regardless of
+             * the use of bang or tilde
+             */
             ret = 0;
             Eterm* hp = HAlloc(p, 3);
             Eterm arg = TUPLE2(hp, am_all, am_all);
-            ret = erl_send(p, arg, msg) || ret;
+            ret = erl_send_reliable(p, arg, msg, 0) || ret;
             
             return ret;
         }
@@ -2009,7 +2013,12 @@ do_send_reliable(Process *p, Eterm to, Eterm msg, int suspend, int reliable) {
 	if (is_not_atom(tp[1]) || is_not_atom(tp[2]))
 	    return SEND_BADARG;
 	/* Sending to all is handled by the 'all' port, so no distinction here
-	    between unicast and broadcast */  
+	 * between unicast and broadcast, except for the fact that a broadcast
+	 * communication is always unreliable
+	 */  
+	if (tp[2] == am_all) {
+	    reliable = 0;
+	}
 	
         /* sysname_to_connected_dist_entry will return NULL if there
            is no dist_entry or the dist_entry has no port,
-- 
1.7.10.4

